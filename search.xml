<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android Overview]]></title>
      <url>http://robinheztto.com/2200/01/01/android-overview/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android学习提纲．从底至上．RTFSC．<strong>持续学习中…</strong></p>
</blockquote>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/android_framework_details.png?raw=true" alt="Android stack"><br></div>

<h1 id="BootFlow"><a href="#BootFlow" class="headerlink" title="BootFlow"></a>BootFlow</h1><ul>
<li><a href="http://www.robinheztto.com/2016/01/15/android-lk/" target="_blank" rel="external">Android之BootFlow</a></li>
<li><a href="http://www.robinheztto.com/2016/01/15/android-lk/" target="_blank" rel="external">Android之LK</a></li>
<li>[Android之Recovery]</li>
<li><a href="http://www.robinheztto.com/2016/02/01/android-init-language/" target="_blank" rel="external">Android之Init.rc语法</a></li>
<li><a href="http://www.robinheztto.com/2016/02/02/android-init/" target="_blank" rel="external">Android之Init</a></li>
<li><a href="http://www.robinheztto.com/2016/07/01/android-zygote-1/" target="_blank" rel="external">Android之Zygote-启动流程</a></li>
<li><a href="http://www.robinheztto.com/2016/07/02/android-zygote-2/" target="_blank" rel="external">Android之Zygote-应用进程创建</a></li>
<li><a href="http://www.robinheztto.com/2016/11/28/android-systemserver-1/" target="_blank" rel="external">Android之SystemServer启动(上)</a></li>
<li><a href="http://www.robinheztto.com/2016/11/28/android-systemserver-2/" target="_blank" rel="external">Android之SystemServer启动(下)</a></li>
</ul>
<hr>
<h1 id="PowerManagerment"><a href="#PowerManagerment" class="headerlink" title="PowerManagerment"></a>PowerManagerment</h1><ul>
<li><a href="http://www.robinheztto.com/2017/04/20/android-power-basic/" target="_blank" rel="external">Android电源管理系列之Basic</a></li>
<li><a href="http://www.robinheztto.com/2017/05/01/android-power-system-wakeup-events-framework/" target="_blank" rel="external">Android电源管理系列之System wakeup events framework</a></li>
<li><a href="http://www.robinheztto.com/2017/05/05/android-power-suspend/" target="_blank" rel="external">Android电源管理系列之Suspend</a></li>
<li><a href="http://www.robinheztto.com/2017/05/20/android-power-libsuspend/" target="_blank" rel="external">Android电源管理系列之libsuspend</a></li>
<li><a href="http://www.robinheztto.com/2017/06/01/android-power-wakelock/" target="_blank" rel="external">Android电源管理系列之Wakelock</a></li>
<li><a href="http://www.robinheztto.com/2017/06/14/android-power-pms-1/" target="_blank" rel="external">Android电源管理系列之PowerManagerService(一)</a></li>
<li><a href="http://www.robinheztto.com/2017/06/16/android-power-pms-2/" target="_blank" rel="external">Android电源管理系列之PowerManagerService(二)</a></li>
<li><a href="http://www.robinheztto.com/2017/09/11/android-power-doze-overview/" target="_blank" rel="external">Android电源管理系列之Doze</a></li>
<li><a href="http://www.robinheztto.com/2017/09/13/android-power-doze-light/" target="_blank" rel="external">Android电源管理系列之Light Doze</a></li>
<li><a href="http://www.robinheztto.com/2017/09/15/android-power-doze-deep/" target="_blank" rel="external">Android电源管理系列之Deep Doze</a></li>
</ul>
<hr>
<h1 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h1><ul>
<li><a href="http://www.robinheztto.com/2016/03/19/android-binder-0/" target="_blank" rel="external">Android Binder之概述</a></li>
<li><a href="http://www.robinheztto.com/2016/03/20/android-binder-1/" target="_blank" rel="external">Android Binder之Binder Driver</a></li>
<li><a href="http://www.robinheztto.com/2016/03/25/android-binder-2/" target="_blank" rel="external">Android Binder之Service Manager</a></li>
<li><a href="http://www.robinheztto.com/2016/03/28/android-binder-3/" target="_blank" rel="external">Android Binder之进程间通信库</a></li>
<li><a href="http://www.robinheztto.com/2016/03/28/android-binder-4/" target="_blank" rel="external">Android Binder之Service Manager代理对象</a></li>
<li><a href="http://www.robinheztto.com/2016/04/02/android-binder-5/" target="_blank" rel="external">Android Binder之Service启动</a></li>
<li><a href="http://www.robinheztto.com/2016/04/18/android-binder-6/" target="_blank" rel="external">Android Binder之Service代理获取</a></li>
<li><a href="http://www.robinheztto.com/2016/04/23/android-binder-7/" target="_blank" rel="external">Android Binder之Java接口</a></li>
</ul>
<hr>
<h1 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h1><ul>
<li><a href="http://www.robinheztto.com/2016/01/01/android-env/" target="_blank" rel="external">Android之Zygote-启动流程</a></li>
<li><a href="http://www.robinheztto.com/2016/01/01/android-env/" target="_blank" rel="external">Android之Zygote-应用进程创建</a></li>
<li><a href="http://www.robinheztto.com/2016/02/02/android-init/" target="_blank" rel="external">Android之SystemServer启动(上)</a></li>
<li><a href="http://www.robinheztto.com/2016/02/02/android-init/" target="_blank" rel="external">Android之SystemServer启动(下)</a></li>
<li><a href="http://www.robinheztto.com/2017/03/10/android-alarm-1/" target="_blank" rel="external">Android之AlarmManagerService(一)</a></li>
<li><a href="http://www.robinheztto.com/2017/03/11/android-alarm-2/" target="_blank" rel="external">Android之AlarmManagerService(二)</a></li>
<li><a href="http://www.robinheztto.com/2017/03/12/android-alarm-3/" target="_blank" rel="external">Android之AlarmManagerService(三)</a></li>
</ul>
<hr>
<h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><ul>
<li><a href="http://www.robinheztto.com/2016/01/01/android-env/" target="_blank" rel="external">Android Debug之系统启动</a></li>
</ul>
<hr>
<h1 id="Env-amp-Tools"><a href="#Env-amp-Tools" class="headerlink" title="Env&amp;Tools"></a>Env&amp;Tools</h1><ul>
<li><p><a href="http://www.robinheztto.com/2016/01/01/android-env/" target="_blank" rel="external">Android之开发环境搭建</a></p>
</li>
<li><p><a href="http://www.robinheztto.com/2016/01/05/android-tcpdump/" target="_blank" rel="external">Android之抓包</a></p>
</li>
</ul>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://free-electrons.com/pub/conferences/2012/captronic/android/android-captronic.pdf" target="_blank" rel="external">android-captronic</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android#Issue]]></title>
      <url>http://robinheztto.com/2100/01/01/android-issue/</url>
      <content type="html"><![CDATA[<p><strong>关于Android N平台java.lang.UnsatisfiedLinkError: dlopen failed的问题</strong></p>
<blockquote>
<p>Android N上应用Crash,log上报java.lang.UnsatisfiedLinkError，类似如下的log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dlopen failed: library &quot;libcutils.so&quot;</span><br><span class="line">(&quot;/system/lib/libcutils.so&quot;) needed or dlopened by</span><br><span class="line">&quot;/system/lib/libnativeloader.so&quot; is not accessible for the namespace</span><br><span class="line">&quot;classloader-namespace&quot;</span><br><span class="line">  at java.lang.Runtime.loadLibrary0(Runtime.java:977)</span><br><span class="line">  at java.lang.System.loadLibrary(System.java:1602)</span><br></pre></td></tr></table></figure></p>
<p>原因：<br>从Android N开始，系统将阻止应用动态链接非公开NDK库(参考官网描述<a href="https://developer.android.com/about/versions/nougat/android-7.0-changes.html" target="_blank" rel="external">android-7.0-changes</a>)<br>解决：<br>　1. so库打包到apk里面或参考官网解决<br>　2. 添加so到public.libraries.txt白名单.(参考<a href="http://blog.csdn.net/xiashaohua/article/details/52709630?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">android N : UnsatisfiedLinkError</a>)</p>
</blockquote>
<hr>
<p><strong>关于绕过默认短信应用限制读写短信的问题</strong></p>
<blockquote>
<p>Android 4.4以后，只有默认短信应用才具有读写短信的权限，系统应用比如垃圾短信拦截，一键换机等需要在未设置为默认短信应用的情况下读写短信数据库，可以利用以下代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ( 19 &gt;= Build.VERSION.SDK_INT) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        AppOpsManager appOpsManager = (AppOpsManager) sContext.getSystemService(&quot;appops&quot;);</span><br><span class="line">        appOpsManager.setMode(15, android.os.Process.myUid(), packageName, 0);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>具体原理参考<a href="http://3dobe.com/archives/51/" target="_blank" rel="external">Android 权限管理 AppOps</a></p>
<hr>
<p><strong>关于使用jack编译生成jar包</strong></p>
<blockquote>
<p>Jack是Java Android Compiler Kit的缩写，它直接将Java代码直接编译为字节码，不再生成classes.jar等中间文件，而是直接生成了classes.jack文件，需生成classes.jar时，可在Android.mk中添加如下定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_JACK_ENABLED=disabled</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Jack &amp; Jill参考<a href="https://yq.aliyun.com/articles/40811" target="_blank" rel="external">Android 新一代编译 toolchain Jack &amp; Jill 简介</a></p>
<hr>
<p><strong>关于Android Gradle Plugin</strong></p>
<blockquote>
<p>编译android gradle plugin</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir studio-master-dev</span><br><span class="line">$ cd studio-master-dev</span><br><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest -b studio-master-dev</span><br><span class="line">$ repo sync</span><br><span class="line">$ cd tools</span><br><span class="line">$ ./gradlew init</span><br><span class="line">$ ./gradlew assemble</span><br><span class="line">$ ./gradlew publishLocal</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于gradle不支持不支持msgid同名字符串的问题（由于不是标准Application做法）参考gradle plugin源码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sdk-common/src/main/java/com/android/ide/common/res2/ValueResourceParser2.java</span><br><span class="line">checkDuplicate() -&gt;</span><br><span class="line">else if (set.contains(name) &amp;&amp; resource.getType() != ResourceType.PUBLIC) &#123;</span><br><span class="line">				System.out.println(&quot;checkDuplicate ------&gt; &quot; + resource.getType());</span><br><span class="line">                throw MergingException.withMessage(</span><br><span class="line">                        &quot;Found item %s/%s more than one time&quot;,</span><br><span class="line">                        resource.getType().getDisplayName(), name).withFile(from).build();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://groups.google.com/forum/#!topic/android-building/dxP0tp0e1MI" target="_blank" rel="external">Gradle vs. Make for AOSP build</a><br><a href="http://tools.android.com/tech-docs" target="_blank" rel="external">Android Gradle</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android编译集成之gitolite]]></title>
      <url>http://robinheztto.com/2018/06/14/android-ci-gitolite/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在Git服务管理领域，主要有三种流行的方案:<br>Gitosis - 轻量级，开源项目，使用SSH公钥认证，只能做到库级的权限控制，目前项目已经停止开发，不再维护。<br>Gitolite - 轻量级，开源项目，使用SSH公钥认证，能做到分支级的权限控制。<br>Git + Repo + Gerrit - 超级重量级，集版本控制，库管理和代码审核为一身，可管理大型及超大型项目。</p>
</blockquote>
<p>Gitolite是在Git之上的一个授权层，依托sshd或者httpd来进行认证。Gitolite允许你定义访问许可不只作用于仓库，同样可作用于仓库中的每个branch和tag name，可确切定义用户(或一组人)只能push特定的”refs”(或者branches或者tags)。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Gitolite的安装需要分别在客户端和服务器端操作，搭建Gitolite的步骤如下图所示。<br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/ci/gitolite.png?raw=true" alt="Gitolite"></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li><p>安装openssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install  openssh-client</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装git</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成SSH key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C HF</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>运行命令后，一直按回车键直到SSH key生成。</p>
<ol>
<li>上传SSH public key到服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mv ~/.ssh/id_rsa.pub username.pub</span><br><span class="line">$ scp username.pub servername@server:/tmp</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>username及server根据实际情况填写。</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ol>
<li><p>安装openssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install openssh-server openssh-client</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装git</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装gitolite</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y install gitolite</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建gitolite用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser --system --shell /bin/bash --group --disabled-password --home /home/gitolite gitolite</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 777 /tmp/username.pub</span><br><span class="line">$ sudo su - gitolite</span><br><span class="line">$ gl-setup /tmp/username.pub</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的命令执行作用：<br>a)建立目录“~/repositories”，用来存储所有git仓库。<br>b)把公钥文件username.pub添加到 ～/.ssh/authorized_keys。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>gitolite的配置文件本身就是一个git仓库，gitolite的配置修改就是通过git实现的，先clone下来修改，再push上去。只要push上去，gitolite会立刻监视到配置文件的修改并应用。</p>
<h3 id="管理库"><a href="#管理库" class="headerlink" title="管理库"></a>管理库</h3><p>首先，在管理客户端clone管理库到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone gitolite@server:gitolite-admin.git</span><br></pre></td></tr></table></figure></p>
<p>管理库里的目录里有conf/和keydir/两个目录。</p>
<ul>
<li>conf/gitolite.conf 用于Git项目配置，访问权限设置。</li>
<li>keydir/ 用于存储用户的SSH public key(公钥）。</li>
</ul>
<p>如下所示, “username”(之前用gl-setup命令时候的pubkey名称)具有读写权限而且在gitolite-admin仓库里有一个同名的公钥文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat conf/gitolite.conf</span><br><span class="line"></span><br><span class="line">repo gitolite-admin</span><br><span class="line">    RW+                 = username</span><br></pre></td></tr></table></figure></p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><ol>
<li>用户/仓库分组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@oss_repos      = linux perl rakudo git gitolite</span><br><span class="line">@secret_repos   = fenestra pear</span><br><span class="line"></span><br><span class="line">@admins         = scott</span><br><span class="line">@interns        = ashok</span><br><span class="line">@engineers      = sitaram dilbert wally alice</span><br><span class="line">@staff          = @admins @engineers @interns</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在下面的例子里，实习生可以push ”int“分支。工程师可以push任何有”eng-“开头的branch，还有refs/tags下面用”rc”开头的后面跟数字的。而且管理员可以随便更改(包括rewind)对任何参考名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repo @oss_repos</span><br><span class="line">    RW  int$                = @interns</span><br><span class="line">    RW  eng-                = @engineers</span><br><span class="line">    RW  refs/tags/rc[0-9]   = @engineers</span><br><span class="line">    RW+                     = @admins</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android编译之签名机制]]></title>
      <url>http://robinheztto.com/2018/05/19/android-build-sign/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android OS 镜像在两个地方使用加密签名：</p>
<ol>
<li>映像中的所有.apk文件都必须经过签名。Android软件包管理器通过下列两种方式使用.apk 签名：<ul>
<li>更换应用时，必须使用与旧应用相同的密钥对其签名，才能存取旧应用的数据。无论是通过覆盖.apk 来更新用户应用，还是使用安装在 /data 下的新版本应用来覆盖系统应用，这一点都适用。</li>
<li>如果两个或多个应用想要共享同一个用户 ID（方便共享数据等），则必须使用相同的密钥对它们进行签名。</li>
</ul>
</li>
<li>必须使用符合系统预期的密钥对 OTA 更新包进行签名，否则在安装过程中 OTA 更新包将被拒绝。</li>
</ol>
</blockquote>
<h1 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h1><p>Android源码build/target/product/security目录下提供了测试密钥，包括platform，shared，media verity，test(testkey是作为android编译的时候默认的签名key，如果代码中apk的android.mk没有设置LOCAL_CERTIFICATE的值，就默认使用testkey)，其中shared.pk8是私钥，shared.x509.pem是公钥，一定是成对匹配出现的。当编译整个Android OS映像时将使用这些测试密钥对所有.apk文件进行签名。</p>
<h2 id="自定义Key"><a href="#自定义Key" class="headerlink" title="自定义Key"></a>自定义Key</h2><p>Android源码build/target/product/security/README说明了key的制作方法，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; build/make/target/product/security/README</span><br><span class="line"></span><br><span class="line">key generation</span><br><span class="line">--------------</span><br><span class="line"></span><br><span class="line">The following commands were used to generate the test key pairs:</span><br><span class="line"></span><br><span class="line">  development/tools/make_key testkey  &apos;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com&apos;</span><br><span class="line">  development/tools/make_key platform &apos;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com&apos;</span><br><span class="line">  development/tools/make_key shared   &apos;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com&apos;</span><br><span class="line">  development/tools/make_key media    &apos;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>通过development/tools/make_key生成对应信息的key，参数的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C ---&gt; Country Name (2 letter code)</span><br><span class="line">ST ---&gt; State or Province Name (full name)</span><br><span class="line">L ---&gt; Locality Name (eg, city)</span><br><span class="line">O ---&gt; Organization Name (eg, company)</span><br><span class="line">OU ---&gt; Organizational Unit Name (eg, section)</span><br><span class="line">CN ---&gt; Common Name (eg, your name or your server’s hostname)</span><br><span class="line">emailAddress ---&gt; Contact email address</span><br></pre></td></tr></table></figure></p>
<p>可在源码根目录下运行如下脚本统一制作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">subject=&apos;/C=CN/ST=Guangdong/L=Shenzhen View/O=Android/OU=Android/CN=Android/emailAddress=robin.he.ztto@gmail.cn&apos;</span><br><span class="line">mkdir ~/.android-certs</span><br><span class="line">for x in releasekey platform shared media verity; do \</span><br><span class="line">    ./development/tools/make_key ~/.android-certs/$x &quot;$subject&quot;; \</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<h2 id="为DM-Verity功能生成verity-key"><a href="#为DM-Verity功能生成verity-key" class="headerlink" title="为DM-Verity功能生成verity key"></a>为DM-Verity功能生成verity key</h2><p>首先通过使用以下的命令来生成verity key的工具generate_verity_key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">choosecombo</span><br><span class="line">make generate_verity_key (mmm system/extras/verity/)</span><br></pre></td></tr></table></figure></p>
<p>然后在前面步骤已生成verity.pk8，verity.x509.pem的基础上使用以下命令生成verity_key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out/host/linux-x86/bin/generate_verity_key -convert verity.x509.pem verity_key</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试系列之java]]></title>
      <url>http://robinheztto.com/2018/05/08/interview-java/</url>
      <content type="html"><![CDATA[<h2 id="面向对象的基本特征"><a href="#面向对象的基本特征" class="headerlink" title="面向对象的基本特征"></a>面向对象的基本特征</h2><ul>
<li>抽象<br>将具有相同属性与行为的一类对象总结成类的过程。抽象只关注于对象的属性与行为，并不关注具体的细节。</li>
<li>封装<br>对类的数据及数据操作进行封装，隐藏一切可隐藏的细节，只公开对外的接口。</li>
<li>继承<br>继承已有类的信息创建新类的过程。</li>
<li>多态<br>多态性是指允许不同子类型的对象对同一消息作出不同的响应。</li>
</ul>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol>
<li><p><strong>数据:</strong> 声明修饰的数据为常量(可以是编译时常量也可以是运行时常量)。</p>
<blockquote>
<p>对于基本数据类型，final修饰的数值不变<br>对于引用类型，final修饰的引用不变，但引用的对象本身可以改变</p>
</blockquote>
</li>
<li><p><strong>方法:</strong> 声明修饰的方法不能被子类覆盖重写。private方法隐式指定为final，如果在子类中定义的方法和基类中的一个private方法签名相同，此时子类的方法不是覆盖基类方法，而是在子类中定义了一个新的方法。</p>
</li>
<li><p><strong>类:</strong> 声明修饰的类不允许被继承，没有子类。final类中所有的方法都被隐示定义为final，因为它们是不会被重载。</p>
</li>
<li><p>final关键字不能修饰接口</p>
</li>
</ol>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>  保留关键字</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ol>
<li><strong>成员变量:</strong> 声明修饰的成员变量为静态变量(类变量)，在内存中只有一个副本，并且在类初始化时赋值，无需依赖对象调用，static成员变量的初始化顺序按照定义的顺序进行。</li>
<li><strong>成员方法:</strong> 声明修饰的成员方法为静态方法(类方法)，在类加载时已存在，无需依赖对象调用，静态方法不能调用其他非静态成员或方法。</li>
<li><strong>代码块:</strong> 只在类加载的时候执行一次。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试系列之C]]></title>
      <url>http://robinheztto.com/2018/05/08/interview-c/</url>
      <content type="html"><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li>局部变量:存储位置由栈变成静态存储区，生命周期由程序开始执行到结束。</li>
<li>全局变量:限定修饰的全局变量作用域为本文件内，外部文件不可见。</li>
<li>修饰函数:限定函数作用域范围为定义的本文件内，外部文件不可访问。</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li><p>修饰变量:标记标量只读</p>
<blockquote>
<p>const int * a;  指针指向的数据<em>a只读，指针a可以改变指向。<br>int ** const a; 指针指向的数据</em>a可修改，指针a不能改变指向。<br>const int *<em> const a; 指针的指向的数据</em>a只读，指针a不能改变指向。</p>
</blockquote>
</li>
<li><p>修饰函数参数:标记参数在函数内不允许修改</p>
</li>
<li><p>修饰函数返回值:标志函数返回值为只读</p>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面试系列之C++]]></title>
      <url>http://robinheztto.com/2018/05/08/interview-cpp/</url>
      <content type="html"><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li>局部变量:存储位置由栈变成静态存储区，生命周期由程序开始执行到结束。</li>
<li>全局变量:限定修饰的全局变量作用域为本文件内，外部文件不可见。</li>
<li>函数:限定函数作用域范围为定义的本文件内，外部文件不可访问。</li>
<li>成员变量:修饰成员变量为类变量，无需依赖对象调用，static修饰的成员变量要在类外初始化。</li>
<li>成员函数:修饰静态成员函数，无需依赖对象调用，静态成员函数只能访问静态成员函数或静态成员变量，不能访问非静态成员函数或者变量。</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li><p>修饰变量:标记标量只读</p>
<blockquote>
<p>const int * a;  指针指向的数据<em>a只读，指针a可以改变指向。<br>int ** const a; 指针指向的数据</em>a可修改，指针a不能改变指向。<br>const int *<em> const a; 指针的指向的数据</em>a只读，指针a不能改变指向。</p>
</blockquote>
</li>
<li><p>修饰函数参数:标记参数在函数内不允许修改</p>
</li>
<li><p>修饰成员函数:标志成员函数不能修改任何成员变量的值(mutable标记的成员变量除外)，另外const成员函数不能调用非const成员函数(因为非const成员函数可能修改成员变量)</p>
</li>
<li><p>修饰函数返回值:标志函数返回值为只读</p>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android持续集成之Jenkins]]></title>
      <url>http://robinheztto.com/2018/05/03/android-ci-jenkins/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Jenkins是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -</span><br><span class="line">$ sudo sh -c &apos;echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list&apos;</span><br><span class="line">$ sudo apt-get update -y</span><br><span class="line">$ sudo apt-get install jenkins -y</span><br><span class="line">$ sudo /etc/init.d/jenkins start</span><br></pre></td></tr></table></figure>
<p>完成以上步骤后，通过浏览器打开 <a href="http://localhost:8080，" target="_blank" rel="external">http://localhost:8080，</a> 如果无法启动jenkins，可在/var/log/jenkins/jenkins.log下查看Jenkins log</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/ci/jenkins-error-log.png?raw=true" alt="jenkins-error-log"><br></div>

<p>如上图示，出现上面的报错信息，即端口号被占用，需按以下步骤修改Jenkins端口号</p>
<p>1.修改/etc/init.d/jenkins中do_start函数check_tcp_port命令，将端口号从8080换成8081</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/init.d/jenkins</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Function that starts the daemon/service</span><br><span class="line">#</span><br><span class="line">do_start()</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    # Verify that the jenkins port is not already in use, winstone does not exit</span><br><span class="line">    # even for BindException</span><br><span class="line">    check_tcp_port &quot;http&quot; &quot;$HTTP_PORT&quot; &quot;8081&quot; &quot;$HTTP_HOST&quot; &quot;0.0.0.0&quot; || return 2</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.修改/etc/default/jenkins文件，将端口8080改成8081<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/default/jenkins</span><br><span class="line"></span><br><span class="line"># port for HTTP connector (default 8080; disable with -1)</span><br><span class="line">HTTP_PORT=8081</span><br></pre></td></tr></table></figure></p>
<p>3.重新启动jenkins<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/jenkins start</span><br><span class="line">$ ps -ef | grep jenkins</span><br></pre></td></tr></table></figure></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>浏览器打开gerrit url，即出现如下界面，admin初始密码保存在/var/lib/jenkins/secrets</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/ci/jenkins-login.png?raw=true" alt="jenkins-login"><br></div>

<p>首次进入账户，根据提示安装推介的插件</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/ci/jenkins-startup.png?raw=true" alt="jenkins-startup"><br></div>

<p>推介安装包括如下插件</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/ci/jenkins-startup-1.png?raw=true" alt="jenkins-startup-1"><br></div>

<p>进入jenkins后，界面如下显示</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/ci/jenkins-page.png?raw=true" alt="jenkins-page"><br></div>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之Deep Doze]]></title>
      <url>http://robinheztto.com/2017/09/15/android-power-doze-deep/</url>
      <content type="html"><![CDATA[<h1 id="STATE-ACTIVE-gt-STATE-INACTIVE"><a href="#STATE-ACTIVE-gt-STATE-INACTIVE" class="headerlink" title="STATE_ACTIVE -&gt; STATE_INACTIVE"></a>STATE_ACTIVE -&gt; STATE_INACTIVE</h1><p>如上文所述，当Screen off或者unplug事件触发时，进入becomeInactiveIfAppropriateLocked执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void becomeInactiveIfAppropriateLocked() &#123;</span><br><span class="line">    // 灭屏且未充电  </span><br><span class="line">    if ((!mScreenOn &amp;&amp; !mCharging) || mForceIdle) &#123;</span><br><span class="line">        // 进入deep模式状态机轮转</span><br><span class="line">        if (mState == STATE_ACTIVE &amp;&amp; mDeepEnabled) &#123;</span><br><span class="line">            // 切换到STATE_INACTIVE状态</span><br><span class="line">            mState = STATE_INACTIVE;</span><br><span class="line">            // 重置状态值，定时器等</span><br><span class="line">            resetIdleManagementLocked();</span><br><span class="line">            // 启动Deep定时器，进入deep状态轮转</span><br><span class="line">            scheduleAlarmLocked(mInactiveTimeout, false);</span><br><span class="line">            EventLogTags.writeDeviceIdle(mState, &quot;no activity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前模式是LIGHT_STATE_ACTIVE，且mLightEnabled开关打开(上篇博客已分析)</span><br><span class="line">        if (mLightState == LIGHT_STATE_ACTIVE &amp;&amp; mLightEnabled) &#123;</span><br><span class="line">            mLightState = LIGHT_STATE_INACTIVE;</span><br><span class="line">            resetLightIdleManagementLocked();</span><br><span class="line">            scheduleLightAlarmLocked(mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT);</span><br><span class="line">            EventLogTags.writeDeviceIdleLight(mLightState, &quot;no activity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>灭屏且未充电状态或mForceIdle状态满足时，STATE_ACTIVE切换到STATE_INACTIVE，并且启动定时器轮转状态机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// inactiveTimeoutDefaul默认值为30min</span><br><span class="line">long inactiveTimeoutDefault = (mHasWatch ? 15 : 30) * 60 * 1000L;</span><br><span class="line">INACTIVE_TIMEOUT = mParser.getLong(KEY_INACTIVE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / 10));</span><br><span class="line"></span><br><span class="line">void scheduleAlarmLocked(long delay, boolean idleUntil) &#123;</span><br><span class="line">    if (mMotionSensor == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mNextAlarmTime = SystemClock.elapsedRealtime() + delay;</span><br><span class="line">    if (idleUntil) &#123;</span><br><span class="line">        mAlarmManager.setIdleUntil(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                mNextAlarmTime, &quot;DeviceIdleController.deep&quot;, mDeepAlarmListener, mHandler);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                mNextAlarmTime, &quot;DeviceIdleController.deep&quot;, mDeepAlarmListener, mHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>scheduleAlarmLocked调度定时器，时间mInactiveTimeout为Constants.INACTIVE_TIMEOUT，即inactive_to，默认为30min。</p>
<h1 id="STATE-INACTIVE-gt-STATE-IDLE-PENDING"><a href="#STATE-INACTIVE-gt-STATE-IDLE-PENDING" class="headerlink" title="STATE_INACTIVE -&gt; STATE_IDLE_PENDING"></a>STATE_INACTIVE -&gt; STATE_IDLE_PENDING</h1><p>在过mInactiveTimeout时间的定时后，进入mDeepAlarmListener中处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final AlarmManager.OnAlarmListener mDeepAlarmListener</span><br><span class="line">        = new AlarmManager.OnAlarmListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAlarm() &#123;</span><br><span class="line">        synchronized (DeviceIdleController.this) &#123;</span><br><span class="line">            stepIdleStateLocked(&quot;s:alarm&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>继续看stepIdleStateLocked的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">MIN_TIME_TO_ALARM = mParser.getLong(KEY_MIN_TIME_TO_ALARM,</span><br><span class="line">        !COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);</span><br><span class="line"></span><br><span class="line">void stepIdleStateLocked(String reason) &#123;</span><br><span class="line">    final long now = SystemClock.elapsedRealtime();</span><br><span class="line">    // 如果60分钟内有可以从Deep Idle唤醒的定时器触发，暂时先退出状态机轮转</span><br><span class="line">    if ((now+mConstants.MIN_TIME_TO_ALARM) &gt; mAlarmManager.getNextWakeFromIdleTime()) &#123;</span><br><span class="line">        //　重置为STATE_ACTIVE状态</span><br><span class="line">        if (mState != STATE_ACTIVE) &#123;</span><br><span class="line">            becomeActiveLocked(&quot;alarm&quot;, Process.myUid());</span><br><span class="line">            becomeInactiveIfAppropriateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (mState) &#123;</span><br><span class="line">        case STATE_INACTIVE:</span><br><span class="line">            // 启动motion sensor监听</span><br><span class="line">            startMonitoringMotionLocked();</span><br><span class="line">            // 调度STATE_IDLE_PENDING状态的定时器，即idle_after_inactive_to，默认30min</span><br><span class="line">            scheduleAlarmLocked(mConstants.IDLE_AFTER_INACTIVE_TIMEOUT, false);</span><br><span class="line">            // mNextIdlePendingDelay设置为idle_pending_to即5min</span><br><span class="line">            mNextIdlePendingDelay = mConstants.IDLE_PENDING_TIMEOUT;</span><br><span class="line">            mNextIdleDelay = mConstants.IDLE_TIMEOUT;</span><br><span class="line">            // 切换状态为STATE_IDLE_PENDING</span><br><span class="line">            mState = STATE_IDLE_PENDING;</span><br><span class="line">            EventLogTags.writeDeviceIdle(mState, reason);</span><br><span class="line">            break;</span><br><span class="line">        case STATE_IDLE_PENDING:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case STATE_SENSING:</span><br><span class="line">            ......</span><br><span class="line">        case STATE_LOCATING:</span><br><span class="line">            ......</span><br><span class="line">        case STATE_IDLE_MAINTENANCE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case STATE_IDLE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当进入STATE_IDLE_PENDING时，通过startMonitoringMotionLocked启动了motion sensor监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private final MotionListener mMotionListener = new MotionListener();</span><br><span class="line"></span><br><span class="line">void startMonitoringMotionLocked() &#123;</span><br><span class="line">    if (mMotionSensor != null &amp;&amp; !mMotionListener.active) &#123;</span><br><span class="line">        // 注册mMotionSensor监听</span><br><span class="line">        mMotionListener.registerLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final class MotionListener extends TriggerEventListener</span><br><span class="line">        implements SensorEventListener &#123;</span><br><span class="line"></span><br><span class="line">    boolean active = false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onTrigger(TriggerEvent event) &#123;</span><br><span class="line">        synchronized (DeviceIdleController.this) &#123;</span><br><span class="line">            active = false;</span><br><span class="line">            // MotionSensor事件触发时，执行motionLocked</span><br><span class="line">            motionLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onSensorChanged(SensorEvent event) &#123;</span><br><span class="line">        synchronized (DeviceIdleController.this) &#123;</span><br><span class="line">            mSensorManager.unregisterListener(this, mMotionSensor);</span><br><span class="line">            active = false;</span><br><span class="line">            motionLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAccuracyChanged(Sensor sensor, int accuracy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 注册MotionSensor监听</span><br><span class="line">    public boolean registerLocked() &#123;</span><br><span class="line">        boolean success;</span><br><span class="line">        if (mMotionSensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) &#123;</span><br><span class="line">            success = mSensorManager.requestTriggerSensor(mMotionListener, mMotionSensor);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            success = mSensorManager.registerListener(</span><br><span class="line">                    mMotionListener, mMotionSensor, SensorManager.SENSOR_DELAY_NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            active = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Slog.e(TAG, &quot;Unable to register for &quot; + mMotionSensor);</span><br><span class="line">        &#125;</span><br><span class="line">        return success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unregisterLocked() &#123;</span><br><span class="line">        if (mMotionSensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) &#123;</span><br><span class="line">            mSensorManager.cancelTriggerSensor(mMotionListener, mMotionSensor);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mSensorManager.unregisterListener(mMotionListener);</span><br><span class="line">        &#125;</span><br><span class="line">        active = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当mMotionSensor事件触发时，motionLocked被调动执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void motionLocked() &#123;</span><br><span class="line">    handleMotionDetectedLocked(mConstants.MOTION_INACTIVE_TIMEOUT, &quot;motion&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// handleMotionDetectedLocked中重置状态为STATE_ACTIVE，并重新设置mInactiveTimeout为</span><br><span class="line">// mConstants.MOTION_INACTIVE_TIMEOUT，即motion_inactive_to，默认是10分钟</span><br><span class="line">// 即如果由于MotionSensor检测到的动作而退出了INACTIVE状态，再次从INACTIVE切换</span><br><span class="line">// 到IDLE_PENDING的时间就从原先的30分钟缩短到了10分钟。</span><br><span class="line">void handleMotionDetectedLocked(long timeout, String type) &#123;</span><br><span class="line">    boolean becomeInactive = false;</span><br><span class="line">    if (mState != STATE_ACTIVE) &#123;</span><br><span class="line">        scheduleReportActiveLocked(type, Process.myUid());</span><br><span class="line">        mState = STATE_ACTIVE;</span><br><span class="line">        mInactiveTimeout = timeout;</span><br><span class="line">        mCurIdleBudget = 0;</span><br><span class="line">        mMaintenanceStartTime = 0;</span><br><span class="line">        EventLogTags.writeDeviceIdle(mState, type);</span><br><span class="line">        addEvent(EVENT_NORMAL);</span><br><span class="line">        becomeInactive = true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mLightState == LIGHT_STATE_OVERRIDE) &#123;</span><br><span class="line">        // We went out of light idle mode because we had started deep idle mode...  let&apos;s</span><br><span class="line">        // now go back and reset things so we resume light idling if appropriate.</span><br><span class="line">        mLightState = STATE_ACTIVE;</span><br><span class="line">        EventLogTags.writeDeviceIdleLight(mLightState, type);</span><br><span class="line">        becomeInactive = true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (becomeInactive) &#123;</span><br><span class="line">        becomeInactiveIfAppropriateLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="STATE-IDLE-PENDING-gt-STATE-SENSING"><a href="#STATE-IDLE-PENDING-gt-STATE-SENSING" class="headerlink" title="STATE_IDLE_PENDING -&gt; STATE_SENSING"></a>STATE_IDLE_PENDING -&gt; STATE_SENSING</h1><p>当STATE_IDLE_PENDING定时时间到后，继续进入到stepIdleStateLocked中处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void stepIdleStateLocked(String reason) &#123;</span><br><span class="line">    ......</span><br><span class="line">    switch (mState) &#123;</span><br><span class="line">        case STATE_INACTIVE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case STATE_IDLE_PENDING:</span><br><span class="line">            // 切换状态到STATE_SENSING</span><br><span class="line">            mState = STATE_SENSING;</span><br><span class="line">            EventLogTags.writeDeviceIdle(mState, reason);</span><br><span class="line">            // 调度STATE_SENSING状态定时器，SENSING_TIMEOUT即sensing_to，默认4min，正常情况下该定时器不会被触发</span><br><span class="line">            scheduleSensingTimeoutAlarmLocked(mConstants.SENSING_TIMEOUT);</span><br><span class="line">            cancelLocatingLocked();</span><br><span class="line">            mNotMoving = false;</span><br><span class="line">            mLocated = false;</span><br><span class="line">            mLastGenericLocation = null;</span><br><span class="line">            mLastGpsLocation = null;</span><br><span class="line">            // 启动AnyMotionDetector，利用加速度传感器监测是否有方向的变化</span><br><span class="line">            mAnyMotionDetector.checkForAnyMotion();</span><br><span class="line">            break;</span><br><span class="line">        case STATE_SENSING:</span><br><span class="line">            ......</span><br><span class="line">        case STATE_LOCATING:</span><br><span class="line">            ......</span><br><span class="line">        case STATE_IDLE_MAINTENANCE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case STATE_IDLE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>stepIdleStateLocked对STATE_SENSING的处理同样是启动一个定时器，但是该定时器不会被触发，也就是STATE_SENSING状态的轮转不依靠定时器进行，而是在mAnyMotionDetector的监测结果的回调onAnyMotionResult()中进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void onAnyMotionResult(int result) &#123;</span><br><span class="line">    if (result != AnyMotionDetector.RESULT_UNKNOWN) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // 取消STATE_SENSING的定时器</span><br><span class="line">            cancelSensingTimeoutAlarmLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((result == AnyMotionDetector.RESULT_MOVED) ||</span><br><span class="line">        (result == AnyMotionDetector.RESULT_UNKNOWN)) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            handleMotionDetectedLocked(mConstants.INACTIVE_TIMEOUT, &quot;non_stationary&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (result == AnyMotionDetector.RESULT_STATIONARY) &#123;</span><br><span class="line">        if (mState == STATE_SENSING) &#123;</span><br><span class="line">            // If we are currently sensing, it is time to move to locating.</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                mNotMoving = true;</span><br><span class="line">                stepIdleStateLocked(&quot;s:stationary&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (mState == STATE_LOCATING) &#123;</span><br><span class="line">            // If we are currently locating, note that we are not moving and step</span><br><span class="line">            // if we have located the position.</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                mNotMoving = true;</span><br><span class="line">                if (mLocated) &#123;</span><br><span class="line">                    stepIdleStateLocked(&quot;s:stationary&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当检测结果为MOVED时，调用handleMotionDetectedLocked重置状态为ACTIVE，如果结果为RESULT_STATIONARY，当前状态为SENSING时，调用stopIdleStateLocked轮转到下一个状态，也就是进入到LOCATING状态，那么如果当前为LOCATING时，需要另外对mLocated变量进行判断才决定是否进行下一次切换。</p>
<h1 id="STATE-SENSING-gt-STATE-LOCATING"><a href="#STATE-SENSING-gt-STATE-LOCATING" class="headerlink" title="STATE_SENSING -&gt; STATE_LOCATING"></a>STATE_SENSING -&gt; STATE_LOCATING</h1><p>stepIdleStateLocked对STATE_LOCATING状态的处理同样是启动一个定时器，并通过LocationManager请求对位置的监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void stepIdleStateLocked(String reason) &#123;</span><br><span class="line">    ......</span><br><span class="line">    switch (mState) &#123;</span><br><span class="line">        case STATE_INACTIVE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case STATE_IDLE_PENDING:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case STATE_SENSING:</span><br><span class="line">            cancelSensingTimeoutAlarmLocked();</span><br><span class="line">            mState = STATE_LOCATING;</span><br><span class="line">            EventLogTags.writeDeviceIdle(mState, reason);</span><br><span class="line">            // 调度STATE_LOCATING状态定时器，LOCATING_TIMEOUT即locating_to，默认30s</span><br><span class="line">            scheduleAlarmLocked(mConstants.LOCATING_TIMEOUT, false);</span><br><span class="line">            // 通过LocationManager请求位置监听</span><br><span class="line">            if (mLocationManager != null</span><br><span class="line">                    &amp;&amp; mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) &#123;</span><br><span class="line">                mLocationManager.requestLocationUpdates(mLocationRequest,</span><br><span class="line">                        mGenericLocationListener, mHandler.getLooper());</span><br><span class="line">                mLocating = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mHasNetworkLocation = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mLocationManager != null</span><br><span class="line">                    &amp;&amp; mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != null) &#123;</span><br><span class="line">                mHasGps = true;</span><br><span class="line">                mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000, 5,</span><br><span class="line">                        mGpsLocationListener, mHandler.getLooper());</span><br><span class="line">                mLocating = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mHasGps = false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有location provider,将通过listeners回调轮状状态</span><br><span class="line">            if (mLocating) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        case STATE_LOCATING:</span><br><span class="line">            ......</span><br><span class="line">        case STATE_IDLE_MAINTENANCE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case STATE_IDLE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>STATE_LOCATING的状态在mGenericLocationListener/mGpsLocationListener中进行轮转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private final LocationListener mGenericLocationListener = new LocationListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLocationChanged(Location location) &#123;</span><br><span class="line">        synchronized (DeviceIdleController.this) &#123;</span><br><span class="line">            receivedGenericLocationLocked(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private final LocationListener mGpsLocationListener = new LocationListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLocationChanged(Location location) &#123;</span><br><span class="line">        synchronized (DeviceIdleController.this) &#123;</span><br><span class="line">            receivedGpsLocationLocked(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void receivedGenericLocationLocked(Location location) &#123;</span><br><span class="line">    if (mState != STATE_LOCATING) &#123;</span><br><span class="line">        cancelLocatingLocked();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG) Slog.d(TAG, &quot;Generic location: &quot; + location);</span><br><span class="line">    mLastGenericLocation = new Location(location);</span><br><span class="line">    if (location.getAccuracy() &gt; mConstants.LOCATION_ACCURACY &amp;&amp; mHasGps) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mLocated = true;</span><br><span class="line">    if (mNotMoving) &#123;</span><br><span class="line">        stepIdleStateLocked(&quot;s:location&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void receivedGpsLocationLocked(Location location) &#123;</span><br><span class="line">    if (mState != STATE_LOCATING) &#123;</span><br><span class="line">        cancelLocatingLocked();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG) Slog.d(TAG, &quot;GPS location: &quot; + location);</span><br><span class="line">    mLastGpsLocation = new Location(location);</span><br><span class="line">    if (location.getAccuracy() &gt; mConstants.LOCATION_ACCURACY) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mLocated = true;</span><br><span class="line">    if (mNotMoving) &#123;</span><br><span class="line">        stepIdleStateLocked(&quot;s:gps&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果开启了Gps的定位监测，并且精度大于LOCATION_ACCURACY，那么这里的监测就忽略，如果监测数据为Not move，那么就调用StepIdleStateLocked来进行下一步。</p>
<h1 id="STATE-LOCATING-gt-STATE-IDLE"><a href="#STATE-LOCATING-gt-STATE-IDLE" class="headerlink" title="STATE_LOCATING -&gt; STATE_IDLE"></a>STATE_LOCATING -&gt; STATE_IDLE</h1><h1 id="STATE-IDLE-MAINTENANCE-gt-STATE-IDLE"><a href="#STATE-IDLE-MAINTENANCE-gt-STATE-IDLE" class="headerlink" title="STATE_IDLE_MAINTENANCE -&gt; STATE_IDLE"></a>STATE_IDLE_MAINTENANCE -&gt; STATE_IDLE</h1><h1 id="STATE-LOCATING-gt-STATE-IDLE-MAINTENANCE"><a href="#STATE-LOCATING-gt-STATE-IDLE-MAINTENANCE" class="headerlink" title="STATE_LOCATING -&gt; STATE_IDLE_MAINTENANCE"></a>STATE_LOCATING -&gt; STATE_IDLE_MAINTENANCE</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之Light Doze]]></title>
      <url>http://robinheztto.com/2017/09/13/android-power-doze-light/</url>
      <content type="html"><![CDATA[<p>Light Doze的状态切换如下图示：</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/light_doze.png?raw=true" alt="light doze machine state"><br></div></p>
<h2 id="LIGHT-STATE-ACTIVE-gt-LIGHT-STATE-INACTIVE"><a href="#LIGHT-STATE-ACTIVE-gt-LIGHT-STATE-INACTIVE" class="headerlink" title="LIGHT_STATE_ACTIVE -&gt; LIGHT_STATE_INACTIVE"></a>LIGHT_STATE_ACTIVE -&gt; LIGHT_STATE_INACTIVE</h2><p>DeviceIdleController服务启动过程中注册了DisplayListener，BATTERY_CHANGED Receiver监听屏幕亮灭与充电状态事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void updateDisplayLocked() &#123;</span><br><span class="line">    // 获取default Display  </span><br><span class="line">    mCurDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);</span><br><span class="line">    boolean screenOn = mCurDisplay.getState() == Display.STATE_ON;</span><br><span class="line">    // 灭屏</span><br><span class="line">    if (!screenOn &amp;&amp; mScreenOn) &#123;</span><br><span class="line">        mScreenOn = false;</span><br><span class="line">        if (!mForceIdle) &#123;</span><br><span class="line">            becomeInactiveIfAppropriateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    // 亮屏</span><br><span class="line">    &#125; else if (screenOn) &#123;</span><br><span class="line">        mScreenOn = true;</span><br><span class="line">        if (!mForceIdle) &#123;</span><br><span class="line">            becomeActiveLocked(&quot;screen&quot;, Process.myUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void updateChargingLocked(boolean charging) &#123;</span><br><span class="line">    // 未充电状态</span><br><span class="line">    if (!charging &amp;&amp; mCharging) &#123;</span><br><span class="line">        mCharging = false;</span><br><span class="line">        if (!mForceIdle) &#123;</span><br><span class="line">            becomeInactiveIfAppropriateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    // 充电状态</span><br><span class="line">    &#125; else if (charging) &#123;</span><br><span class="line">        mCharging = charging;</span><br><span class="line">        if (!mForceIdle) &#123;</span><br><span class="line">            becomeActiveLocked(&quot;charging&quot;, Process.myUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当灭屏或未充电状态事件触发时，调用becomeInactiveIfAppropriateLocked进行状态处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void becomeInactiveIfAppropriateLocked() &#123;</span><br><span class="line">    // 灭屏且未充电  </span><br><span class="line">    if ((!mScreenOn &amp;&amp; !mCharging) || mForceIdle) &#123;</span><br><span class="line">        // 进入deep模式，在下篇博客中分析</span><br><span class="line">        if (mState == STATE_ACTIVE &amp;&amp; mDeepEnabled) &#123;</span><br><span class="line">            mState = STATE_INACTIVE;</span><br><span class="line">            resetIdleManagementLocked();</span><br><span class="line">            scheduleAlarmLocked(mInactiveTimeout, false);</span><br><span class="line">            EventLogTags.writeDeviceIdle(mState, &quot;no activity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 当前模式是LIGHT_STATE_ACTIVE，且mLightEnabled开关打开(上篇博客已分析)</span><br><span class="line">        if (mLightState == LIGHT_STATE_ACTIVE &amp;&amp; mLightEnabled) &#123;</span><br><span class="line">            // 切换当前light状态为LIGHT_STATE_INACTIVE</span><br><span class="line">            mLightState = LIGHT_STATE_INACTIVE;</span><br><span class="line">            // 取消Light定时器</span><br><span class="line">            resetLightIdleManagementLocked();</span><br><span class="line">            // 启动Light定时器，进入Light状态机轮转</span><br><span class="line">            scheduleLightAlarmLocked(mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT);</span><br><span class="line">            EventLogTags.writeDeviceIdleLight(mLightState, &quot;no activity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void scheduleLightAlarmLocked(long delay) &#123;</span><br><span class="line">    mNextLightAlarmTime = SystemClock.elapsedRealtime() + delay;</span><br><span class="line">    // 定时时间到后，mLightAlarmListener将在mHandler关联的BackgroundThread线程中执行</span><br><span class="line">    mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">            mNextLightAlarmTime, &quot;DeviceIdleController.light&quot;, mLightAlarmListener, mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>灭屏且未充电状态或打开强制Idle状态满足时，LIGHT_STATE_ACTIVE切换到LIGHT_STATE_INACTIVE，并且启动定时器轮转状态机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong(</span><br><span class="line">        KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);</span><br></pre></td></tr></table></figure></p>
<p>定时器定时时间LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT即light_idle_to默认为5min。</p>
<h2 id="LIGHT-STATE-INACTIVE-gt-LIGHT-STATE-PRE-IDLE"><a href="#LIGHT-STATE-INACTIVE-gt-LIGHT-STATE-PRE-IDLE" class="headerlink" title="LIGHT_STATE_INACTIVE -&gt; LIGHT_STATE_PRE_IDLE"></a>LIGHT_STATE_INACTIVE -&gt; LIGHT_STATE_PRE_IDLE</h2><p>在过LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT时间的定时后，进入mLightAlarmListener中处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final AlarmManager.OnAlarmListener mLightAlarmListener</span><br><span class="line">        = new AlarmManager.OnAlarmListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onAlarm() &#123;</span><br><span class="line">        synchronized (DeviceIdleController.this) &#123;</span><br><span class="line">            stepLightIdleStateLocked(&quot;s:alarm&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>继续看stepLightIdleStateLocked的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// LIGHT_STATE_IDLE_MAINTENANCE最短时间，默认为1min</span><br><span class="line">LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = mParser.getLong(</span><br><span class="line">        KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,</span><br><span class="line">        !COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L);</span><br><span class="line"></span><br><span class="line">// LIGHT_IDLE_TIMEOUT默认值为5min</span><br><span class="line">LIGHT_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);  </span><br><span class="line"></span><br><span class="line">// LIGHT_STATE_PRE_IDLE时间，默认为10min</span><br><span class="line">LIGHT_PRE_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? 10 * 60 * 1000L : 30 * 1000L);              </span><br><span class="line"></span><br><span class="line">void stepLightIdleStateLocked(String reason) &#123;</span><br><span class="line">    // 如果处于Deep mode的IDLE状态，Light Mode将会被忽略</span><br><span class="line">    if (mLightState == LIGHT_STATE_OVERRIDE) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前mLightState处于LIGHT_STATE_INACTIVE状态</span><br><span class="line">    switch (mLightState) &#123;</span><br><span class="line">        case LIGHT_STATE_INACTIVE:</span><br><span class="line">            // LIGHT_STATE_IDLE_MAINTENANCE最短时间，默认为1min</span><br><span class="line">            mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;</span><br><span class="line">            // Idle时间初始值为LIGHT_IDLE_TIMEOUT，5min</span><br><span class="line">            mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT;</span><br><span class="line">            mMaintenanceStartTime = 0;</span><br><span class="line">            //　当前有Alarm或job等active ops，先进入LIGHT_STATE_PRE_IDLE状态等待完成，否则直接进入LIGHT_STATE_PRE_IDLE</span><br><span class="line">            if (!isOpsInactiveLocked()) &#123;</span><br><span class="line">                mLightState = LIGHT_STATE_PRE_IDLE;</span><br><span class="line">                EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">                // 设置LIGHT_STATE_PRE_IDLE时间，默认为10min</span><br><span class="line">                scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        case LIGHT_STATE_PRE_IDLE:</span><br><span class="line">        case LIGHT_STATE_IDLE_MAINTENANCE:</span><br><span class="line">            .......</span><br><span class="line">            break;</span><br><span class="line">        case LIGHT_STATE_IDLE:</span><br><span class="line">        case LIGHT_STATE_WAITING_FOR_NETWORK:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>stepLightIdleStateLocked中LIGHT_STATE_INACTIVE的处理，当首次进入存在active ops时，将会进入LIGHT_STATE_PRE_IDLE状态，等待当前处理完成，mConstants.LIGHT_PRE_IDLE_TIMEOUT即light_pre_idle_to时间到后，再次进入stepLightIdleStateLocked中进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean isOpsInactiveLocked() &#123;</span><br><span class="line">    return mActiveIdleOpCount &lt;= 0 &amp;&amp; !mJobsActive &amp;&amp; !mAlarmsActive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LIGHT-STATE-PRE-IDLE-gt-LIGHT-STATE-IDLE"><a href="#LIGHT-STATE-PRE-IDLE-gt-LIGHT-STATE-IDLE" class="headerlink" title="LIGHT_STATE_PRE_IDLE -&gt; LIGHT_STATE_IDLE"></a>LIGHT_STATE_PRE_IDLE -&gt; LIGHT_STATE_IDLE</h2><p>当LIGHT_STATE_PRE_IDLE定时时间到后，继续进入到stepLightIdleStateLocked中处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void stepLightIdleStateLocked(String reason) &#123;</span><br><span class="line">    if (mLightState == LIGHT_STATE_OVERRIDE) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前mLightState处于LIGHT_STATE_PRE_IDLE状态</span><br><span class="line">    switch (mLightState) &#123;</span><br><span class="line">        case LIGHT_STATE_INACTIVE:</span><br><span class="line">            ......</span><br><span class="line">        case LIGHT_STATE_PRE_IDLE:</span><br><span class="line">        case LIGHT_STATE_IDLE_MAINTENANCE:</span><br><span class="line">            // 当前mMaintenanceStartTime=0</span><br><span class="line">            if (mMaintenanceStartTime != 0) &#123;</span><br><span class="line">                long duration = SystemClock.elapsedRealtime() - mMaintenanceStartTime;</span><br><span class="line">                if (duration &lt; mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) &#123;</span><br><span class="line">                    // We didn&apos;t use up all of our minimum budget; add this to the reserve.</span><br><span class="line">                    mCurIdleBudget += (mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET-duration);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // We used more than our minimum budget; this comes out of the reserve.</span><br><span class="line">                    mCurIdleBudget -= (duration-mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mMaintenanceStartTime = 0;</span><br><span class="line">            // 设置IDLE时间，初始值为LIGHT_IDLE_TIMEOUT，5min</span><br><span class="line">            scheduleLightAlarmLocked(mNextLightIdleDelay);</span><br><span class="line">            // 设置下次IDLE的时间，5*2^min</span><br><span class="line">            // 最长LIGHT_MAX_IDLE_TIMEOUT，15min，最短LIGHT_IDLE_TIMEOUT,5min</span><br><span class="line">            mNextLightIdleDelay = Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,</span><br><span class="line">                    (long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));</span><br><span class="line">            if (mNextLightIdleDelay &lt; mConstants.LIGHT_IDLE_TIMEOUT) &#123;</span><br><span class="line">                mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG) Slog.d(TAG, &quot;Moved to LIGHT_STATE_IDLE.&quot;);</span><br><span class="line">            // 进入LIGHT_STATE_IDLE模式</span><br><span class="line">            mLightState = LIGHT_STATE_IDLE;</span><br><span class="line">            EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">            addEvent(EVENT_LIGHT_IDLE);</span><br><span class="line">            // 发送消息，进行LIGHT_STATE_IDLE状态相关的处理</span><br><span class="line">            mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);</span><br><span class="line">            break;</span><br><span class="line">        case LIGHT_STATE_IDLE:</span><br><span class="line">        case LIGHT_STATE_WAITING_FOR_NETWORK:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>stepLightIdleStateLocked中对LIGHT_STATE_PRE_IDLE状态的处理，进入LIGHT_STATE_IDLE状态并设置时间，然后发送消息进行状态切换相关的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">final class MyHandler extends Handler &#123;</span><br><span class="line">    ......</span><br><span class="line">    @Override public void handleMessage(Message msg) &#123;</span><br><span class="line">        if (DEBUG) Slog.d(TAG, &quot;handleMessage(&quot; + msg.what + &quot;)&quot;);</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case MSG_WRITE_CONFIG: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_REPORT_IDLE_ON:</span><br><span class="line">            case MSG_REPORT_IDLE_ON_LIGHT: &#123;</span><br><span class="line">                final boolean deepChanged;</span><br><span class="line">                final boolean lightChanged;</span><br><span class="line">                if (msg.what == MSG_REPORT_IDLE_ON) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // LocalPowerManager设置LightDeviceIdle模式</span><br><span class="line">                    deepChanged = mLocalPowerManager.setDeviceIdleMode(false);</span><br><span class="line">                    lightChanged = mLocalPowerManager.setLightDeviceIdleMode(true);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // NetworkPolicyManager设置DeviceIdle模式，禁止非白名单应用联网</span><br><span class="line">                    mNetworkPolicyManager.setDeviceIdleMode(true);</span><br><span class="line">                    mBatteryStats.noteDeviceIdleMode(msg.what == MSG_REPORT_IDLE_ON</span><br><span class="line">                            ? BatteryStats.DEVICE_IDLE_MODE_DEEP</span><br><span class="line">                            : BatteryStats.DEVICE_IDLE_MODE_LIGHT, null, Process.myUid());</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                // 发送LightIdle模式切换广播</span><br><span class="line">                if (lightChanged) &#123;</span><br><span class="line">                    getContext().sendBroadcastAsUser(mLightIdleIntent, UserHandle.ALL);</span><br><span class="line">                &#125;</span><br><span class="line">                EventLogTags.writeDeviceIdleOnComplete();</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_REPORT_IDLE_OFF: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_REPORT_ACTIVE: &#123;</span><br><span class="line">              ......              </span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123;</span><br><span class="line">              ......              </span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_REPORT_MAINTENANCE_ACTIVITY: &#123;</span><br><span class="line">              ......              </span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_FINISH_IDLE_OP: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在MyHandler中会对MSG_REPORT_IDLE_ON_LIGHT消息进行一系列的处理通知各个模块对LightDeviceId进行处理，包括禁止网络，推迟SyncManager，jobsheduler等。</p>
<h2 id="LIGHT-STATE-IDLE-gt-LIGHT-STATE-IDLE-MAINTENANCE"><a href="#LIGHT-STATE-IDLE-gt-LIGHT-STATE-IDLE-MAINTENANCE" class="headerlink" title="LIGHT_STATE_IDLE -&gt; LIGHT_STATE_IDLE_MAINTENANCE"></a>LIGHT_STATE_IDLE -&gt; LIGHT_STATE_IDLE_MAINTENANCE</h2><h2 id="LIGHT-STATE-IDLE-gt-LIGHT-STATE-WAITING-FOR-NETWORK"><a href="#LIGHT-STATE-IDLE-gt-LIGHT-STATE-WAITING-FOR-NETWORK" class="headerlink" title="LIGHT_STATE_IDLE -&gt; LIGHT_STATE_WAITING_FOR_NETWORK"></a>LIGHT_STATE_IDLE -&gt; LIGHT_STATE_WAITING_FOR_NETWORK</h2><p>当LIGHT_STATE_IDLE定时时间到后，继续进入到stepLightIdleStateLocked中进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_IDLE_MAINTENANCE时间默认最短1min，最长5min</span><br><span class="line">LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = mParser.getLong(</span><br><span class="line">        KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,</span><br><span class="line">        !COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L);</span><br><span class="line">LIGHT_IDLE_MAINTENANCE_MAX_BUDGET = mParser.getLong(</span><br><span class="line">        KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET,</span><br><span class="line">        !COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);</span><br><span class="line"></span><br><span class="line">void stepLightIdleStateLocked(String reason) &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 当前状态mLightState为LIGHT_STATE_IDLE</span><br><span class="line">    switch (mLightState) &#123;</span><br><span class="line">        case LIGHT_STATE_INACTIVE:</span><br><span class="line">            ......</span><br><span class="line">        case LIGHT_STATE_PRE_IDLE:</span><br><span class="line">        case LIGHT_STATE_IDLE_MAINTENANCE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        case LIGHT_STATE_IDLE:</span><br><span class="line">        case LIGHT_STATE_WAITING_FOR_NETWORK:</span><br><span class="line">            // 当前有网络连接时或为LIGHT_STATE_WAITING_FOR_NETWORK状态时，直接进入LIGHT_STATE_IDLE_MAINTENANCE状态</span><br><span class="line">            if (mNetworkConnected || mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) &#123;</span><br><span class="line">                // 设置mActiveIdleOpCount初始值为1</span><br><span class="line">                mActiveIdleOpCount = 1;</span><br><span class="line">                // mActiveIdleWakeLock防止系统进入休眠</span><br><span class="line">                mActiveIdleWakeLock.acquire();</span><br><span class="line">                // mCurIdleBudget即mMaintenance windows时间最短1min最长5min</span><br><span class="line">                mMaintenanceStartTime = SystemClock.elapsedRealtime();</span><br><span class="line">                if (mCurIdleBudget &lt; mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) &#123;</span><br><span class="line">                    mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;</span><br><span class="line">                &#125; else if (mCurIdleBudget &gt; mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) &#123;</span><br><span class="line">                    mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;</span><br><span class="line">                &#125;</span><br><span class="line">                // 进入LIGHT_STATE_IDLE_MAINTENANCE状态并设置定时器</span><br><span class="line">                scheduleLightAlarmLocked(mCurIdleBudget);</span><br><span class="line">                if (DEBUG) Slog.d(TAG,</span><br><span class="line">                        &quot;Moved from LIGHT_STATE_IDLE to LIGHT_STATE_IDLE_MAINTENANCE.&quot;);</span><br><span class="line">                mLightState = LIGHT_STATE_IDLE_MAINTENANCE;</span><br><span class="line">                EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">                addEvent(EVENT_LIGHT_MAINTENANCE);</span><br><span class="line">                // 发送消息，对LIGHT_STATE_IDLE_MAINTENANCE状态进行处理</span><br><span class="line">                mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 当前没有网络连接，先进入LIGHT_STATE_WAITING_FOR_NETWORK等待一个idle的周期</span><br><span class="line">                scheduleLightAlarmLocked(mNextLightIdleDelay);</span><br><span class="line">                if (DEBUG) Slog.d(TAG, &quot;Moved to LIGHT_WAITING_FOR_NETWORK.&quot;);</span><br><span class="line">                mLightState = LIGHT_STATE_WAITING_FOR_NETWORK;</span><br><span class="line">                EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当退出LIGHT_STATE_IDLE状态时，如当前有网络连接或者为LIGHT_STATE_WAITING_FOR_NETWORK状态，则直接进入LIGHT_STATE_IDLE_MAINTENANCE，并发送MSG_REPORT_IDLE_OFF消息处理该状态的切换。如当前没有网络连接时，则先进入LIGHT_STATE_WAITING_FOR_NETWORK等待一个idle的周期等待网络连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">final class MyHandler extends Handler &#123;</span><br><span class="line">    @Override public void handleMessage(Message msg) &#123;</span><br><span class="line">        if (DEBUG) Slog.d(TAG, &quot;handleMessage(&quot; + msg.what + &quot;)&quot;);</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case MSG_WRITE_CONFIG: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_REPORT_IDLE_ON:</span><br><span class="line">            case MSG_REPORT_IDLE_ON_LIGHT: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">            // MSG_REPORT_IDLE_OFF即执行MSG_REPORT_IDLE_ON_LIGHT中的反操作，恢复LIGH_IDLE的限制操作</span><br><span class="line">            case MSG_REPORT_IDLE_OFF: &#123;</span><br><span class="line">                EventLogTags.writeDeviceIdleOffStart(&quot;unknown&quot;);</span><br><span class="line">                final boolean deepChanged = mLocalPowerManager.setDeviceIdleMode(false);</span><br><span class="line">                final boolean lightChanged = mLocalPowerManager.setLightDeviceIdleMode(false);</span><br><span class="line">                try &#123;</span><br><span class="line">                    mNetworkPolicyManager.setDeviceIdleMode(false);</span><br><span class="line">                    mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,</span><br><span class="line">                            null, Process.myUid());</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                if (deepChanged) &#123;</span><br><span class="line">                  ......</span><br><span class="line">                &#125;</span><br><span class="line">                if (lightChanged) &#123;</span><br><span class="line">                  　// 曾加mActiveIdleOpCount计数</span><br><span class="line">                    incActiveIdleOps();</span><br><span class="line">                    // 发送广播，最后执行mIdleStartedDoneReceiver</span><br><span class="line">                    getContext().sendOrderedBroadcastAsUser(mLightIdleIntent, UserHandle.ALL,</span><br><span class="line">                            null, mIdleStartedDoneReceiver, null, 0, null, null);</span><br><span class="line">                &#125;</span><br><span class="line">                // 减少mActiveIdleOpCount计数</span><br><span class="line">                decActiveIdleOps();</span><br><span class="line">                EventLogTags.writeDeviceIdleOffComplete();</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_REPORT_ACTIVE: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_REPORT_MAINTENANCE_ACTIVITY: &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125; break;</span><br><span class="line">            case MSG_FINISH_IDLE_OP: &#123;</span><br><span class="line">              decActiveIdleOps();</span><br><span class="line">            &#125; break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyHandler中处理MSG_REPORT_IDLE_OFF消息主要是恢复MSG_REPORT_IDLE_ON时所做的限制操作，恢复网络，SyncManager，jobsheduler的执行。</p>
<h2 id="LIGHT-STATE-IDLE-MAINTENANCE-gt-LIGHT-STATE-IDLE"><a href="#LIGHT-STATE-IDLE-MAINTENANCE-gt-LIGHT-STATE-IDLE" class="headerlink" title="LIGHT_STATE_IDLE_MAINTENANCE -&gt; LIGHT_STATE_IDLE"></a>LIGHT_STATE_IDLE_MAINTENANCE -&gt; LIGHT_STATE_IDLE</h2><p>LIGHT_STATE_IDLE_MAINTENANCE状态恢复操作处理时，最后执行最后decActiveIdleOps()，同时发送的OrderedBroadcast也会执行mIdleStartedDoneReceiver最后也是调用decActiveIdleOps()处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final BroadcastReceiver mIdleStartedDoneReceiver = new BroadcastReceiver() &#123;</span><br><span class="line">    @Override public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        if (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(intent.getAction())) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP,</span><br><span class="line">                    mConstants.MIN_LIGHT_MAINTENANCE_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>mIdleStartedDoneReceiver中发送MSG_FINISH_IDLE_OP消息，进入decActiveIdleOps()中处理，检查当前是否有active的操作(Alarm，Job)，如果没有则无需等定时器到期提前退出Maintenance windows。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void decActiveIdleOps() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mActiveIdleOpCount--;</span><br><span class="line">        // 当前activie操作小于等于0，说明当前没有执行的操作，可以以前退出Maintenance windows     </span><br><span class="line">        if (mActiveIdleOpCount &lt;= 0) &#123;</span><br><span class="line">            exitMaintenanceEarlyIfNeededLocked();</span><br><span class="line">            mActiveIdleWakeLock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exitMaintenanceEarlyIfNeededLocked() &#123;</span><br><span class="line">    if (mState == STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_IDLE_MAINTENANCE</span><br><span class="line">            || mLightState == LIGHT_STATE_PRE_IDLE) &#123;</span><br><span class="line">        // 当前是否有activie ops操作</span><br><span class="line">        if (isOpsInactiveLocked()) &#123;</span><br><span class="line">            final long now = SystemClock.elapsedRealtime();</span><br><span class="line">            if (mState == STATE_IDLE_MAINTENANCE) &#123;</span><br><span class="line">                stepIdleStateLocked(&quot;s:early&quot;);</span><br><span class="line">            &#125; else if (mLightState == LIGHT_STATE_PRE_IDLE) &#123;</span><br><span class="line">                stepLightIdleStateLocked(&quot;s:predone&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stepLightIdleStateLocked(&quot;s:early&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后续stepLightIdleStateLocked中的处理跟LIGHT_STATE_PRE_IDLE到LIGHT_STATE_IDLE状态切换一致。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之Doze]]></title>
      <url>http://robinheztto.com/2017/09/11/android-power-doze-overview/</url>
      <content type="html"><![CDATA[<blockquote>
<p>从Android M开始，开始引入Doze和App standby两种省电技术以延长电池的使用寿命，其中Doze模式主要针对设备空闲的情况，而App standby针对于未使用的应用。<br>当设备处于灭屏且未充电状态，静止一段时间后就会进入Doze的空闲状态(前提是编译前已通过配置xml文件开启Doze功能)，然后通过限制App访问网络，并推迟Syncs，Jobs，Alarm等工作来减少电池电量的消耗。而Appstandby，主要针对于不是经常使用的App，禁止其后台的网络活动，作业等行为。只要App在android M或更高版本的系统上运行，都会受到Doze和App Standby模式的约束。</p>
</blockquote>
<h1 id="Doze模式"><a href="#Doze模式" class="headerlink" title="Doze模式"></a>Doze模式</h1><p>下面是Doze模式的时序示意图，设备进入Doze模式必须满足三个前提条件，屏幕熄灭，未充电，静止一段时间。在进入Doze模式后，系统会周期性退出Doze空闲状态(下图的maintenance window)，让App有机会完成被限制的活动，以获取更好的用户体验，随着时间的推移，系统调度maintenance窗口的频率会越来越低。</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/doze.png?raw=true" alt="doze"><br></div><br>Doze模式通过对应用活动的限制，来使系统在空闲状态下尽可能的休眠。</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/doze-limit.png?raw=true" alt="doze"><br></div><br>如上图示，当处于Doze Idle状态时，wakelock被disable，网络访问被禁止，Jobs与Syncs，Alarm都被推迟到maintenance window执行，GPS/WiFi扫描也被禁止。</p>
<h1 id="增强Doze模式"><a href="#增强Doze模式" class="headerlink" title="增强Doze模式"></a>增强Doze模式</h1><p>在Android N版本上，Doze模式有了进一步增强，加入了Light idle和Deep idle。相比于M版本，Android N进入Doze模式条件更加宽松，当手机处于未充电状态且灭屏一段时间(不一定是静止状态)，就可以进入Light idle浅度休眠模式。</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/doze-diagram-1.png?raw=true" alt="doze"><br></div><br>Light idle与Deep idle独立运行的，系统会首先进入Light idle然后进入Deep idle，当进入Deep idle后，Light idle状态被忽略。下面是二种模式的比较：</p>
<table>
<thead>
<tr>
<th>IDLE程度</th>
<th>进入条件</th>
<th>对App的行为限制</th>
<th>退出条件</th>
<th>设备硬件要求</th>
</tr>
</thead>
<tbody>
<tr>
<td>Light IDLE</td>
<td>设备不充电，屏幕关闭</td>
<td>1.不能访问网络；<br>2.推迟作业和同步</td>
<td>激活屏幕，设备充电，Alarms定时时间到</td>
<td>无</td>
</tr>
<tr>
<td>Deep IDLE</td>
<td>设备不充电，屏幕关闭，设备保持静止一段时间</td>
<td>1.不能访问网络；<br>2.wake lock失效；<br>3.禁止GPS/WIFI 扫描；<br>4.Alarms推迟；<br>5.作业，同步推迟；</td>
<td>激活屏幕，设备充电，移动设备，Alarms定时时间到</td>
<td>具有SMD（Significant motion Dector），用于检测设备是否处于静止状态传感器</td>
</tr>
</tbody>
</table>
<h1 id="开启Doze功能"><a href="#开启Doze功能" class="headerlink" title="开启Doze功能"></a>开启Doze功能</h1><ol>
<li>安装GCM服务(可选)</li>
<li><p>打开Doze模式的配置开关(AOSP中默认关闭)，修改如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/res/res/values/config.xml</span><br><span class="line"></span><br><span class="line">&lt;!-- Set this to true to enable the platform&apos;s auto-power-save modes like doze and</span><br><span class="line">     app standby.  These are not enabled by default because they require a standard</span><br><span class="line">     cloud-to-device messaging service for apps to interact correctly with the modes</span><br><span class="line">     (such as to be able to deliver an instant message to the device even when it is</span><br><span class="line">     dozing).  This should be enabled if you have such services and expect apps to</span><br><span class="line">     correctly use them when installed on your device.  Otherwise, keep this disabled</span><br><span class="line">     so that applications can still use their own mechanisms. --&gt;</span><br><span class="line">&lt;bool name=&quot;config_enableAutoPowerModes&quot;&gt;true&lt;/bool&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>预装App/服务适配，重要的App/服务加入白名单(如果不能使用GCM服务，App又要求具有即使推送消息功能，那么最好加入到白名单中)</p>
</li>
</ol>
<h1 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h1><p>由于国内网络环境，Android设备基本上不能正常使用Google服务，但App又需要接收实时消息推送，所以系统提供了可以配置的白名单让App免于被Doze模式和App standby模式限制。</p>
<ol>
<li><p>预置应用，对于系统应用，需要默认加入到白名单中，修改<code>frameworks/base/data/etc/platform.xml</code>配置文件，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- These are the standard packages that are white-listed to always have internet</span><br><span class="line">     access while in power save mode, even if they aren&apos;t in the foreground. --&gt;</span><br><span class="line">&lt;allow-in-power-save package=&quot;com.android.providers.downloads&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主动配置，配置的白名单的app数据保存在<code>/data/system/deviceidle.xml</code>。</p>
</li>
</ol>
<ul>
<li>用户可以通过设置&gt;电池&gt;电池优化来手动配置白名单。</li>
<li>App发送Intent，ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS直接导航用户到电池优化界面。</li>
<li>App申请REQUEST_IGNORE_BATTERY_OPTIMIZATIONS权限，通过发送Intent(ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS)触发请求加入白名单的对话框，用户在对话框中选择是或否在决定是否加入白名单(推荐这种方式)</li>
</ul>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><strong>在调试中所有状态都可通过命令<code>adb shell dumpsys deviceidle</code>来查看</strong></p>
<ol>
<li>设置手机未充电状态<br><code>$ adb shell dumpsys battery unplug</code></li>
<li>查看手机充电状态，<code>AC powered:</code>与<code>USB powered:</code>为false说明设置成功<br><code>$ adb shell dumpsys battery</code></li>
<li>enable Doze<br><code>$ adb shell dumpsys deviceidle enable light/deep/all</code></li>
<li>设置Doze模式<br><code>$ adb shell dumpsys deviceidle step light/deep</code></li>
<li>强制直接进入Deep IDLE状态<br><code>$ adb shell dumpsys deviceidle force-idle</code></li>
<li>disable Doze<br><code>$ adb shell dumpsys deviceidle disable</code></li>
<li>reset battery状态<br><code>$ adb shell dumpsys battery reset</code></li>
</ol>
<h1 id="DeviceIdleController"><a href="#DeviceIdleController" class="headerlink" title="DeviceIdleController"></a>DeviceIdleController</h1><p>DeviceIdleController是在system_server中启动的负责管理Doze模式的系统服务。如下图示，DeviceIdleController服务驱动Doze状态机，通过状态的轮转，以发送广播与调用setidle方法的方式通知关联模块对不同状态做出不同的策略。</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/DeviceIdleController.png?raw=true" alt="DeviceIdleController"><br></div><br>在system_server启动过程，执行startOtherServices时，创建并启动了DeviceIdleController服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line"></span><br><span class="line">private void startOtherServices() &#123;</span><br><span class="line">  ......</span><br><span class="line">  mSystemServiceManager.startService(DeviceIdleController.class);</span><br><span class="line">  ......</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>DeviceIdleController继承于SystemService，并且实现AnyMotionDetector.DeviceIdleCallback接口，该接口主要用来监测设备的运动状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/DeviceIdleController.java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Keeps track of device idleness and drives low power mode based on that.</span><br><span class="line"> */</span><br><span class="line">public class DeviceIdleController extends SystemService</span><br><span class="line">        implements AnyMotionDetector.DeviceIdleCallback &#123;</span><br><span class="line">          ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mSystemServiceManager.startService(DeviceIdleController.class)利用反射的方式构造DeviceIdleController服务，然后调用其onStart()方法，首先看构造方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/DeviceIdleController.java</span><br><span class="line"></span><br><span class="line">public DeviceIdleController(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    mConfigFile = new AtomicFile(new File(getSystemDir(), &quot;deviceidle.xml&quot;));</span><br><span class="line">    mHandler = new MyHandler(BackgroundThread.getHandler().getLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DeviceIdleController构造方法中，新建对应/data/system/deviceidle.xml文件的原子操作文件对象，并且创建关联后台线程的mHandler处理消息。接下来看onStart()方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/DeviceIdleController.java</span><br><span class="line"></span><br><span class="line">public void onStart() &#123;</span><br><span class="line">    final PackageManager pm = getContext().getPackageManager();</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // 读取定义在frameworks/base/core/res/res/values/config.xml文件中的config_enableAutoPowerModes</span><br><span class="line">        // 标志是否打开Doze模式     </span><br><span class="line">        mLightEnabled = mDeepEnabled = getContext().getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_enableAutoPowerModes);</span><br><span class="line">        SystemConfig sysConfig = SystemConfig.getInstance();</span><br><span class="line">        // 读取Doze模式下的系统应用白名单配置</span><br><span class="line">        // 该配置在etc/permissions/platform.xml文件中以tag:allow-in-power-save-except-idle的形式定义</span><br><span class="line">        ArraySet&lt;String&gt; allowPowerExceptIdle = sysConfig.getAllowInPowerSaveExceptIdle();</span><br><span class="line">        for (int i=0; i&lt;allowPowerExceptIdle.size(); i++) &#123;</span><br><span class="line">            String pkg = allowPowerExceptIdle.valueAt(i);</span><br><span class="line">            try &#123;</span><br><span class="line">                ApplicationInfo ai = pm.getApplicationInfo(pkg,</span><br><span class="line">                        PackageManager.MATCH_SYSTEM_ONLY);</span><br><span class="line">                int appid = UserHandle.getAppId(ai.uid);</span><br><span class="line">                mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, appid);</span><br><span class="line">                mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, true);</span><br><span class="line">            &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 读取Doze模式及Appstandby模式下的系统应用白名单配置</span><br><span class="line">        // 该配置在etc/permissions/platform.xml文件中以tag:allow-in-power-save的形式定义</span><br><span class="line">        ArraySet&lt;String&gt; allowPower = sysConfig.getAllowInPowerSave();</span><br><span class="line">        for (int i=0; i&lt;allowPower.size(); i++) &#123;</span><br><span class="line">            String pkg = allowPower.valueAt(i);</span><br><span class="line">            try &#123;</span><br><span class="line">                ApplicationInfo ai = pm.getApplicationInfo(pkg,</span><br><span class="line">                        PackageManager.MATCH_SYSTEM_ONLY);</span><br><span class="line">                int appid = UserHandle.getAppId(ai.uid);</span><br><span class="line">                // These apps are on both the whitelist-except-idle as well</span><br><span class="line">                // as the full whitelist, so they apply in all cases.</span><br><span class="line">                mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, appid);</span><br><span class="line">                mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, true);</span><br><span class="line">                mPowerSaveWhitelistApps.put(ai.packageName, appid);</span><br><span class="line">                mPowerSaveWhitelistSystemAppIds.put(appid, true);</span><br><span class="line">            &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新常量设置</span><br><span class="line">        mConstants = new Constants(mHandler, getContext().getContentResolver());</span><br><span class="line">        // 读取Doze模式及Appstandby模式下的用户应用白名单配置</span><br><span class="line">        // 该配置在data/system/deviceidle.xml文件中以tag:wl的形式定义</span><br><span class="line">        readConfigFileLocked();</span><br><span class="line">        // 合并系统应用及用户应用白名单，并设置到PowerManager及AlarmManager中</span><br><span class="line">        updateWhitelistAppIdsLocked();</span><br><span class="line"></span><br><span class="line">        // 初始化相关成员的状态</span><br><span class="line">        mNetworkConnected = true;</span><br><span class="line">        mScreenOn = true;</span><br><span class="line">        // Start out assuming we are charging.  If we aren&apos;t, we will at least get</span><br><span class="line">        // a battery update the next time the level drops.</span><br><span class="line">        mCharging = true;</span><br><span class="line">        mState = STATE_ACTIVE;</span><br><span class="line">        mLightState = LIGHT_STATE_ACTIVE;</span><br><span class="line">        mInactiveTimeout = mConstants.INACTIVE_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发布BinderService与LocalService对象，提供接口给其他进程或本进程内其他服务</span><br><span class="line">    mBinderService = new BinderService();</span><br><span class="line">    publishBinderService(Context.DEVICE_IDLE_CONTROLLER, mBinderService);</span><br><span class="line">    publishLocalService(LocalService.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onStart()中初始化了白名单设置，如下所示分成三类：</p>
<ol>
<li>System-excidle (system app) : used for doze<br>ArrayMap<string, interger=""> mPowerSaveWhitelistAppsExceptIdle<br>String: packageName<br>Interger: app Uid<br>From etc/permissions/platform.xml tag: allow-in-power-save-except-idle (SystemConfig.mAllowInPowerSaveExceptIdle)</string,></li>
<li>System (system app) : used for doze &amp; app standby<br>ArrayMap<string, interger=""> mPowerSaveWhitelistApps<br>From etc/permissions/platform.xml tag : allow-in-power-save (SystemConfig.mAllowInPowerSave)</string,></li>
<li>User :  used for doze &amp; app standby<br>ArrayMap<string,interger> mPowerSaveWhitelistUserApps<br>From data/system/deviceidle.xml tag: wl</string,interger></li>
</ol>
<p>当所有系统服务就绪后，会执行<code>mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</code>回调到DeviceIdleController的onBootPhase()方法中，下面继续看onBootPhase()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBootPhase(int phase) &#123;</span><br><span class="line">    if (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // 获取相关的系统服务                      </span><br><span class="line">            mAlarmManager = (AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">            mBatteryStats = BatteryStatsService.getService();</span><br><span class="line">            mLocalPowerManager = getLocalService(PowerManagerInternal.class);</span><br><span class="line">            mPowerManager = getContext().getSystemService(PowerManager.class);</span><br><span class="line">            // 创建WakeLock,用于maintenance windows时期防止系统休眠</span><br><span class="line">            mActiveIdleWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">                    &quot;deviceidle_maint&quot;);</span><br><span class="line">            // 设置WakeLock引用计数为false</span><br><span class="line">            mActiveIdleWakeLock.setReferenceCounted(false);</span><br><span class="line">            mConnectivityService = (ConnectivityService)ServiceManager.getService(</span><br><span class="line">                    Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            mLocalAlarmManager = getLocalService(AlarmManagerService.LocalService.class);</span><br><span class="line">            mNetworkPolicyManager = INetworkPolicyManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));</span><br><span class="line">            mDisplayManager = (DisplayManager) getContext().getSystemService(</span><br><span class="line">                    Context.DISPLAY_SERVICE);</span><br><span class="line">            mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);</span><br><span class="line">            // 读取定义在frameworks/base/core/res/res/values/config.xml文件中的config_autoPowerModeAnyMotionSensor</span><br><span class="line">            // 获取传感器ID,没有则继续获取</span><br><span class="line">            int sigMotionSensorId = getContext().getResources().getInteger(</span><br><span class="line">                    com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);</span><br><span class="line">            if (sigMotionSensorId &gt; 0) &#123;</span><br><span class="line">                mMotionSensor = mSensorManager.getDefaultSensor(sigMotionSensorId, true);</span><br><span class="line">            &#125;</span><br><span class="line">            // 读取定义在frameworks/base/core/res/res/values/config.xml文件中的config_autoPowerModePreferWristTilt</span><br><span class="line">            // 有设置，则获取传感器ID，根据ID获取传感器实例，没有则继续获取</span><br><span class="line">            if (mMotionSensor == null &amp;&amp; getContext().getResources().getBoolean(</span><br><span class="line">                    com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) &#123;</span><br><span class="line">                mMotionSensor = mSensorManager.getDefaultSensor(</span><br><span class="line">                        Sensor.TYPE_WRIST_TILT_GESTURE, true);</span><br><span class="line">            &#125;</span><br><span class="line">            // 最后，获取TYPE_SIGNIFICANT_MOTION传感器，获取成功则可以进入Deep Doze模式，没有则只能进入Light Doze模式</span><br><span class="line">            if (mMotionSensor == null) &#123;</span><br><span class="line">                // As a last ditch, fall back to SMD.</span><br><span class="line">                mMotionSensor = mSensorManager.getDefaultSensor(</span><br><span class="line">                        Sensor.TYPE_SIGNIFICANT_MOTION, true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (getContext().getResources().getBoolean(</span><br><span class="line">                    com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) &#123;</span><br><span class="line">                mLocationManager = (LocationManager) getContext().getSystemService(</span><br><span class="line">                        Context.LOCATION_SERVICE);</span><br><span class="line">                mLocationRequest = new LocationRequest()</span><br><span class="line">                    .setQuality(LocationRequest.ACCURACY_FINE)</span><br><span class="line">                    .setInterval(0)</span><br><span class="line">                    .setFastestInterval(0)</span><br><span class="line">                    .setNumUpdates(1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 获取运动传感器检测角度的阀值,并创建AnyMotionDetector</span><br><span class="line">            float angleThreshold = getContext().getResources().getInteger(</span><br><span class="line">                    com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;</span><br><span class="line">            mAnyMotionDetector = new AnyMotionDetector(</span><br><span class="line">                    (PowerManager) getContext().getSystemService(Context.POWER_SERVICE),</span><br><span class="line">                    mHandler, mSensorManager, this, angleThreshold);</span><br><span class="line"></span><br><span class="line">            // light mode与deep mode的Intent,用于通知其他模块进入light/deep模式                            </span><br><span class="line">            mIdleIntent = new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);</span><br><span class="line">            mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                    | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">            mLightIdleIntent = new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);</span><br><span class="line">            mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                    | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line"></span><br><span class="line">            // 注册BATTERY_CHANGED广播                        </span><br><span class="line">            IntentFilter filter = new IntentFilter();</span><br><span class="line">            filter.addAction(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">            getContext().registerReceiver(mReceiver, filter);</span><br><span class="line"></span><br><span class="line">            // 注册PACKAGE_REMOVED广播   </span><br><span class="line">            filter = new IntentFilter();</span><br><span class="line">            filter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">            filter.addDataScheme(&quot;package&quot;);</span><br><span class="line">            getContext().registerReceiver(mReceiver, filter);</span><br><span class="line"></span><br><span class="line">            // 注册网络变化广播</span><br><span class="line">            filter = new IntentFilter();</span><br><span class="line">            filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">            getContext().registerReceiver(mReceiver, filter);</span><br><span class="line"></span><br><span class="line">            // 设置PowerManager,AlarmManager中Doze模式白名单应用</span><br><span class="line">            mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);</span><br><span class="line">            mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);</span><br><span class="line">            // 注册屏幕亮灭监听</span><br><span class="line">            mDisplayManager.registerDisplayListener(mDisplayListener, null);</span><br><span class="line">            // 更新当前屏幕亮灭状态</span><br><span class="line">            updateDisplayLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        // 更新当前网络连接状态</span><br><span class="line">        updateConnectivityState(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传感器选用规则：<br>Doze 模式启动之前会对当前设备传感器进行检查，以决定doze模式的深度：<br>步骤1：检查com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor，如果有设置，则获取传感器ID，根据ID获取传感器实例，没有的话跳到步骤2。<br>步骤2：检查com.android.internal.R.bool.config_autoPowerModePreferWristTilt，如果有设置，则获取传感器ID，根据ID获取传感器实例，没有的话跳到步骤3。<br>步骤3：获取TYPE_SIGNIFICANT_MOTION传感器，获取成功则有条件可以进入Deep Doze模式，没有则只能进入Light Doze模式。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之PowerManagerService(二)]]></title>
      <url>http://robinheztto.com/2017/06/16/android-power-pms-2/</url>
      <content type="html"><![CDATA[<h1 id="WakeLock机制"><a href="#WakeLock机制" class="headerlink" title="WakeLock机制"></a>WakeLock机制</h1><h2 id="PowerManager-WakeLock"><a href="#PowerManager-WakeLock" class="headerlink" title="PowerManager.WakeLock"></a>PowerManager.WakeLock</h2><p>为了延长电池的使用寿命，Android设备会在一段时间后使屏幕变暗，然后关闭屏幕显示，直至停止CPU进入休眠。WakeLock是Android提供的唤醒锁机制，用来保持CPU运行或避免屏幕变暗/关闭以及避免键盘背光灯熄灭。</p>
<p>唤醒锁的类型：</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>CPU</th>
<th>Screen</th>
<th>Keyboard</th>
</tr>
</thead>
<tbody>
<tr>
<td>PARTIAL_WAKE_LOCK</td>
<td>on</td>
<td>off</td>
<td>off</td>
</tr>
<tr>
<td>SCREEN_DIM_WAKE_LOCK</td>
<td>on</td>
<td>Dim</td>
<td>off</td>
</tr>
<tr>
<td>SCREEN_BRIGHT_WAKE_LOCK</td>
<td>on</td>
<td>Bright</td>
<td>off</td>
</tr>
<tr>
<td>FULL_WAKE_LOCK</td>
<td>on</td>
<td>Bright</td>
<td>on</td>
</tr>
</tbody>
</table>
<p>如果是PARTIAL_WAKE_LOCK,无论屏幕的状态或是按下电源键, CPU都将正常工作。如果是其它的唤醒锁,设备会在用户按下电源钮后停止工作进入休眠状态。以上四种锁，除了PARTIAL_WAKE_LOCK，其余的锁在API level 17已经被deprecated了。</p>
<p>唤醒锁的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">权限申明：</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.DEVICE_POWER&quot;/&gt;</span><br><span class="line"></span><br><span class="line">代码使用：</span><br><span class="line">PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);</span><br><span class="line">PowerManager.WakeLock wl =  powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;My Tag&quot;);</span><br><span class="line">wl.acquire();　//acquire时尽量申明timeout时间</span><br><span class="line">//......</span><br><span class="line">wl.release();</span><br></pre></td></tr></table></figure></p>
<p>在应用程序中使用WakeLock时必须申明权限，acquire请求唤醒锁时尽量设置timeout时间释放WakeLock，以避免长时间持有WakeLock导致系统无法休眠。</p>
<p>唤醒锁的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/os/PowerManager.java</span><br><span class="line"></span><br><span class="line">public final class WakeLock &#123;</span><br><span class="line">    private int mFlags;</span><br><span class="line">    private String mTag;</span><br><span class="line">    private final String mPackageName;</span><br><span class="line">    private final IBinder mToken;</span><br><span class="line">    private int mCount;</span><br><span class="line">    private boolean mRefCounted = true;</span><br><span class="line">    private boolean mHeld;</span><br><span class="line">    private WorkSource mWorkSource;</span><br><span class="line">    private String mHistoryTag;</span><br><span class="line">    private final String mTraceName;</span><br><span class="line">    ......</span><br><span class="line">    WakeLock(int flags, String tag, String packageName) &#123;</span><br><span class="line">        mFlags = flags;</span><br><span class="line">        mTag = tag;</span><br><span class="line">        mPackageName = packageName;</span><br><span class="line">        mToken = new Binder();</span><br><span class="line">        mTraceName = &quot;WakeLock (&quot; + mTag + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="updatePowerStateLocked"><a href="#updatePowerStateLocked" class="headerlink" title="updatePowerStateLocked"></a>updatePowerStateLocked</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">protected void updatePowerStateLocked() &#123;</span><br><span class="line">    // 服务没有ready,mDirty值没有设置情况下不做更新操作</span><br><span class="line">    if (!mSystemReady || mDirty == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!Thread.holdsLock(mLock)) &#123;</span><br><span class="line">        Slog.wtf(TAG, &quot;Power manager lock was not held when calling updatePowerStateLocked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // Phase 0: 更新基本状态</span><br><span class="line">        updateIsPoweredLocked(mDirty);</span><br><span class="line">        updateStayOnLocked(mDirty);</span><br><span class="line">        updateScreenBrightnessBoostLocked(mDirty);</span><br><span class="line"></span><br><span class="line">        // Phase 1: Update wakefulness.</span><br><span class="line">        // Loop because the wake lock and user activity computations are influenced</span><br><span class="line">        // by changes in wakefulness.</span><br><span class="line">        final long now = SystemClock.uptimeMillis();</span><br><span class="line">        int dirtyPhase2 = 0;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int dirtyPhase1 = mDirty;</span><br><span class="line">            dirtyPhase2 |= dirtyPhase1;</span><br><span class="line">            mDirty = 0;</span><br><span class="line"></span><br><span class="line">            updateWakeLockSummaryLocked(dirtyPhase1);</span><br><span class="line">            updateUserActivitySummaryLocked(now, dirtyPhase1);</span><br><span class="line">            if (!updateWakefulnessLocked(dirtyPhase1)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Phase 2: Update display power state.</span><br><span class="line">        boolean displayBecameReady = updateDisplayPowerStateLocked(dirtyPhase2);</span><br><span class="line"></span><br><span class="line">        // Phase 3: Update dream state (depends on display ready signal).</span><br><span class="line">        updateDreamLocked(dirtyPhase2, displayBecameReady);</span><br><span class="line"></span><br><span class="line">        // Phase 4: Send notifications, if needed.</span><br><span class="line">        finishWakefulnessChangeIfNeededLocked();</span><br><span class="line"></span><br><span class="line">        // Phase 5: Update suspend blocker.</span><br><span class="line">        // Because we might release the last suspend blocker here, we need to make sure</span><br><span class="line">        // we finished everything else first!</span><br><span class="line">        updateSuspendBlockerLocked();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_POWER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看updateIsPoweredLocked(mDirty);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">private void updateIsPoweredLocked(int dirty) &#123;</span><br><span class="line">    if ((dirty &amp; DIRTY_BATTERY_STATE) != 0) &#123;</span><br><span class="line">        final boolean wasPowered = mIsPowered;</span><br><span class="line">        final int oldPlugType = mPlugType;</span><br><span class="line">        final boolean oldLevelLow = mBatteryLevelLow;</span><br><span class="line">        mIsPowered = mBatteryManagerInternal.isPowered(BatteryManager.BATTERY_PLUGGED_ANY);</span><br><span class="line">        mPlugType = mBatteryManagerInternal.getPlugType();</span><br><span class="line">        mBatteryLevel = mBatteryManagerInternal.getBatteryLevel();</span><br><span class="line">        mBatteryLevelLow = mBatteryManagerInternal.getBatteryLevelLow();</span><br><span class="line"></span><br><span class="line">        if (wasPowered != mIsPowered || oldPlugType != mPlugType) &#123;</span><br><span class="line">            mDirty |= DIRTY_IS_POWERED;</span><br><span class="line"></span><br><span class="line">            // Update wireless dock detection state.</span><br><span class="line">            final boolean dockedOnWirelessCharger = mWirelessChargerDetector.update(</span><br><span class="line">                    mIsPowered, mPlugType, mBatteryLevel);</span><br><span class="line"></span><br><span class="line">            // Treat plugging and unplugging the devices as a user activity.</span><br><span class="line">            // Users find it disconcerting when they plug or unplug the device</span><br><span class="line">            // and it shuts off right away.</span><br><span class="line">            // Some devices also wake the device when plugged or unplugged because</span><br><span class="line">            // they don&apos;t have a charging LED.</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            if (shouldWakeUpWhenPluggedOrUnpluggedLocked(wasPowered, oldPlugType,</span><br><span class="line">                    dockedOnWirelessCharger)) &#123;</span><br><span class="line">                wakeUpNoUpdateLocked(now, &quot;android.server.power:POWER&quot;, Process.SYSTEM_UID,</span><br><span class="line">                        mContext.getOpPackageName(), Process.SYSTEM_UID);</span><br><span class="line">            &#125;</span><br><span class="line">            userActivityNoUpdateLocked(</span><br><span class="line">                    now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID);</span><br><span class="line"></span><br><span class="line">            // Tell the notifier whether wireless charging has started so that</span><br><span class="line">            // it can provide feedback to the user.</span><br><span class="line">            //Bug293654, zhanghong.wt, modify, 20170914, modify no notificatin ring while plugging USB</span><br><span class="line">            if (dockedOnWirelessCharger || (mIsPowered &amp;&amp; oldPlugType != mPlugType&amp;&amp;(&quot;1&quot;.equals(SystemProperties.get(&quot;sys.boot_completed&quot;))))) &#123;</span><br><span class="line">                mNotifier.onWirelessChargingStarted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (wasPowered != mIsPowered || oldLevelLow != mBatteryLevelLow) &#123;</span><br><span class="line">            if (oldLevelLow != mBatteryLevelLow &amp;&amp; !mBatteryLevelLow) &#123;</span><br><span class="line">                if (DEBUG_SPEW) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;updateIsPoweredLocked: resetting low power snooze&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                mAutoLowPowerModeSnoozing = false;</span><br><span class="line">            &#125;</span><br><span class="line">            updateLowPowerModeLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之PowerManagerService(一)]]></title>
      <url>http://robinheztto.com/2017/06/14/android-power-pms-1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>PowerManagerService提供Android系统的电源管理服务，主要功能是控制系统待机状态，屏幕显示，亮度调节，光线/距离传感器的控制等。</p>
<p>相关代码在以下文件中：<br>frameworks/base/services/java/com/android/server/SystemServer.java<br>frameworks/base/core/java/android/os/PowerManager.java<br>frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java<br>frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp<br>frameworks/base/core/java/android/os/PowerManagerInternal.java<br>frameworks/base/services/core/java/com/android/server/power/Notifier.java<br>device/qcom/common/power/power.c<br>system/core/libsuspend/autosuspend.c<br>hardware/libhardware_legacy/power/power.c</p>
</blockquote>
<h1 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h1><p>跟其他系统服务一样，PowerManagerService也是继承于SystemService并通过SystemServer启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">public final class PowerManagerService extends SystemService</span><br><span class="line">        implements Watchdog.Monitor &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line"></span><br><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">  ......</span><br><span class="line">  mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在SystemServer的startBootstrapServices中，通过SystemServiceManager.startService启动了PowerManagerService，下面首先来看PowerManagerService构造方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">public PowerManagerService(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    // mContext赋值为SystemContext</span><br><span class="line">    mContext = context;</span><br><span class="line">    // 创建消息处理线程并启动，创建关联消息处理线程的handler对象</span><br><span class="line">    mHandlerThread = new ServiceThread(TAG,</span><br><span class="line">            Process.THREAD_PRIORITY_DISPLAY, false /*allowIo*/);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    mHandler = new PowerManagerHandler(mHandlerThread.getLooper());</span><br><span class="line">    qcNsrmPowExt = new QCNsrmPowerExtension(this);</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        // 创建&quot;PowerManagerService.WakeLocks&quot;的SuspendBlocker</span><br><span class="line">        mWakeLockSuspendBlocker = createSuspendBlockerLocked(&quot;PowerManagerService.WakeLocks&quot;);</span><br><span class="line">        // 创建&quot;PowerManagerService.Display&quot;的SuspendBlocker</span><br><span class="line">        mDisplaySuspendBlocker = createSuspendBlockerLocked(&quot;PowerManagerService.Display&quot;);</span><br><span class="line">        // 请求DisplaySuspendBlocker，禁止系统进入休眠</span><br><span class="line">        mDisplaySuspendBlocker.acquire();</span><br><span class="line">        mHoldingDisplaySuspendBlocker = true;</span><br><span class="line">        mHalAutoSuspendModeEnabled = false;</span><br><span class="line">        mHalInteractiveModeEnabled = true;</span><br><span class="line">        // 设置mWakefulness为唤醒状态</span><br><span class="line">        mWakefulness = WAKEFULNESS_AWAKE;</span><br><span class="line">        // 进入到native层初始化</span><br><span class="line">        nativeInit();</span><br><span class="line">        nativeSetAutoSuspend(false);</span><br><span class="line">        nativeSetInteractive(true);</span><br><span class="line">        nativeSetFeature(POWER_FEATURE_DOUBLE_TAP_TO_WAKE, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerManagerService构造函数中首先创建了处理消息的进程及对应的handler对象以进行消息处理，然后创建SuspendBlocker对象，用于WakeLocks与Display，并设置mWakefulness的初始状态为WAKEFULNESS_AWAKE，最后进入到native层初始化。下面先看一下关于mWakefulness的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/os/PowerManagerInternal.java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设备处于休眠状态，只能被wakeUp()唤醒．</span><br><span class="line"> */</span><br><span class="line">public static final int WAKEFULNESS_ASLEEP = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设备处于正常工作(fully awake)状态．</span><br><span class="line"> */</span><br><span class="line">public static final int WAKEFULNESS_AWAKE = 1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设备处于播放屏保状态．</span><br><span class="line"> */</span><br><span class="line">public static final int WAKEFULNESS_DREAMING = 2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设备处于doze状态，只有低耗电的屏保可以运行，其他应用被挂起．</span><br><span class="line"> */</span><br><span class="line">public static final int WAKEFULNESS_DOZING = 3;</span><br></pre></td></tr></table></figure></p>
<p>继续回到PowerManagerService构造函数的native初始化中，首先来看nativeInit的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp</span><br><span class="line"></span><br><span class="line">static const JNINativeMethod gPowerManagerServiceMethods[] = &#123;</span><br><span class="line">    /* name, signature, funcPtr */</span><br><span class="line">    &#123; &quot;nativeInit&quot;, &quot;()V&quot;,</span><br><span class="line">            (void*) nativeInit &#125;,</span><br><span class="line">    &#123; &quot;nativeAcquireSuspendBlocker&quot;, &quot;(Ljava/lang/String;)V&quot;,</span><br><span class="line">            (void*) nativeAcquireSuspendBlocker &#125;,</span><br><span class="line">    &#123; &quot;nativeReleaseSuspendBlocker&quot;, &quot;(Ljava/lang/String;)V&quot;,</span><br><span class="line">            (void*) nativeReleaseSuspendBlocker &#125;,</span><br><span class="line">    &#123; &quot;nativeSetInteractive&quot;, &quot;(Z)V&quot;,</span><br><span class="line">            (void*) nativeSetInteractive &#125;,</span><br><span class="line">    &#123; &quot;nativeSetAutoSuspend&quot;, &quot;(Z)V&quot;,</span><br><span class="line">            (void*) nativeSetAutoSuspend &#125;,</span><br><span class="line">    &#123; &quot;nativeSendPowerHint&quot;, &quot;(II)V&quot;,</span><br><span class="line">            (void*) nativeSendPowerHint &#125;,</span><br><span class="line">    &#123; &quot;nativeSetFeature&quot;, &quot;(II)V&quot;,</span><br><span class="line">            (void*) nativeSetFeature &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>PowerManagerService中的native方法定义如上，nativeInit即调用nativeInit()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp</span><br><span class="line"></span><br><span class="line">static void nativeInit(JNIEnv* env, jobject obj) &#123;</span><br><span class="line">    // 创建一个全局对象，引用PMS</span><br><span class="line">    gPowerManagerServiceObj = env-&gt;NewGlobalRef(obj);</span><br><span class="line">    // 利用hw_get_module加载power模块</span><br><span class="line">    status_t err = hw_get_module(POWER_HARDWARE_MODULE_ID,</span><br><span class="line">            (hw_module_t const**)&amp;gPowerModule);</span><br><span class="line">    if (!err) &#123;</span><br><span class="line">        gPowerModule-&gt;init(gPowerModule);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGE(&quot;Couldn&apos;t load %s module (%s)&quot;, POWER_HARDWARE_MODULE_ID, strerror(-err));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nativeInit的主要任务时装载power模块，该模块由厂商实现，以高通为例，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; device/qcom/common/power/power.c</span><br><span class="line"></span><br><span class="line">static struct hw_module_methods_t power_module_methods = &#123;</span><br><span class="line">    .open = NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct power_module HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .common = &#123;</span><br><span class="line">        .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">        .module_api_version = POWER_MODULE_API_VERSION_0_2,</span><br><span class="line">        .hal_api_version = HARDWARE_HAL_API_VERSION,</span><br><span class="line">        .id = POWER_HARDWARE_MODULE_ID,</span><br><span class="line">        .name = &quot;QCOM Power HAL&quot;,</span><br><span class="line">        .author = &quot;Qualcomm&quot;,</span><br><span class="line">        .methods = &amp;power_module_methods,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    .init = power_init,</span><br><span class="line">    .powerHint = power_hint,</span><br><span class="line">    .setInteractive = set_interactive,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>power_module中实现了init，powerHint，setInteractive，nativeInit最终调用到HAL power模块的power_init具体实现中。接着看native初始化nativeSetAutoSuspend的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp</span><br><span class="line"></span><br><span class="line">static void nativeSetAutoSuspend(JNIEnv* /* env */, jclass /* clazz */, jboolean enable) &#123;</span><br><span class="line">    if (enable) &#123;</span><br><span class="line">        ALOGD_IF_SLOW(100, &quot;Excessive delay in autosuspend_enable() while turning screen off&quot;);</span><br><span class="line">        autosuspend_enable();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGD_IF_SLOW(100, &quot;Excessive delay in autosuspend_disable() while turning screen on&quot;);</span><br><span class="line">        autosuspend_disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; system/core/libsuspend/autosuspend.c</span><br><span class="line"></span><br><span class="line">int autosuspend_disable(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    ret = autosuspend_init();</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;autosuspend_disable\n&quot;);</span><br><span class="line"></span><br><span class="line">    if (!autosuspend_enabled) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = autosuspend_ops-&gt;disable();</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    autosuspend_enabled = false;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nativeSetAutoSuspend最终调用到libsuspend(参考Android电源管理系列之libsuspend)的autosuspend_disable禁止系统休眠。继续看native初始化nativeSetInteractive，nativeSetFeature的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp</span><br><span class="line"></span><br><span class="line">static void nativeSetInteractive(JNIEnv* /* env */, jclass /* clazz */, jboolean enable) &#123;</span><br><span class="line">    if (gPowerModule) &#123;</span><br><span class="line">        if (enable) &#123;</span><br><span class="line">            ALOGD_IF_SLOW(20, &quot;Excessive delay in setInteractive(true) while turning screen on&quot;);</span><br><span class="line">            gPowerModule-&gt;setInteractive(gPowerModule, true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGD_IF_SLOW(20, &quot;Excessive delay in setInteractive(false) while turning screen off&quot;);</span><br><span class="line">            gPowerModule-&gt;setInteractive(gPowerModule, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void nativeSetFeature(JNIEnv *env, jclass clazz, jint featureId, jint data) &#123;</span><br><span class="line">    int data_param = data;</span><br><span class="line"></span><br><span class="line">    if (gPowerModule &amp;&amp; gPowerModule-&gt;setFeature) &#123;</span><br><span class="line">        gPowerModule-&gt;setFeature(gPowerModule, (feature_t)featureId, data_param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同nativeInit一样，最终都是调用到HAL power模块的具体实现中。以上是构造函数的分析流程，下面继续看PowerManagerService在系统启动过程中回调onStart()，onBootPhase()，systemReady()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">public void onStart() &#123;</span><br><span class="line">    publishBinderService(Context.POWER_SERVICE, new BinderService());</span><br><span class="line">    publishLocalService(PowerManagerInternal.class, new LocalService());</span><br><span class="line"></span><br><span class="line">    Watchdog.getInstance().addMonitor(this);</span><br><span class="line">    Watchdog.getInstance().addThread(mHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final class BinderService extends IPowerManager.Stub ｛</span><br><span class="line">    ......</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">private final class LocalService extends PowerManagerInternal &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onStart()中发布了BinderService，LocalService分别供其他进程，进程内其他服务调用，并将PowerManagerService加入到Watchdog监控中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">public void onBootPhase(int phase) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; else if (phase == PHASE_BOOT_COMPLETED) &#123;</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            // 设置mBootCompleted状态</span><br><span class="line">            mBootCompleted = true;</span><br><span class="line">            mDirty |= DIRTY_BOOT_COMPLETED;</span><br><span class="line">            // 更新userActivity及PowerState，后面分析</span><br><span class="line">            userActivityNoUpdateLocked(</span><br><span class="line">                    now, PowerManager.USER_ACTIVITY_EVENT_OTHER, 0, Process.SYSTEM_UID);</span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">            // 执行mBootCompletedRunnables中的runnable方法</span><br><span class="line">            if (!ArrayUtils.isEmpty(mBootCompletedRunnables)) &#123;</span><br><span class="line">                Slog.d(TAG, &quot;Posting &quot; + mBootCompletedRunnables.length + &quot; delayed runnables&quot;);</span><br><span class="line">                for (Runnable r : mBootCompletedRunnables) &#123;</span><br><span class="line">                    BackgroundThread.getHandler().post(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mBootCompletedRunnables = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onBootPhase中主要设置mBootCompleted状态，更新PowerState状态，并执行mBootCompletedRunnables中的runnables方法(低电量模式会设置)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">public void systemReady(IAppOpsService appOps) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mSystemReady = true;</span><br><span class="line">        // 获取AppOpsService</span><br><span class="line">        mAppOps = appOps;</span><br><span class="line">        // 获取DreamManager</span><br><span class="line">        mDreamManager = getLocalService(DreamManagerInternal.class);</span><br><span class="line">        // 获取DisplayManagerService</span><br><span class="line">        mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);</span><br><span class="line">        mPolicy = getLocalService(WindowManagerPolicy.class);</span><br><span class="line">        // 获取mBatteryService</span><br><span class="line">        mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);</span><br><span class="line"></span><br><span class="line">        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">        // 获取屏幕默认，最大，最小亮度</span><br><span class="line">        mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();</span><br><span class="line">        mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();</span><br><span class="line">        mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();</span><br><span class="line">        // 获取SensorManager</span><br><span class="line">        SensorManager sensorManager = new SystemSensorManager(mContext, mHandler.getLooper());</span><br><span class="line"></span><br><span class="line">        mBatteryStats = BatteryStatsService.getService();</span><br><span class="line">        // 创建Notifier对象，用于广播power state的变化</span><br><span class="line">        mNotifier = new Notifier(Looper.getMainLooper(), mContext, mBatteryStats,</span><br><span class="line">                mAppOps, createSuspendBlockerLocked(&quot;PowerManagerService.Broadcasts&quot;),</span><br><span class="line">                mPolicy);</span><br><span class="line">        // 无线充电检测</span><br><span class="line">        mWirelessChargerDetector = new WirelessChargerDetector(sensorManager,</span><br><span class="line">                createSuspendBlockerLocked(&quot;PowerManagerService.WirelessChargerDetector&quot;),</span><br><span class="line">                mHandler);</span><br><span class="line">        // 监听设置的变化</span><br><span class="line">        mSettingsObserver = new SettingsObserver(mHandler);</span><br><span class="line"></span><br><span class="line">        mLightsManager = getLocalService(LightsManager.class);</span><br><span class="line">        mAttentionLight = mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);</span><br><span class="line"></span><br><span class="line">        // Initialize display power management.</span><br><span class="line">        mDisplayManagerInternal.initPowerManagement(</span><br><span class="line">                mDisplayPowerCallbacks, mHandler, sensorManager);</span><br><span class="line"></span><br><span class="line">        // Register for settings changes.</span><br><span class="line">        final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        resolver.registerContentObserver(Settings.Secure.getUriFor(</span><br><span class="line">                Settings.Secure.SCREENSAVER_ENABLED),</span><br><span class="line">        ......</span><br><span class="line">        IVrManager vrManager =</span><br><span class="line">                (IVrManager) getBinderService(VrManagerService.VR_MANAGER_BINDER_SERVICE);</span><br><span class="line">        try &#123;</span><br><span class="line">            vrManager.registerListener(mVrStateCallbacks);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.e(TAG, &quot;Failed to register VR mode state listener: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        // 读取配置</span><br><span class="line">        readConfigurationLocked();</span><br><span class="line">        updateSettingsLocked();</span><br><span class="line">        mDirty |= DIRTY_BATTERY_STATE;</span><br><span class="line">        updatePowerStateLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Register for broadcasts from other components of the system.</span><br><span class="line">    IntentFilter filter = new IntentFilter();</span><br><span class="line">    filter.addAction(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">    filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);</span><br><span class="line">    mContext.registerReceiver(new BatteryReceiver(), filter, null, mHandler);</span><br><span class="line"></span><br><span class="line">    filter = new IntentFilter();</span><br><span class="line">    filter.addAction(Intent.ACTION_DREAMING_STARTED);</span><br><span class="line">    filter.addAction(Intent.ACTION_DREAMING_STOPPED);</span><br><span class="line">    mContext.registerReceiver(new DreamReceiver(), filter, null, mHandler);</span><br><span class="line"></span><br><span class="line">    filter = new IntentFilter();</span><br><span class="line">    filter.addAction(Intent.ACTION_USER_SWITCHED);</span><br><span class="line">    mContext.registerReceiver(new UserSwitchedReceiver(), filter, null, mHandler);</span><br><span class="line"></span><br><span class="line">    filter = new IntentFilter();</span><br><span class="line">    filter.addAction(Intent.ACTION_DOCK_EVENT);</span><br><span class="line">    mContext.registerReceiver(new DockReceiver(), filter, null, mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="userActivity"><a href="#userActivity" class="headerlink" title="userActivity"></a>userActivity</h1><p>userActivity是定义在PowerManager中的SystemApi，用户向PowerManagerService报告用户活动，以更新PowerManagerService内部时间/状态值，推迟系统休眠的时间。下面首先来看userActivity的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/os/PowerManager.java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * User activity event type: Unspecified event type.</span><br><span class="line"> */</span><br><span class="line">public static final int USER_ACTIVITY_EVENT_OTHER = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * User activity event type: Button or key pressed or released.</span><br><span class="line"> */</span><br><span class="line">public static final int USER_ACTIVITY_EVENT_BUTTON = 1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * User activity event type: Touch down, move or up.</span><br><span class="line"> */</span><br><span class="line">public static final int USER_ACTIVITY_EVENT_TOUCH = 2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * User activity event type: Accessibility taking action on behalf of user.</span><br><span class="line"> */</span><br><span class="line">public static final int USER_ACTIVITY_EVENT_ACCESSIBILITY = 3;</span><br><span class="line"></span><br><span class="line">@SystemApi</span><br><span class="line">public void userActivity(long when, int event, int flags) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mService.userActivity(when, event, flags);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">private final class BinderService extends IPowerManager.Stub &#123;</span><br><span class="line">  ......</span><br><span class="line">  public void userActivity(long eventTime, int event, int flags) &#123;</span><br><span class="line">      final long now = SystemClock.uptimeMillis();</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      if (eventTime &gt; now) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;event time must not be in the future&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final int uid = Binder.getCallingUid();</span><br><span class="line">      final long ident = Binder.clearCallingIdentity();</span><br><span class="line">      try &#123;</span><br><span class="line">          userActivityInternal(eventTime, event, flags, uid);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          Binder.restoreCallingIdentity(ident);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerManager中userActivity请求调用服务端PowerManagerService BinderService的userActivity，即调用内部方法userActivityInternal。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">private void userActivityInternal(long eventTime, int event, int flags, int uid) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (userActivityNoUpdateLocked(eventTime, event, flags, uid)) &#123;</span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>userActivityInternal中首先调用userActivityNoUpdateLocked更新相关数据及状态(***NoUpdateLocked仅仅更新内部状态并不采取任何操作)，然后调用updatePowerStateLocked更新所有PowerState，下面分析userActivityNoUpdateLocked的实现，updatePowerStateLocked是PowerManagerService的核心方法，在最后进行分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">private boolean userActivityNoUpdateLocked(long eventTime, int event, int flags, int uid) &#123;</span><br><span class="line">    // 如果发生时间是上一次休眠或唤醒前，或当前没有开机完成到systemReady，不采取操作直接返回</span><br><span class="line">    if (eventTime &lt; mLastSleepTime || eventTime &lt; mLastWakeTime</span><br><span class="line">            || !mBootCompleted || !mSystemReady) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 更新mLastInteractivePowerHintTime时间</span><br><span class="line">        if (eventTime &gt; mLastInteractivePowerHintTime) &#123;</span><br><span class="line">            powerHintInternal(POWER_HINT_INTERACTION, 0);</span><br><span class="line">            mLastInteractivePowerHintTime = eventTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 通过mNotifier通知BatteryStats UserActivity事件</span><br><span class="line">        mNotifier.onUserActivity(event, uid);</span><br><span class="line"></span><br><span class="line">        if (mUserInactiveOverrideFromWindowManager) &#123;</span><br><span class="line">            mUserInactiveOverrideFromWindowManager = false;</span><br><span class="line">            mOverriddenTimeout = -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果系统处于休眠状态，不进行处理</span><br><span class="line">        if (mWakefulness == WAKEFULNESS_ASLEEP</span><br><span class="line">                || mWakefulness == WAKEFULNESS_DOZING</span><br><span class="line">                || (flags &amp; PowerManager.USER_ACTIVITY_FLAG_INDIRECT) != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 根据flag是否在已变暗的情况下是否重启活动超时更新mLastUserActivityTimeNoChangeLights或mLastUserActivityTime</span><br><span class="line">        // 并且设置mDirty DIRTY_USER_ACTIVITY</span><br><span class="line">        if ((flags &amp; PowerManager.USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS) != 0) &#123;</span><br><span class="line">            if (eventTime &gt; mLastUserActivityTimeNoChangeLights</span><br><span class="line">                    &amp;&amp; eventTime &gt; mLastUserActivityTime) &#123;</span><br><span class="line">                mLastUserActivityTimeNoChangeLights = eventTime;</span><br><span class="line">                mDirty |= DIRTY_USER_ACTIVITY;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (eventTime &gt; mLastUserActivityTime) &#123;</span><br><span class="line">                mLastUserActivityTime = eventTime;</span><br><span class="line">                mDirty |= DIRTY_USER_ACTIVITY;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_POWER);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="gotoSleep"><a href="#gotoSleep" class="headerlink" title="gotoSleep"></a>gotoSleep</h1><p>gotoSleep在PowerManager中的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/os/PowerManager.java</span><br><span class="line"></span><br><span class="line">public void goToSleep(long time) &#123;</span><br><span class="line">    goToSleep(time, GO_TO_SLEEP_REASON_APPLICATION, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void goToSleep(long time, int reason, int flags) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mService.goToSleep(time, reason, flags);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与userActivity一样，gotoSleep最终将调用到goToSleepInternal。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">private final class BinderService extends IPowerManager.Stub &#123;</span><br><span class="line">  ......</span><br><span class="line">  public void goToSleep(long eventTime, int reason, int flags) &#123;</span><br><span class="line">      if (eventTime &gt; SystemClock.uptimeMillis()) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;event time must not be in the future&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mContext.enforceCallingOrSelfPermission(</span><br><span class="line">              android.Manifest.permission.DEVICE_POWER, null);</span><br><span class="line"></span><br><span class="line">      final int uid = Binder.getCallingUid();</span><br><span class="line">      final long ident = Binder.clearCallingIdentity();</span><br><span class="line">      try &#123;</span><br><span class="line">          goToSleepInternal(eventTime, reason, flags, uid);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          Binder.restoreCallingIdentity(ident);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void goToSleepInternal(long eventTime, int reason, int flags, int uid) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (goToSleepNoUpdateLocked(eventTime, reason, flags, uid)) &#123;</span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>goToSleepInternal中将执行goToSleepNoUpdateLocked更新内部状态，同样在updatePowerStateLocked中更新PowerState的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line"></span><br><span class="line">private boolean goToSleepNoUpdateLocked(long eventTime, int reason, int flags, int uid) &#123;</span><br><span class="line">    // 当不处于awake状态或未开机systemReady，不处理</span><br><span class="line">    if (eventTime &lt; mLastWakeTime</span><br><span class="line">            || mWakefulness == WAKEFULNESS_ASLEEP</span><br><span class="line">            || mWakefulness == WAKEFULNESS_DOZING</span><br><span class="line">            || !mBootCompleted || !mSystemReady) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ......</span><br><span class="line">        // 更新mLastSleepTime时间，设置DIRTY_WAKEFULNESS标志位</span><br><span class="line">        mLastSleepTime = eventTime;</span><br><span class="line">        mSandmanSummoned = true;</span><br><span class="line">        setWakefulnessLocked(WAKEFULNESS_DOZING, reason);</span><br><span class="line"></span><br><span class="line">        // Report the number of wake locks that will be cleared by going to sleep.</span><br><span class="line">        int numWakeLocksCleared = 0;</span><br><span class="line">        final int numWakeLocks = mWakeLocks.size();</span><br><span class="line">        for (int i = 0; i &lt; numWakeLocks; i++) &#123;</span><br><span class="line">            final WakeLock wakeLock = mWakeLocks.get(i);</span><br><span class="line">            switch (wakeLock.mFlags &amp; PowerManager.WAKE_LOCK_LEVEL_MASK) &#123;</span><br><span class="line">                case PowerManager.FULL_WAKE_LOCK:</span><br><span class="line">                case PowerManager.SCREEN_BRIGHT_WAKE_LOCK:</span><br><span class="line">                case PowerManager.SCREEN_DIM_WAKE_LOCK:</span><br><span class="line">                    numWakeLocksCleared += 1;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Skip dozing if requested.</span><br><span class="line">        if ((flags &amp; PowerManager.GO_TO_SLEEP_FLAG_NO_DOZE) != 0) &#123;</span><br><span class="line">            reallyGoToSleepNoUpdateLocked(eventTime, uid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_POWER);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>goToSleepNoUpdateLocked中更新mLastSleepTime，mWakefulness，mDirty状态。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之Wakelock]]></title>
      <url>http://robinheztto.com/2017/06/01/android-power-wakelock/</url>
      <content type="html"><![CDATA[<blockquote>
<p>wakelocks最初来源于Android在linux kernel上的一个补丁集，旨在允许用户空间的应用能够通过持有Wakelock来阻止系统进入低功耗模式。</p>
<p>相关代码在以下文件中：<br>kernel/msm-4.4/kernel/power/wakelock.c<br>kernel/msm-4.4/kernel/power/main.c</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>早期，为了适用移动设备的使用特性，Google在Linux的基础上为Android设计了一套新的电源管理机制 wakelocks，early_suspend。但由于此机制定义了Android自己的休眠接口，修改了Linux原生的susupend流程，导致在合入此patch的问题上Android和Linux内核开发者有<a href="http://lwn.net/Articles/318611/" target="_blank" rel="external">争论</a>。<br>直到kernel推出wakeup events framework，Android在wakeup events framework上重新修改了电源管理机制，弃用了之前的early_suspend机制，底层基于wakeup source重新实现了wakelocks(Android上层的Wakelock保留了原来的使用方式)，其实就是将kernel中的wakeup source开放到用户空间。</p>
<p>新旧wakelock的对比如下(用户空间的使用方式一致，内核空间实现机制不同)：</p>
<table>
<thead>
<tr>
<th></th>
<th>uesr space</th>
<th>kernel space</th>
</tr>
</thead>
<tbody>
<tr>
<td>old wakelock</td>
<td>写/sys/power/wake_lock阻止系统进入suspend，写/sys/power/wake_unlock允许suspend</td>
<td>lock在suspend的流程中加锁，阻止suspend，unlock移除该锁。</td>
</tr>
<tr>
<td>new wakelock</td>
<td>写/sys/power/wake_lock阻止系统进入suspend，写/sys/power/wake_unlock允许suspend</td>
<td>基于wakeup event framework的wakeup source实现，lock即active一个wakeup event，unlock　deactive一个wakeup event。</td>
</tr>
</tbody>
</table>
<h1 id="Android-Wakelock"><a href="#Android-Wakelock" class="headerlink" title="Android Wakelock"></a>Android Wakelock</h1><p>在Android App中唤醒锁的使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">权限申明：</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.DEVICE_POWER&quot;/&gt;</span><br><span class="line"></span><br><span class="line">代码使用：</span><br><span class="line">PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);</span><br><span class="line">PowerManager.WakeLock wl =  powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;My Tag&quot;);</span><br><span class="line">wl.acquire();　//acquire时尽量申明timeout时间</span><br><span class="line">//......</span><br><span class="line">wl.release();</span><br></pre></td></tr></table></figure></p>
<p>在应用程序中使用WakeLock时必须申明权限，acquire请求唤醒锁时尽量设置timeout时间释放WakeLock，以避免长时间持有WakeLock导致系统无法休眠。</p>
<p>唤醒锁的类型：</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>CPU</th>
<th>Screen</th>
<th>Keyboard</th>
</tr>
</thead>
<tbody>
<tr>
<td>PARTIAL_WAKE_LOCK</td>
<td>on</td>
<td>off</td>
<td>off</td>
</tr>
<tr>
<td>SCREEN_DIM_WAKE_LOCK</td>
<td>on</td>
<td>Dim</td>
<td>off</td>
</tr>
<tr>
<td>SCREEN_BRIGHT_WAKE_LOCK</td>
<td>on</td>
<td>Bright</td>
<td>off</td>
</tr>
<tr>
<td>FULL_WAKE_LOCK</td>
<td>on</td>
<td>Bright</td>
<td>on</td>
</tr>
</tbody>
</table>
<p>如果是PARTIAL_WAKE_LOCK,无论屏幕的状态或是按下电源键, CPU都将正常工作。如果是其它的唤醒锁,设备会在用户按下电源钮后停止工作进入休眠状态。以上四种锁，除了PARTIAL_WAKE_LOCK，其余的锁在API level 17已经被deprecated了。</p>
<h1 id="Kernel-Wakelock"><a href="#Kernel-Wakelock" class="headerlink" title="Kernel Wakelock"></a>Kernel Wakelock</h1><p>如下图(来自<a href="http://www.wowotech.net" target="_blank" rel="external">蜗窝科技</a>)所示，PM core通过main模块向用户空间提供操作接口，即向用户空间暴露/sys/power/wake_lock与/sys/power/wake_unlock两个sysfs文件，PM core中的wakelock模块依赖于wakeup events framework提供的wakeup source机制实现，同时对用户空间的wakeup source(wakelock)提供支持。</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/android-power-wakelocks.jpeg?raw=true" alt="wakelocks"><br></div>

<p>下面首先来看Kernenl中的wakelock实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/wakelock.c</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * kernel/power/wakelock.c</span><br><span class="line"> *</span><br><span class="line"> * User space wakeup sources support.</span><br><span class="line"> *</span><br><span class="line"> * Copyright (C) 2012 Rafael J. Wysocki &lt;rjw@sisk.pl&gt;</span><br><span class="line"> *</span><br><span class="line"> * This code is based on the analogous interface allowing user space to</span><br><span class="line"> * manipulate wakelocks on Android.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct wakelock &#123;</span><br><span class="line">	char			*name; // 该wakelock对应的name</span><br><span class="line">	struct rb_node		node; // 红黑树节点，用于存储该wakelock</span><br><span class="line">	struct wakeup_source	ws; // 该wakelock对应的wakeup source</span><br><span class="line">#ifdef CONFIG_PM_WAKELOCKS_GC</span><br><span class="line">	struct list_head	lru; // 用于wakelock的回收机制</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过注释信息可以知道，Kernenl中的wakelock是对用户空间wakelock支持的实现，以允许在用户空间操作wakeup source，创建Kerne wakelock的即在指定的wakeup source上activate一个wakeup event，注销wakelock的本质是deactivate wakeup event，下面从读写/sys/power/wake_lock和/sys/power/wake_unlock两个sysfs文件来详细分析该流程。</p>
<h2 id="读写wake-lock"><a href="#读写wake-lock" class="headerlink" title="读写wake_lock"></a>读写wake_lock</h2><p>/sys/power/wake_lock的读写方法定义如下，/sys/power/wake_lock的写方法直接调用pm_wake_lock()，读方法直接调用pm_show_wakelocks()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/main.c</span><br><span class="line"></span><br><span class="line">static ssize_t wake_lock_show(struct kobject *kobj,</span><br><span class="line">			      struct kobj_attribute *attr,</span><br><span class="line">			      char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	return pm_show_wakelocks(buf, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t wake_lock_store(struct kobject *kobj,</span><br><span class="line">			       struct kobj_attribute *attr,</span><br><span class="line">			       const char *buf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	int error = pm_wake_lock(buf);</span><br><span class="line">	return error ? error : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">power_attr(wake_lock);</span><br></pre></td></tr></table></figure></p>
<p>pm_wake_lock()与pm_show_wakelocks()都在wakelock.c中定义，先看pm_wake_lock()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/wakelock.c</span><br><span class="line"></span><br><span class="line">int pm_wake_lock(const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	const char *str = buf;</span><br><span class="line">	struct wakelock *wl;</span><br><span class="line">	u64 timeout_ns = 0;</span><br><span class="line">	size_t len;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	// 检查当前进程是否具备阻止系统suspend的权限</span><br><span class="line">	if (!capable(CAP_BLOCK_SUSPEND))</span><br><span class="line">		return -EPERM;</span><br><span class="line">	// 解析字符串，timeout_ns保存timeout值</span><br><span class="line">	while (*str &amp;&amp; !isspace(*str))</span><br><span class="line">		str++;</span><br><span class="line"></span><br><span class="line">	len = str - buf;</span><br><span class="line">	if (!len)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (*str &amp;&amp; *str != &apos;\n&apos;) &#123;</span><br><span class="line">		/* Find out if there&apos;s a valid timeout string appended. */</span><br><span class="line">		ret = kstrtou64(skip_spaces(str), 10, &amp;timeout_ns);</span><br><span class="line">		if (ret)</span><br><span class="line">			return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wakelocks_lock);</span><br><span class="line">	// 从RB tree中查找buf名字对应的wakelock，如果找到则返回，没找到则新建wakelock对象并返回</span><br><span class="line">	wl = wakelock_lookup_add(buf, len, true);</span><br><span class="line">	if (IS_ERR(wl)) &#123;</span><br><span class="line">		ret = PTR_ERR(wl);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果指定timeout值，以wakelock的wakeup source指针为参数，调用__pm_wakeup_event接口，上报一个具有时限的wakeup events；</span><br><span class="line">	// 如果没有指定timeout值，调用__pm_stay_awake，上报一个没有时限的wakeup event。</span><br><span class="line">	if (timeout_ns) &#123;</span><br><span class="line">		u64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;</span><br><span class="line">		do_div(timeout_ms, NSEC_PER_MSEC);</span><br><span class="line">		__pm_wakeup_event(&amp;wl-&gt;ws, timeout_ms);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		__pm_stay_awake(&amp;wl-&gt;ws);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wakelocks_lru_most_recent(wl);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;wakelocks_lock);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续看内部接口wakelock_lookup_add的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/wakelock.c</span><br><span class="line"></span><br><span class="line">static struct wakelock *wakelock_lookup_add(const char *name, size_t len,</span><br><span class="line">					    bool add_if_not_found)</span><br><span class="line">&#123;</span><br><span class="line">	struct rb_node **node = &amp;wakelocks_tree.rb_node;</span><br><span class="line">	struct rb_node *parent = *node;</span><br><span class="line">	struct wakelock *wl;</span><br><span class="line"></span><br><span class="line">	// 根据name查找红黑树上对应的wakelock</span><br><span class="line">	while (*node) &#123;</span><br><span class="line">		int diff;</span><br><span class="line"></span><br><span class="line">		parent = *node;</span><br><span class="line">		wl = rb_entry(*node, struct wakelock, node);</span><br><span class="line">		diff = strncmp(name, wl-&gt;name, len);</span><br><span class="line">		if (diff == 0) &#123;</span><br><span class="line">			if (wl-&gt;name[len])</span><br><span class="line">				diff = -1;</span><br><span class="line">			else</span><br><span class="line">				return wl;</span><br><span class="line">		&#125;</span><br><span class="line">		if (diff &lt; 0)</span><br><span class="line">			node = &amp;(*node)-&gt;rb_left;</span><br><span class="line">		else</span><br><span class="line">			node = &amp;(*node)-&gt;rb_right;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!add_if_not_found)</span><br><span class="line">		return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	if (wakelocks_limit_exceeded())</span><br><span class="line">		return ERR_PTR(-ENOSPC);</span><br><span class="line"></span><br><span class="line">	// 没有找到，创建新的wakelock</span><br><span class="line">	wl = kzalloc(sizeof(*wl), GFP_KERNEL);</span><br><span class="line">	if (!wl)</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	wl-&gt;name = kstrndup(name, len, GFP_KERNEL);</span><br><span class="line">	if (!wl-&gt;name) &#123;</span><br><span class="line">		kfree(wl);</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line">	wl-&gt;ws.name = wl-&gt;name;</span><br><span class="line">	// 将wakeup source添加到wakeup events framework中</span><br><span class="line">	wakeup_source_add(&amp;wl-&gt;ws);</span><br><span class="line">	// 将该wakelock添加到红黑树</span><br><span class="line">	rb_link_node(&amp;wl-&gt;node, parent, node);</span><br><span class="line">	rb_insert_color(&amp;wl-&gt;node, &amp;wakelocks_tree);</span><br><span class="line">  // 将新分配的wakeup添加到一个名称为wakelocks_lru_list的链表前端</span><br><span class="line">	wakelocks_lru_add(wl);</span><br><span class="line">	increment_wakelocks_number();</span><br><span class="line">	return wl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面继续看读wake_lock的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/wakelock.c</span><br><span class="line"></span><br><span class="line">ssize_t pm_show_wakelocks(char *buf, bool show_active)</span><br><span class="line">&#123;</span><br><span class="line">	struct rb_node *node;</span><br><span class="line">	struct wakelock *wl;</span><br><span class="line">	char *str = buf;</span><br><span class="line">	char *end = buf + PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wakelocks_lock);</span><br><span class="line">	// 遍历红黑树，拿到wakelock指针，将该wakelock的名字添加在buf</span><br><span class="line">	for (node = rb_first(&amp;wakelocks_tree); node; node = rb_next(node)) &#123;</span><br><span class="line">		wl = rb_entry(node, struct wakelock, node);</span><br><span class="line">		// 判断其中的wakeup source的active变量与show_active是否相符</span><br><span class="line">		if (wl-&gt;ws.active == show_active)</span><br><span class="line">			str += scnprintf(str, end - str, &quot;%s &quot;, wl-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	if (str &gt; buf)</span><br><span class="line">		str--;</span><br><span class="line"></span><br><span class="line">	str += scnprintf(str, end - str, &quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wakelocks_lock);</span><br><span class="line">	return (str - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="读写wake-unlock"><a href="#读写wake-unlock" class="headerlink" title="读写wake_unlock"></a>读写wake_unlock</h2><p>/sys/power/wake_unlock的读写方法定义如下，/sys/power/wake_unlock的写方法直接调用pm_wake_unlock()，读方法直接调用pm_show_wakelocks()，pm_show_wakelocks在上面已经分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/main.c</span><br><span class="line"></span><br><span class="line">static ssize_t wake_unlock_show(struct kobject *kobj,</span><br><span class="line">				struct kobj_attribute *attr,</span><br><span class="line">				char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	return pm_show_wakelocks(buf, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t wake_unlock_store(struct kobject *kobj,</span><br><span class="line">				 struct kobj_attribute *attr,</span><br><span class="line">				 const char *buf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	int error = pm_wake_unlock(buf);</span><br><span class="line">	return error ? error : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">power_attr(wake_unlock);</span><br></pre></td></tr></table></figure></p>
<p>pm_wake_unlock()在wakelock.c中定义，下面看他的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/wakelock.c</span><br><span class="line"></span><br><span class="line">int pm_wake_unlock(const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	struct wakelock *wl;</span><br><span class="line">	size_t len;</span><br><span class="line">	int ret = 0;</span><br><span class="line"></span><br><span class="line">	// 检查当前进程是否具备阻止系统suspend的权限</span><br><span class="line">	if (!capable(CAP_BLOCK_SUSPEND))</span><br><span class="line">		return -EPERM;</span><br><span class="line"></span><br><span class="line">	// 解析字符串</span><br><span class="line">	len = strlen(buf);</span><br><span class="line">	if (!len)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (buf[len-1] == &apos;\n&apos;)</span><br><span class="line">		len--;</span><br><span class="line"></span><br><span class="line">	if (!len)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;wakelocks_lock);</span><br><span class="line">	//　根据name在RB树中查找是wakelock，没有则退出</span><br><span class="line">	wl = wakelock_lookup_add(buf, len, false);</span><br><span class="line">	if (IS_ERR(wl)) &#123;</span><br><span class="line">		ret = PTR_ERR(wl);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	// 调用__pm_relax接口，deactive wakelock对应的wakeup source。</span><br><span class="line">	__pm_relax(&amp;wl-&gt;ws);</span><br><span class="line">	// 调用wakelocks_lru_most_recent接口，将盖wakelock移到wakelocks_lru_list链表的前端，并执行垃圾回收操作</span><br><span class="line">	wakelocks_lru_most_recent(wl);</span><br><span class="line">	wakelocks_gc();</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	mutex_unlock(&amp;wakelocks_lock);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之libsuspend]]></title>
      <url>http://robinheztto.com/2017/05/20/android-power-libsuspend/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android向上层提供了操作休眠相关的接口(即读写/sys/power/目录下文件)，即libsuspend.so，<br>源码位于system/core/libsuspend下：<br>system/core/libsuspend<br>kernel/msm-4.4/kernel/power/suspend.c<br>kernel/msm-4.4/kernel/power/process.c<br>kernel/msm-4.4/kernel/power/console.c<br>kernel/msm-4.4/kernel/power/power.h<br>kernel/msm-4.4/include/linux/suspend.h<br>kernel-x.xx/drivers/misc/mediatek/base/power/spm_v2/mt_sleep.c</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之Suspend]]></title>
      <url>http://robinheztto.com/2017/05/05/android-power-suspend/</url>
      <content type="html"><![CDATA[<blockquote>
<p>kernel/msm-4.4/kernel/power/main.c<br>kernel/msm-4.4/kernel/power/suspend.c<br>kernel/msm-4.4/kernel/power/process.c<br>kernel/msm-4.4/kernel/power/console.c<br>kernel/msm-4.4/kernel/power/power.h<br>kernel/msm-4.4/include/linux/suspend.h<br>kernel-x.xx/drivers/misc/mediatek/base/power/spm_v2/mt_sleep.c</p>
</blockquote>
<p>Linux kernel提供Freeze，Standby，STR(Supend to RAM)三种Suspend机制，当用户空间向”/sys/power/state”文件分别写”freeze”，”standby”，”mem”时即触发对应的suspend流程。关于PM_SUSPEND的定义如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/include/linux/suspend.h</span><br><span class="line"></span><br><span class="line">#define PM_SUSPEND_ON		((__force suspend_state_t) 0)</span><br><span class="line">#define PM_SUSPEND_FREEZE	((__force suspend_state_t) 1)</span><br><span class="line">#define PM_SUSPEND_STANDBY	((__force suspend_state_t) 2)</span><br><span class="line">#define PM_SUSPEND_MEM		((__force suspend_state_t) 3)</span><br><span class="line">#define PM_SUSPEND_MIN		PM_SUSPEND_FREEZE</span><br><span class="line">#define PM_SUSPEND_MAX		((__force suspend_state_t) 4)</span><br></pre></td></tr></table></figure></p>
<p>下面先从/sys/power/下属性文件的创建开始分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/main.c</span><br><span class="line"></span><br><span class="line">static int __init pm_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int error = pm_start_workqueue();</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line">	hibernate_image_size_init();</span><br><span class="line">	hibernate_reserved_size_init();</span><br><span class="line">	power_kobj = kobject_create_and_add(&quot;power&quot;, NULL);</span><br><span class="line">	if (!power_kobj)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	error = sysfs_create_group(power_kobj, &amp;attr_group);</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line">	pm_print_times_init();</span><br><span class="line">	return pm_autosleep_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core_initcall(pm_init);</span><br></pre></td></tr></table></figure></p>
<p>pm_init中创建了/sys/power目录，并且根据attr_group的定义创建对应的属性文件，attr_group的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/main.c</span><br><span class="line"></span><br><span class="line">static struct attribute * g[] = &#123;</span><br><span class="line">	&amp;state_attr.attr,</span><br><span class="line">#ifdef CONFIG_PM_TRACE</span><br><span class="line">	&amp;pm_trace_attr.attr,</span><br><span class="line">	&amp;pm_trace_dev_match_attr.attr,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PM_SLEEP</span><br><span class="line">	&amp;pm_async_attr.attr,</span><br><span class="line">	&amp;wakeup_count_attr.attr,</span><br><span class="line">#ifdef CONFIG_PM_AUTOSLEEP</span><br><span class="line">	&amp;autosleep_attr.attr,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PM_WAKELOCKS</span><br><span class="line">	&amp;wake_lock_attr.attr,</span><br><span class="line">	&amp;wake_unlock_attr.attr,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PM_DEBUG</span><br><span class="line">	&amp;pm_test_attr.attr,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PM_SLEEP_DEBUG</span><br><span class="line">	&amp;pm_print_times_attr.attr,</span><br><span class="line">	&amp;pm_wakeup_irq_attr.attr,</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FREEZER</span><br><span class="line">	&amp;pm_freeze_timeout_attr.attr,</span><br><span class="line">#endif</span><br><span class="line">	NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct attribute_group attr_group = &#123;</span><br><span class="line">	.attrs = g,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>attribute_group中定义了state_attr，pm_async_attr，wakeup_count_attr，wake_lock_attr，wake_unlock_attr等attribute，对应生成/sys/power/state，/sys/power/pm_async，/sys/power/wakeup_count，/sys/power/wake_lock，/sys/power/wake_unlock等属性文件。state_attr等attribute的show，sotre通过宏power_attr来定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/power.h</span><br><span class="line"></span><br><span class="line">#define power_attr(_name) \</span><br><span class="line">static struct kobj_attribute _name##_attr = &#123;	\</span><br><span class="line">	.attr	= &#123;				\</span><br><span class="line">		.name = __stringify(_name),	\</span><br><span class="line">		.mode = 0644,			\</span><br><span class="line">	&#125;,					\</span><br><span class="line">	.show	= _name##_show,			\</span><br><span class="line">	.store	= _name##_store,		\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/main.c</span><br><span class="line"></span><br><span class="line">power_attr(pm_async);</span><br><span class="line">power_attr(state);</span><br><span class="line">power_attr(wake_unlock);</span><br><span class="line">power_attr(wake_lock);</span><br><span class="line">power_attr(wakeup_count);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>下面首先看/sys/power/state的读取方法state_show的实现，即显平台所支持的Suspend机制(通过<code>cat /sys/power/state</code>可查询)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/main.c</span><br><span class="line"></span><br><span class="line">const char *pm_states[PM_SUSPEND_MAX];</span><br><span class="line"></span><br><span class="line">static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,</span><br><span class="line">			  char *buf)</span><br><span class="line">&#123;</span><br><span class="line">	char *s = buf;</span><br><span class="line">#ifdef CONFIG_SUSPEND</span><br><span class="line">	suspend_state_t i;</span><br><span class="line"></span><br><span class="line">	for (i = PM_SUSPEND_MIN; i &lt; PM_SUSPEND_MAX; i++)</span><br><span class="line">		if (pm_states[i])</span><br><span class="line">			s += sprintf(s,&quot;%s &quot;, pm_states[i]);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">	if (hibernation_available())</span><br><span class="line">		s += sprintf(s, &quot;disk &quot;);</span><br><span class="line">	if (s != buf)</span><br><span class="line">		/* convert the last space to a newline */</span><br><span class="line">		*(s-1) = &apos;\n&apos;;</span><br><span class="line">	return (s - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>state_show实际上显示的是pm_states中的值，pm_states时在suspend_set_ops中初始化赋值的，后面再详细描述。继续看state_store即suspend的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/main.c</span><br><span class="line"></span><br><span class="line">static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,</span><br><span class="line">			   const char *buf, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	suspend_state_t state;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	error = pm_autosleep_lock();</span><br><span class="line">	if (error)</span><br><span class="line">		return error;</span><br><span class="line"></span><br><span class="line">	if (pm_autosleep_state() &gt; PM_SUSPEND_ON) &#123;</span><br><span class="line">		error = -EBUSY;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	state = decode_state(buf, n);</span><br><span class="line">	if (state &lt; PM_SUSPEND_MAX)</span><br><span class="line">		error = pm_suspend(state);</span><br><span class="line">	else if (state == PM_SUSPEND_MAX)</span><br><span class="line">		error = hibernate();</span><br><span class="line">	else</span><br><span class="line">		error = -EINVAL;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">	pm_autosleep_unlock();</span><br><span class="line">	return error ? error : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">power_attr(state);</span><br></pre></td></tr></table></figure></p>
<p>state_store中首先解析从用户空间传入的buffer(freeze、standby or mem)，转换成state参数，然后调用pm_suspend()继续处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/suspend.c</span><br><span class="line"></span><br><span class="line">int pm_suspend(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	if (state &lt;= PM_SUSPEND_ON || state &gt;= PM_SUSPEND_MAX)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	pm_suspend_marker(&quot;entry&quot;);</span><br><span class="line">	error = enter_state(state);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		suspend_stats.fail++;</span><br><span class="line">		dpm_save_failed_errno(error);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		suspend_stats.success++;</span><br><span class="line">	&#125;</span><br><span class="line">	pm_suspend_marker(&quot;exit&quot;);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pm_suspend中首先对参数state进行判断是否合法，然后继续调用enter_state。由pm_suspend_marker可以看到，”entry”与”exit”都是在pm_suspend中，enter_state函数进入休眠直到唤醒时才返回。另外debug时，可根据pm_suspend_marker确定进入与退出suspend的时间，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/suspend.c</span><br><span class="line"></span><br><span class="line">static void pm_suspend_marker(char *annotation)</span><br><span class="line">&#123;</span><br><span class="line">	struct timespec ts;</span><br><span class="line">	struct rtc_time tm;</span><br><span class="line"></span><br><span class="line">	getnstimeofday(&amp;ts);</span><br><span class="line">	rtc_time_to_tm(ts.tv_sec, &amp;tm);</span><br><span class="line">	pr_info(&quot;PM: suspend %s %d-%02d-%02d %02d:%02d:%02d.%09lu UTC\n&quot;,</span><br><span class="line">		annotation, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,</span><br><span class="line">		tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续看enter_state的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/suspend.c</span><br><span class="line"></span><br><span class="line">static int enter_state(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	trace_suspend_resume(TPS(&quot;suspend_enter&quot;), state, true);</span><br><span class="line">	if (state == PM_SUSPEND_FREEZE) &#123;</span><br><span class="line">#ifdef CONFIG_PM_DEBUG</span><br><span class="line">		if (pm_test_level != TEST_NONE &amp;&amp; pm_test_level &lt;= TEST_CPUS) &#123;</span><br><span class="line">			pr_warning(&quot;PM: Unsupported test mode for suspend to idle,&quot;</span><br><span class="line">				   &quot;please choose none/freezer/devices/platform.\n&quot;);</span><br><span class="line">			return -EAGAIN;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">	// 判断是否支持请求的状态state</span><br><span class="line">	&#125; else if (!valid_state(state)) &#123;</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	// 互斥锁，只允许同时处理一个suspend流程</span><br><span class="line">	if (!mutex_trylock(&amp;pm_mutex))</span><br><span class="line">		return -EBUSY;</span><br><span class="line">	// 请求进入freeze，调用freeze_begin流程</span><br><span class="line">	if (state == PM_SUSPEND_FREEZE)</span><br><span class="line">		freeze_begin();</span><br><span class="line"></span><br><span class="line">	// state为standby或mem则进入一下流程处理，首先sync文件系统</span><br><span class="line">#ifndef CONFIG_SUSPEND_SKIP_SYNC</span><br><span class="line">	trace_suspend_resume(TPS(&quot;sync_filesystems&quot;), 0, true);</span><br><span class="line">	printk(KERN_INFO &quot;PM: Syncing filesystems ... &quot;);</span><br><span class="line">	sys_sync();</span><br><span class="line">	printk(&quot;done.\n&quot;);</span><br><span class="line">	trace_suspend_resume(TPS(&quot;sync_filesystems&quot;), 0, false);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	pr_debug(&quot;PM: Preparing system for sleep (%s)\n&quot;, pm_states[state]);</span><br><span class="line">	pm_suspend_clear_flags();</span><br><span class="line">	// 调用suspend_prepare进行suspend前的准备工作</span><br><span class="line">	error = suspend_prepare(state);</span><br><span class="line">	if (error)</span><br><span class="line">		goto Unlock;</span><br><span class="line"></span><br><span class="line">	if (suspend_test(TEST_FREEZER))</span><br><span class="line">		goto Finish;</span><br><span class="line"></span><br><span class="line">	trace_suspend_resume(TPS(&quot;suspend_enter&quot;), state, false);</span><br><span class="line">	pr_debug(&quot;PM: Suspending system (%s)\n&quot;, pm_states[state]);</span><br><span class="line">	pm_restrict_gfp_mask();</span><br><span class="line">	// 进入suspend流程</span><br><span class="line">	error = suspend_devices_and_enter(state);</span><br><span class="line">	pm_restore_gfp_mask();</span><br><span class="line"></span><br><span class="line"> Finish:</span><br><span class="line">	pr_debug(&quot;PM: Finishing wakeup.\n&quot;);</span><br><span class="line">	// 退出suspend,恢复suspend前的状态</span><br><span class="line">	suspend_finish();</span><br><span class="line"> Unlock:</span><br><span class="line">	mutex_unlock(&amp;pm_mutex);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>enter_state中根据state判断，如果是freeze，则进入freeze_begin()处理，如果是standby或mem，则首先同步文件系统，然后调用suspend_prepare进行suspend前的准备工作，最后在suspend_devices_and_enter中进入suspend，当系统唤醒时，在suspend_finish中进行恢复操作。下面详细分析该流程，首先看valid_state的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/include/linux/suspend.h</span><br><span class="line"></span><br><span class="line">struct platform_suspend_ops &#123;</span><br><span class="line">	int (*valid)(suspend_state_t state);</span><br><span class="line">	int (*begin)(suspend_state_t state);</span><br><span class="line">	int (*prepare)(void);</span><br><span class="line">	int (*prepare_late)(void);</span><br><span class="line">	int (*enter)(suspend_state_t state);</span><br><span class="line">	void (*wake)(void);</span><br><span class="line">	void (*finish)(void);</span><br><span class="line">	bool (*suspend_again)(void);</span><br><span class="line">	void (*end)(void);</span><br><span class="line">	void (*recover)(void);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/suspend.c</span><br><span class="line"></span><br><span class="line">static const struct platform_suspend_ops *suspend_ops;</span><br><span class="line"></span><br><span class="line">static bool valid_state(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * PM_SUSPEND_STANDBY and PM_SUSPEND_MEM states need low level</span><br><span class="line">	 * support and need to be valid to the low level</span><br><span class="line">	 * implementation, no valid callback implies that none are valid.</span><br><span class="line">	 */</span><br><span class="line">	return suspend_ops &amp;&amp; suspend_ops-&gt;valid &amp;&amp; suspend_ops-&gt;valid(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>valid_state中调用的是suspend_ops-&gt;valid，(注释可以看到PM_SUSPEND_STANDBY和PM_SUSPEND_MEM是需要底层支持)，即在平台代码中实现。下面以MTK平台为例，看platform_suspend_ops的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel-x.xx/drivers/misc/mediatek/base/power/spm_v2/mt_sleep.c</span><br><span class="line"></span><br><span class="line">static int slp_suspend_ops_valid(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	return state == PM_SUSPEND_MEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int slp_suspend_ops_begin(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	/* legacy log */</span><br><span class="line">	slp_notice(&quot;@@@@@@@@@@@@@@@@@@@@\tChip_pm_begin(%u)(%u)\t@@@@@@@@@@@@@@@@@@@@\n&quot;,</span><br><span class="line">			is_cpu_pdn(slp_spm_flags), is_infra_pdn(slp_spm_flags));</span><br><span class="line"></span><br><span class="line">	slp_wake_reason = WR_NONE;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __attribute__((weak)) mt_power_gs_dump_suspend(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int slp_suspend_ops_prepare(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* legacy log */</span><br><span class="line">	slp_crit2(&quot;@@@@@@@@@@@@@@@@@@@@\tChip_pm_prepare\t@@@@@@@@@@@@@@@@@@@@\n&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_MTKPASR</span><br><span class="line">/* PASR/DPD Preliminary operations */</span><br><span class="line">static int slp_suspend_ops_prepare_late(void)</span><br><span class="line">&#123;</span><br><span class="line">	slp_notice(&quot;[%s]\n&quot;, __func__);</span><br><span class="line">	mtkpasr_phaseone_ops();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void slp_suspend_ops_wake(void)</span><br><span class="line">&#123;</span><br><span class="line">	slp_notice(&quot;[%s]\n&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int slp_suspend_ops_enter(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void slp_suspend_ops_finish(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* legacy log */</span><br><span class="line">	slp_crit2(&quot;@@@@@@@@@@@@@@@@@@@@\tChip_pm_finish\t@@@@@@@@@@@@@@@@@@@@\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void slp_suspend_ops_end(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* legacy log */</span><br><span class="line">	slp_notice(&quot;@@@@@@@@@@@@@@@@@@@@\tChip_pm_end\t@@@@@@@@@@@@@@@@@@@@\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct platform_suspend_ops slp_suspend_ops = &#123;</span><br><span class="line">	.valid = slp_suspend_ops_valid,</span><br><span class="line">	.begin = slp_suspend_ops_begin,</span><br><span class="line">	.prepare = slp_suspend_ops_prepare,</span><br><span class="line">	.enter = slp_suspend_ops_enter,</span><br><span class="line">	.finish = slp_suspend_ops_finish,</span><br><span class="line">	.end = slp_suspend_ops_end,</span><br><span class="line">#ifdef CONFIG_MTKPASR</span><br><span class="line">	.prepare_late = slp_suspend_ops_prepare_late,</span><br><span class="line">	.wake = slp_suspend_ops_wake,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>mt_sleep.c中定义了platform_suspend_ops的实现，这里的slp_suspend_ops_valid支持的是PM_SUSPEND_MEM。接下来继续回到enter_state函数中分析suspend_prepare的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/suspend.c</span><br><span class="line"></span><br><span class="line">static int suspend_prepare(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	// 检查是否支持该state，PM_SUSPEND_FREEZE或者有实现suspend_ops-&gt;enter</span><br><span class="line">	if (!sleep_state_supported(state))</span><br><span class="line">		return -EPERM;</span><br><span class="line"></span><br><span class="line">	// 将当前console切换到一个虚拟console并重定向内核的kmsg  </span><br><span class="line">	pm_prepare_console();</span><br><span class="line"></span><br><span class="line">  // 发送PM_SUSPEND_PREPARE消息  </span><br><span class="line">	error = pm_notifier_call_chain(PM_SUSPEND_PREPARE);</span><br><span class="line">	if (error)</span><br><span class="line">		goto Finish;</span><br><span class="line"></span><br><span class="line">	trace_suspend_resume(TPS(&quot;freeze_processes&quot;), 0, true);</span><br><span class="line">  // freeze用户空间进程和内核线程</span><br><span class="line">	error = suspend_freeze_processes();</span><br><span class="line">	trace_suspend_resume(TPS(&quot;freeze_processes&quot;), 0, false);</span><br><span class="line">	if (!error)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	suspend_stats.failed_freeze++;</span><br><span class="line">	dpm_save_failed_step(SUSPEND_FREEZE);</span><br><span class="line"> Finish:</span><br><span class="line">	// 如果freeze失败，则恢复console的操作</span><br><span class="line">	pm_notifier_call_chain(PM_POST_SUSPEND);</span><br><span class="line">	pm_restore_console();</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>suspend_prepare主要是处理console并冻结用户进程与内核线程，在suspend_prepare准备工作之后，调用suspend_devices_and_enter开始进入suspend状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/suspend.c</span><br><span class="line"></span><br><span class="line">int suspend_devices_and_enter(suspend_state_t state)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line">	bool wakeup = false;</span><br><span class="line"></span><br><span class="line">	// 再次检查是否支持该state，PM_SUSPEND_FREEZE或者有实现suspend_ops-&gt;enter</span><br><span class="line">	if (!sleep_state_supported(state))</span><br><span class="line">		return -ENOSYS;</span><br><span class="line"></span><br><span class="line">	//调用平台实现suspend_ops-&gt;begin()</span><br><span class="line">	error = platform_suspend_begin(state);</span><br><span class="line">	if (error)</span><br><span class="line">		goto Close;</span><br><span class="line"></span><br><span class="line">	//挂起console</span><br><span class="line">	suspend_console();</span><br><span class="line">	suspend_test_start();</span><br><span class="line">	//调用所有设备的-&gt;prepare和-&gt;suspend回调函数，注意suspend device可能失败，会跳至Recover_platform，执行recover操作（suspend_ops-&gt;recover）</span><br><span class="line">	error = dpm_suspend_start(PMSG_SUSPEND);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		pr_err(&quot;PM: Some devices failed to suspend, or early wake event detected\n&quot;);</span><br><span class="line">		log_suspend_abort_reason(&quot;Some devices failed to suspend, or early wake event detected&quot;);</span><br><span class="line">		goto Recover_platform;</span><br><span class="line">	&#125;</span><br><span class="line">	suspend_test_finish(&quot;suspend devices&quot;);</span><br><span class="line">	if (suspend_test(TEST_DEVICES))</span><br><span class="line">		goto Recover_platform;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		// 最终，在suspend_enter中进入suspend状态</span><br><span class="line">		error = suspend_enter(state, &amp;wakeup);</span><br><span class="line">	&#125; while (!error &amp;&amp; !wakeup &amp;&amp; platform_suspend_again(state));</span><br><span class="line"></span><br><span class="line"> Resume_devices:</span><br><span class="line">	suspend_test_start();</span><br><span class="line">	dpm_resume_end(PMSG_RESUME);</span><br><span class="line">	suspend_test_finish(&quot;resume devices&quot;);</span><br><span class="line">	trace_suspend_resume(TPS(&quot;resume_console&quot;), state, true);</span><br><span class="line">	resume_console();</span><br><span class="line">	trace_suspend_resume(TPS(&quot;resume_console&quot;), state, false);</span><br><span class="line"></span><br><span class="line"> Close:</span><br><span class="line">	platform_resume_end(state);</span><br><span class="line">	return error;</span><br><span class="line"></span><br><span class="line"> Recover_platform:</span><br><span class="line">	platform_recover(state);</span><br><span class="line">	goto Resume_devices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>suspend_devices_and_enter中会挂起console，并执行设备驱动的-&gt;prepare和-&gt;suspend回调函数，然后在suspend_enter中进入休眠状态，通过返回值告知是否enter成功，同时通过wakeup指针，告知调用者，是否有wakeup事件发生，导致进入休眠失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/kernel/power/suspend.c</span><br><span class="line"></span><br><span class="line">static int suspend_enter(suspend_state_t state, bool *wakeup)</span><br><span class="line">&#123;</span><br><span class="line">	char suspend_abort[MAX_SUSPEND_ABORT_LEN];</span><br><span class="line">	int error, last_dev;</span><br><span class="line">	// 调用suspend_ops-&gt;prepare()</span><br><span class="line">	error = platform_suspend_prepare(state);</span><br><span class="line">	if (error)</span><br><span class="line">		goto Platform_finish;</span><br><span class="line">	// 调用所有设备的-&gt;suspend_late和-&gt;suspend_noirq回调函数</span><br><span class="line">	error = dpm_suspend_late(PMSG_SUSPEND);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		last_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;</span><br><span class="line">		last_dev %= REC_FAILED_NUM;</span><br><span class="line">		printk(KERN_ERR &quot;PM: late suspend of devices failed\n&quot;);</span><br><span class="line">		log_suspend_abort_reason(&quot;%s device failed to power down&quot;,</span><br><span class="line">			suspend_stats.failed_devs[last_dev]);</span><br><span class="line">		goto Platform_finish;</span><br><span class="line">	&#125;</span><br><span class="line">	// 调用suspend_ops的prepare_late回调</span><br><span class="line">	error = platform_suspend_prepare_late(state);</span><br><span class="line">	if (error)</span><br><span class="line">		goto Devices_early_resume;</span><br><span class="line"></span><br><span class="line">	error = dpm_suspend_noirq(PMSG_SUSPEND);</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		last_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;</span><br><span class="line">		last_dev %= REC_FAILED_NUM;</span><br><span class="line">		printk(KERN_ERR &quot;PM: noirq suspend of devices failed\n&quot;);</span><br><span class="line">		log_suspend_abort_reason(&quot;noirq suspend of %s device failed&quot;,</span><br><span class="line">			suspend_stats.failed_devs[last_dev]);</span><br><span class="line">		goto Platform_early_resume;</span><br><span class="line">	&#125;</span><br><span class="line">	error = platform_suspend_prepare_noirq(state);</span><br><span class="line">	if (error)</span><br><span class="line">		goto Platform_wake;</span><br><span class="line"></span><br><span class="line">	if (suspend_test(TEST_PLATFORM))</span><br><span class="line">		goto Platform_wake;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 如果是suspend to freeze，执行相应的操作，包括冻结进程</span><br><span class="line">	 * suspended devices（参数为PM_SUSPEND_FREEZE）、cpu进入idle。</span><br><span class="line">	 * 如果有任何事件使CPU从idle状态退出，跳至Platform_wake处，执行wake操作。</span><br><span class="line">	 */</span><br><span class="line">	if (state == PM_SUSPEND_FREEZE) &#123;</span><br><span class="line">		trace_suspend_resume(TPS(&quot;machine_suspend&quot;), state, true);</span><br><span class="line">		freeze_enter();</span><br><span class="line">		trace_suspend_resume(TPS(&quot;machine_suspend&quot;), state, false);</span><br><span class="line">		goto Platform_wake;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 禁止所有的非boot cpu</span><br><span class="line">	error = disable_nonboot_cpus();</span><br><span class="line">	if (error || suspend_test(TEST_CPUS)) &#123;</span><br><span class="line">		log_suspend_abort_reason(&quot;Disabling non-boot cpus failed&quot;);</span><br><span class="line">		goto Enable_cpus;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//关全局中断</span><br><span class="line">	arch_suspend_disable_irqs();</span><br><span class="line">	BUG_ON(!irqs_disabled());</span><br><span class="line"></span><br><span class="line">	// 调用syscore_suspend，suspend system core</span><br><span class="line">	error = syscore_suspend();</span><br><span class="line">	if (!error) &#123;</span><br><span class="line">		// 检查一下suspend执行这段时间内，是否有唤醒事件发生</span><br><span class="line">		*wakeup = pm_wakeup_pending();</span><br><span class="line">		if (!(suspend_test(TEST_CORE) || *wakeup)) &#123;</span><br><span class="line">			trace_suspend_resume(TPS(&quot;machine_suspend&quot;),</span><br><span class="line">				state, true);</span><br><span class="line">			// 调用suspend_ops-&gt;enter进入休眠状态  </span><br><span class="line">			error = suspend_ops-&gt;enter(state);</span><br><span class="line">			trace_suspend_resume(TPS(&quot;machine_suspend&quot;),</span><br><span class="line">				state, false);</span><br><span class="line">			events_check_enabled = false;</span><br><span class="line">		&#125; else if (*wakeup) &#123;</span><br><span class="line">			pm_get_active_wakeup_sources(suspend_abort,</span><br><span class="line">				MAX_SUSPEND_ABORT_LEN);</span><br><span class="line">			log_suspend_abort_reason(suspend_abort);</span><br><span class="line">			error = -EBUSY;</span><br><span class="line">		&#125;</span><br><span class="line">		syscore_resume();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arch_suspend_enable_irqs();</span><br><span class="line">	BUG_ON(irqs_disabled());</span><br><span class="line"></span><br><span class="line"> Enable_cpus:</span><br><span class="line">	enable_nonboot_cpus();</span><br><span class="line"></span><br><span class="line"> Platform_wake:</span><br><span class="line">	platform_resume_noirq(state);</span><br><span class="line">	dpm_resume_noirq(PMSG_RESUME);</span><br><span class="line">suspend_ops-&gt;enter</span><br><span class="line"> Platform_early_resume:</span><br><span class="line">	platform_resume_early(state);</span><br><span class="line"></span><br><span class="line"> Devices_early_resume:</span><br><span class="line">	dpm_resume_early(PMSG_RESUME);</span><br><span class="line"></span><br><span class="line"> Platform_finish:</span><br><span class="line">	platform_resume_finish(state);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>suspend_enter中经过一系列的处理，最终在suspend_ops-&gt;enter中进入休眠状态，当唤醒事件发生，系统唤醒，该函数接着执行resume动作，并最终返回，resume动作基本上是suspend的反动作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之System wakeup events framework]]></title>
      <url>http://robinheztto.com/2017/05/01/android-power-system-wakeup-events-framework/</url>
      <content type="html"><![CDATA[<blockquote>
<p>kernel/msm-4.4/drivers/base/power/wakeup.c<br>kernel/msm-4.4/include/linux/pm_wakeup.h<br>kernel/msm-4.4/include/linux/pm.h<br>kernel/msm-4.4/include/linux/device.h</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Android以Linux kernel为系统内核，其电源管理也是基于Linux电源管理子系统的，但是由于传统的Linux系统主要针对PC而非移动设备，对于PC系统，Linux默认是在用户不再使用时才再触发系统进入休眠(STR、Standby、Hibernate)，但是对于移动设备的使用特点而言，并没有明确的不再使用设备的时候，用户随时随地都可能需要使用设备，于是在Android上就有提出了“Opportunistic suspend”的概念，即逮到机会就睡直到下次被唤醒，以适应移动设备的使用特点。</p>
<p>早期，Android为解决该问题，在标准Linux的基础上增加了Early Suspend和Late Resume机制，Early suspend是在熄屏后，提前将一些不会用到的设备(比如背光、重力感应器和触摸屏等设备)关闭，但此时系统仍能持有wake lock后台运行。该方案将Linux原来suspend的流程改变，并增加了Android自己的处理函数，与kernel的流程与机制相冲突，另外一个问题就是存在suspend和wakeup events之间的同步问题，比如当系统进入suspend流程中，会进行freeze process，device prepared，device suspend，disabled irq等操作，如果在suspend流程中有wakeup events产生，而此时系统无法从suspend过程中唤醒。</p>
<p>后来Linux加入wakeup events framework，包括wake lock、wakeup count、autosleep等机制。用来解决system suspend和system wakeup events之间的同步问题。同时在Android4.4中，Android中也去掉了之前的”wakelocks”机制，利用wakeup events framework重新设计了wakelocks，并且维持上层API不变。</p>
<p>system suspend和system wakeup events之间的同步问题:</p>
<ul>
<li>内核空间的同步:<br>wakeup events产生后，通常是以中断的形式通知device driver。driver会处理events，处理的过程中，系统不能suspend。</li>
<li>用户空间的同步:<br>一般情况下，driver对wakeup events处理后，会交给用户空间程序继续处理，处理的过程，也不允许suspend。这又可以分为两种情况：<ol>
<li>进行后续处理的用户进程，根本没有机会被调度，即该wakeup events无法上报到用户空间。</li>
<li>进行后续处理的用户进程被调度，处理的过程中（以及处理结束后，决定终止suspend操作），系统不能suspend。(wake lock功能)</li>
</ol>
</li>
</ul>
<p>wakeup events framework主要解决上述三个同步问题，内核空间的同步(framework的核心功能)，用户空间的同步情形1(wakeup count功能)，用户空间的同步情形2(wake lock功能)。  </p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>下面是wakeup events framework的architecture图(来自<a href="http://www.wowotech.net" target="_blank" rel="external">蜗窝科技</a>)</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/wakeup-events-framework-arch.jpeg?raw=true" alt="wakeup events framework architecture"><br></div><br>wakeup events framework sysfs将设备的wakeup信息，以sysfs的形式提供到用户空间，供用户空间访问(在drivers/base/power/sysfs.c中实现)。<br><br>## wakeup source<br>在kernel中，只有设备才能唤醒系统，但并不是所有设备都具备唤醒系统的能力，具备唤醒能力的设备即“wakeup source”，会在设备结构体struce device中标志该设备具有唤醒能力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; kernel/msm-4.4/include/linux/device.h</span><br><span class="line"></span><br><span class="line">struct device &#123;  </span><br><span class="line">    ...  </span><br><span class="line">    struct dev_pm_info  power;   </span><br><span class="line">    struct dev_pm_domain    *pm_domain;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; kernel/msm-4.4/include/linux/pm_wakeup.h</span><br><span class="line"></span><br><span class="line">static inline bool device_can_wakeup(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	return dev-&gt;power.can_wakeup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline bool device_may_wakeup(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	return dev-&gt;power.can_wakeup &amp;&amp; !!dev-&gt;power.wakeup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>由device_can_wakeup()函数可知，通过dev-&gt;power.can_wakeup来判断该设备是否能唤醒系统，struct dev_pm_info的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/include/linux/pm.h</span><br><span class="line"></span><br><span class="line">struct dev_pm_info &#123;</span><br><span class="line">  ......</span><br><span class="line">	unsigned int		can_wakeup:1;</span><br><span class="line">  ......</span><br><span class="line">#ifdef CONFIG_PM_SLEEP</span><br><span class="line">  ......</span><br><span class="line">	struct wakeup_source	*wakeup;</span><br><span class="line">  ......</span><br><span class="line">#else</span><br><span class="line">	unsigned int		should_wakeup:1;</span><br><span class="line">#endif</span><br><span class="line">  ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>struct dev_pm_info中的can_wakeup标识该设备是否具有唤醒能力。具备唤醒能力的设备在sys/devices/xxx/下存在power相关目录，用于提供所有的wakeup信息，这些信息是以struct wakeup_source的结构组织，即struct dev_pm_info中的wakeup指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/include/linux/pm_wakeup.h</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * struct wakeup_source - Representation of wakeup sources</span><br><span class="line"> *</span><br><span class="line"> * @name: 唤醒源的名字</span><br><span class="line"> * @entry: 用来将唤醒源挂到链表上，用于管理</span><br><span class="line"> * @lock: 同步机制，用于访问链表时使用</span><br><span class="line"> * @wakeirq:Optional device specific wakeirq</span><br><span class="line"> * @timer: 定时器，用于设置该唤醒源的超时时间</span><br><span class="line"> * @timer_expires:  定时器的超时时间</span><br><span class="line"> * @total_time:  wakeup source处于active状态的总时间，可指示该wakeup source对应的设备的繁忙程度、耗电等级</span><br><span class="line"> * @max_time: wakeup source处于active状态的最长时间（越长越不合理）</span><br><span class="line"> * @last_time: wakeup source处于active状态的上次时间</span><br><span class="line"> * @prevent_sleep_time: wakeup source阻止系统自动休眠的总时间</span><br><span class="line"> * @event_count:  wakeup source上报wakeup event的个数</span><br><span class="line"> * @active_count: wakeup source处于active状态的次数</span><br><span class="line"> * @relax_count: wakeup source处于deactive状态的次数</span><br><span class="line"> * @expire_count: wakeup source timeout次数</span><br><span class="line"> * @wakeup_count: wakeup source abort睡眠的次数</span><br><span class="line"> * @active: wakeup source的状态</span><br><span class="line"> * @has_timeout: The wakeup source has been activated with a timeout.</span><br><span class="line"> */</span><br><span class="line">struct wakeup_source &#123;</span><br><span class="line">	const char 		*name;</span><br><span class="line">	struct list_head	entry;</span><br><span class="line">	spinlock_t		lock;</span><br><span class="line">	struct wake_irq		*wakeirq;</span><br><span class="line">	struct timer_list	timer;</span><br><span class="line">	unsigned long		timer_expires;</span><br><span class="line">	ktime_t total_time;</span><br><span class="line">	ktime_t max_time;</span><br><span class="line">	ktime_t last_time;</span><br><span class="line">	ktime_t start_prevent_time;</span><br><span class="line">	ktime_t prevent_sleep_time;</span><br><span class="line">	unsigned long		event_count;</span><br><span class="line">	unsigned long		active_count;</span><br><span class="line">	unsigned long		relax_count;</span><br><span class="line">	unsigned long		expire_count;</span><br><span class="line">	unsigned long		wakeup_count;</span><br><span class="line">	bool			active:1;</span><br><span class="line">	bool			autosleep_enabled:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>wakeup source代表一个具有唤醒能力的设备，该设备产生的可以唤醒系统的事件，就称作wakeup event。当wakeup source产生wakeup event时，需要将wakeup source切换为activate状态；当wakeup event处理完毕后，要切换为deactivate状态。当wakeup source产生wakeup event时，需要切换到activate状态，但并不是每次都需要切换，因此有可能已经处于activate状态了。因此active_count可能小于event_count，换句话说，很有可能在前一个wakeup event没被处理完时，又产生了一个，这从一定程度上反映了wakeup source所代表的设备的繁忙程度。wakeup source在suspend过程中产生wakeup event的话，就会终止suspend过程，wakeup_count记录了wakeup source终止suspend过程的次数（如果发现系统总是suspend失败，检查一下各个wakeup source的该变量，就可以知道问题出在谁身上了）。<br>为了方便查看系统的wakeup sources的信息，linux系统在/sys/kernel/debug下创建了一个”wakeup_sources”文件，此文件记录了系统的唤醒源的详细信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/drivers/base/power/wakeup.c</span><br><span class="line"></span><br><span class="line">static int wakeup_sources_stats_show(struct seq_file *m, void *unused)</span><br><span class="line">&#123;</span><br><span class="line">	struct wakeup_source *ws;</span><br><span class="line"></span><br><span class="line">	seq_puts(m, &quot;name\t\tactive_count\tevent_count\twakeup_count\t&quot;</span><br><span class="line">		&quot;expire_count\tactive_since\ttotal_time\tmax_time\t&quot;</span><br><span class="line">		&quot;last_change\tprevent_suspend_time\n&quot;);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	list_for_each_entry_rcu(ws, &amp;wakeup_sources, entry)</span><br><span class="line">		print_wakeup_source_stats(m, ws);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	print_wakeup_source_stats(m, &amp;deleted_ws);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int wakeup_sources_stats_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	return single_open(file, wakeup_sources_stats_show, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations wakeup_sources_stats_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = wakeup_sources_stats_open,</span><br><span class="line">	.read = seq_read,</span><br><span class="line">	.llseek = seq_lseek,</span><br><span class="line">	.release = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init wakeup_sources_debugfs_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	wakeup_sources_stats_dentry = debugfs_create_file(&quot;wakeup_sources&quot;,</span><br><span class="line">			S_IRUGO, NULL, NULL, &amp;wakeup_sources_stats_fops);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postcore_initcall(wakeup_sources_debugfs_init);</span><br></pre></td></tr></table></figure><br><br>如下图示，通过<code>cat /sys/kernel/debug/wakeup_sources</code>获取wakeup_sources信息：<br><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/sys_kernel_debug_wakeup_sources.png?raw=true" alt="sys_kernel_debug_wakeup_sources"><br></div>

<h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p>wakeup events framework中抽象了wakeup source和wakeup event的概念，向各个device driver提供wakeup source的注册、使能等及wakeup event的上报、停止等接口，同时也向上层提供wakeup event的查询接口，以判断是否可以suspend或者是否需要终止正在进行的suspend。</p>
<h3 id="pm-stay-awake"><a href="#pm-stay-awake" class="headerlink" title="pm_stay_awake()"></a>pm_stay_awake()</h3><p>当设备有wakeup event正在处理时，需要调用该接口通知PM core，该接口的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/drivers/base/power/wakeup.c</span><br><span class="line"></span><br><span class="line">void pm_stay_awake(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (!dev)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;power.lock, flags);</span><br><span class="line">	__pm_stay_awake(dev-&gt;power.wakeup);</span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;power.lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __pm_stay_awake(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (!ws)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ws-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	wakeup_source_report_event(ws);</span><br><span class="line">	del_timer(&amp;ws-&gt;timer);</span><br><span class="line">	ws-&gt;timer_expires = 0;</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;ws-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void wakeup_source_report_event(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	ws-&gt;event_count++;</span><br><span class="line">	/* This is racy, but the counter is approximate anyway. */</span><br><span class="line">	if (events_check_enabled)</span><br><span class="line">		ws-&gt;wakeup_count++;</span><br><span class="line"></span><br><span class="line">	if (!ws-&gt;active)</span><br><span class="line">		wakeup_source_activate(ws);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pm_stay_awake中直接调用<strong>pm_stay_awake，\</strong>pm_stay_awake直接调用wakeup_source_report_event。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/drivers/base/power/wakeup.c</span><br><span class="line"></span><br><span class="line">static void wakeup_source_report_event(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	ws-&gt;event_count++;</span><br><span class="line">	/* This is racy, but the counter is approximate anyway. */</span><br><span class="line">	if (events_check_enabled)</span><br><span class="line">		ws-&gt;wakeup_count++;</span><br><span class="line"></span><br><span class="line">	if (!ws-&gt;active)</span><br><span class="line">		wakeup_source_activate(ws);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>wakeup_source_report_event中增加wakeup source的event_count次数，即表示该source又产生了一个event。然后根据events_check_enabled变量的状态，增加wakeup_count。如果wakeup source没有active，则调用wakeup_source_activate进行activate操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/drivers/base/power/wakeup.c</span><br><span class="line"></span><br><span class="line">static void wakeup_source_activate(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cec;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * active wakeup source should bring the system</span><br><span class="line">	 * out of PM_SUSPEND_FREEZE state</span><br><span class="line">	 */</span><br><span class="line">	freeze_wake();</span><br><span class="line"></span><br><span class="line">	ws-&gt;active = true;</span><br><span class="line">	ws-&gt;active_count++;</span><br><span class="line">	ws-&gt;last_time = ktime_get();</span><br><span class="line">	if (ws-&gt;autosleep_enabled)</span><br><span class="line">		ws-&gt;start_prevent_time = ws-&gt;last_time;</span><br><span class="line"></span><br><span class="line">	/* Increment the counter of events in progress. */</span><br><span class="line">	cec = atomic_inc_return(&amp;combined_event_count);</span><br><span class="line"></span><br><span class="line">	trace_wakeup_source_activate(ws-&gt;name, cec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>wakeup_source_activate中首先调用freeze_wake，将系统从suspend to freeze状态下唤醒，然后设置active标志，增加active_count，更新last_time。如果使能了autosleep，更新start_prevent_time，此刻该wakeup source会开始阻止系统auto sleep。增加“wakeup events in progress”计数，增加该计数意味着系统正在处理的wakeup event数目不为零，即系统不能suspend。</p>
<h2 id="pm-relax"><a href="#pm-relax" class="headerlink" title="pm_relax()"></a>pm_relax()</h2><p>pm_relax和pm_stay_awake成对出现，用于在wakeup event处理结束后通知PM core，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/drivers/base/power/wakeup.c</span><br><span class="line"></span><br><span class="line">void pm_relax(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (!dev)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;dev-&gt;power.lock, flags);</span><br><span class="line">	__pm_relax(dev-&gt;power.wakeup);</span><br><span class="line">	spin_unlock_irqrestore(&amp;dev-&gt;power.lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void __pm_relax(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"></span><br><span class="line">	if (!ws)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;ws-&gt;lock, flags);</span><br><span class="line">	if (ws-&gt;active)</span><br><span class="line">		wakeup_source_deactivate(ws);</span><br><span class="line">	spin_unlock_irqrestore(&amp;ws-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pm_relax中直接调用<strong>pm_relax，\</strong>pm_relax判断wakeup source如果处于active状态，则调用wakeup_source_deactivate接口，deactivate该wakeup source。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/msm-4.4/drivers/base/power/wakeup.c</span><br><span class="line"></span><br><span class="line">static void wakeup_source_deactivate(struct wakeup_source *ws)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int cnt, inpr, cec;</span><br><span class="line">	ktime_t duration;</span><br><span class="line">	ktime_t now;</span><br><span class="line"></span><br><span class="line">	ws-&gt;relax_count++;</span><br><span class="line">	if (ws-&gt;relax_count != ws-&gt;active_count) &#123;</span><br><span class="line">		ws-&gt;relax_count--;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ws-&gt;active = false;</span><br><span class="line"></span><br><span class="line">	now = ktime_get();</span><br><span class="line">	duration = ktime_sub(now, ws-&gt;last_time);</span><br><span class="line">	ws-&gt;total_time = ktime_add(ws-&gt;total_time, duration);</span><br><span class="line">	if (ktime_to_ns(duration) &gt; ktime_to_ns(ws-&gt;max_time))</span><br><span class="line">		ws-&gt;max_time = duration;</span><br><span class="line"></span><br><span class="line">	ws-&gt;last_time = now;</span><br><span class="line">	del_timer(&amp;ws-&gt;timer);</span><br><span class="line">	ws-&gt;timer_expires = 0;</span><br><span class="line"></span><br><span class="line">	if (ws-&gt;autosleep_enabled)</span><br><span class="line">		update_prevent_sleep_time(ws, now);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Increment the counter of registered wakeup events and decrement the</span><br><span class="line">	 * couter of wakeup events in progress simultaneously.</span><br><span class="line">	 */</span><br><span class="line">	cec = atomic_add_return(MAX_IN_PROGRESS, &amp;combined_event_count);</span><br><span class="line">	trace_wakeup_source_deactivate(ws-&gt;name, cec);</span><br><span class="line"></span><br><span class="line">	split_counters(&amp;cnt, &amp;inpr);</span><br><span class="line">	if (!inpr &amp;&amp; waitqueue_active(&amp;wakeup_count_wait_queue))</span><br><span class="line">		wake_up(&amp;wakeup_count_wait_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://www.wowotech.net/pm_subsystem/wakeup_events_framework.html" target="_blank" rel="external">蜗窝科技:Wakeup events framework</a></li>
<li><a href="http://blog.csdn.net/wlwl0071986/article/details/42672591" target="_blank" rel="external">CSDN:三种休眠机制的分析和比较</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android电源管理系列之Basic]]></title>
      <url>http://robinheztto.com/2017/04/20/android-power-basic/</url>
      <content type="html"><![CDATA[<p><strong>1. Sleep/Suspend</strong><br>系统休眠Sleep，Linux Kernel中称作Suspend。系统进入Suspend状态确切来说时CPU进入了Suspend模式，因为对整个系统来说CPU休眠是整个系统休眠的先决条件。CPU Suspend即CPU进入Wait for interrupt状态（WFI），SW完全不跑了，停在suspend workqueue里面。<br>Android系统从灭屏到系统进入Suspend的大体流程框架如下:</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/suspend_flow.png?raw=true" alt="Suspend flow"><br></div><br>相关代码如下：</p>
<blockquote>
<p>/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java<br>/frameworks/base/services/core/jni/com_android_server_power_PowerManagerService.cpp<br>/system/core/libsuspend/<br>/kernel-x.x/kernel/power/</p>
</blockquote>
<p><strong>2. SPM</strong><br>SPM即System Power Manager，管理着包括AP，Modem，Connectivity等子系统。在CPU进入WFI状态后，整个系统就依靠SPM监控各个子系统的状态来控制睡眠/唤醒的流程。<br>SPM控制Cpu Suspend之后系统是否能掉到最小电流，当系统的关键资源（memory、clock）没有任何使用的时候，它就会让系统进入一个真正的深睡状态（最小电流），但只要检测到有任何资源请求还没释放，系统就无法降到底电流。在底电流的debug流程中，不仅仅要看CPU有没有Suspend成功，还要看SPM的状态是否正确。</p>
<p>MTK平台:<br>CPU在进入WFI状态前会把SPM的firmware写入到SPM里的可编程控制器PCM中（Programmable Command Master），然后PCM就依据firmware的逻辑来控制SPM的工作。系统中存在32k，26M二个时钟，系统工作在最小电流的时候，SPM只依靠32K时钟工作，因此要判断系统是不是已经到深休状态，就要看26M有没有关闭。</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/power/26M_control.png?raw=true" alt="26M clock control"><br></div><br>如上图所示，26M时钟有没有关，只需要看SCLKENA信号有没有关闭，而SPM对这个信号的输出以及子系统的信号输入，都记录在SPM的寄存器里面，这个就是我们通过log排查的依据。<br>相关代码如下：</p>
<blockquote>
<p>/kernel-x.x/drivers/misc/mediatek/base/power/spm_vx/</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之AlarmManagerService(三)]]></title>
      <url>http://robinheztto.com/2017/03/12/android-alarm-3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇分析Android上对于Alarm的优化，主要是对齐唤醒机制，也就是把一定时间段内的多次Alarm唤醒合并成一次，减少系统被唤醒次数，增加待机时间。</p>
</blockquote>
<h1 id="原生的对齐机制"><a href="#原生的对齐机制" class="headerlink" title="原生的对齐机制"></a>原生的对齐机制</h1><p>Beginning with API 19 (KITKAT) alarm delivery is inexact: the OS will shift alarms in order to minimize wakeups and battery use. There are new APIs to support applications which need strict delivery guarantees; see setWindow(int, long, long, PendingIntent) and setExact(int, long, PendingIntent). Applications whose targetSdkVersion is earlier than API 19 will continue to see the previous behavior in which all alarms are delivered exactly when requested.</p>
<p>从Android L版本开始，Android原生系统对AlarmManager默认set方法对alarm进行了对齐，alarm的触发时间不保证准确，同时也提供了setExact()，setWindow()用于设置精准时钟。</p>
<p>AlarmManagerService中根据windowLength来判断是否需要进行对齐，使用set()或setRepeating()等方法的windowLength被设置为WINDOW_HEURISTIC，使用setExact()方法的windowLength被设置成WINDOW_EXACT。对于windowLength设置成WINDOW_HEURISTIC的情况，AlarmManagerService会计算alarm的时间窗口(最大触发时间)，然后通过batch处理，将时间窗口有重合的alarm合并到同一个alarm中统一触发。WINDOW_EXACT的alarm的alarm还是精准时钟，放在单独的batch中处理。</p>
<p>虽然Android原生系统对alarm进行了对齐处理，但是仅仅是针对于非精确时钟，且当前国内应用基本上无论是否需要使用的都是setExact()等精准alarm接口，所以原生的对齐机制在国内作用很小。</p>
<h1 id="MTK对齐机制"><a href="#MTK对齐机制" class="headerlink" title="MTK对齐机制"></a>MTK对齐机制</h1><p>MTK在原生batch机制上对alarm的对齐做了进一步增强，</p>
<h1 id="Spreadtrum对齐心跳机制"><a href="#Spreadtrum对齐心跳机制" class="headerlink" title="Spreadtrum对齐心跳机制"></a>Spreadtrum对齐心跳机制</h1><h1 id="智能优化方案"><a href="#智能优化方案" class="headerlink" title="智能优化方案"></a>智能优化方案</h1><p>目标：尽量过滤合理开发范围内，</p>
<ol>
<li>灭屏，未充电</li>
<li>wakeup alarm</li>
<li>系统应用，白名单应用，CTS应用不触发对齐</li>
<li>alarmClock不触发对齐</li>
<li>触发时间在　后不触发对齐</li>
<li>窗口时间大于　不触发对齐</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之AlarmManagerService(二)]]></title>
      <url>http://robinheztto.com/2017/03/11/android-alarm-2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇继续分析Alarm设置及触发的流程。</p>
<p>相关源码位于以下文件中:<br>frameworks/base/core/java/android/app/AlarmManager.java<br>frameworks/base/services/core/java/com/android/server/AlarmManagerService.java<br>frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</p>
</blockquote>
<h1 id="Alarm-set"><a href="#Alarm-set" class="headerlink" title="Alarm set"></a>Alarm set</h1><p>下面从AlarmManagerService中的set方法开始分析Alarm set的实现过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">private final IBinder mService = new IAlarmManager.Stub() &#123;</span><br><span class="line">  ......</span><br><span class="line">  public void set(String callingPackage,</span><br><span class="line">          int type, long triggerAtTime, long windowLength, long interval, int flags,</span><br><span class="line">          PendingIntent operation, IAlarmListener directReceiver, String listenerTag,</span><br><span class="line">          WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock) &#123;</span><br><span class="line">      final int callingUid = Binder.getCallingUid();</span><br><span class="line"></span><br><span class="line">      // make sure the caller is not lying about which package should be blamed for</span><br><span class="line">      // wakelock time spent in alarm delivery</span><br><span class="line">      mAppOps.checkPackage(callingUid, callingPackage);</span><br><span class="line"></span><br><span class="line">      // Repeating alarms必须使用PendingIntent，不能使用AlarmListener</span><br><span class="line">      if (interval != 0) &#123;</span><br><span class="line">          if (directReceiver != null) &#123;</span><br><span class="line">              throw new IllegalArgumentException(&quot;Repeating alarms cannot use AlarmReceivers&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (workSource != null) &#123;</span><br><span class="line">          getContext().enforcePermission(</span><br><span class="line">                  android.Manifest.permission.UPDATE_DEVICE_STATS,</span><br><span class="line">                  Binder.getCallingPid(), callingUid, &quot;AlarmManager.set&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 清除callers的flag:WAKE_FROM_IDLE或FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED(需根据具体条件设置)</span><br><span class="line">      flags &amp;= ~(AlarmManager.FLAG_WAKE_FROM_IDLE</span><br><span class="line">              | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED);</span><br><span class="line"></span><br><span class="line">      // 只有DeviceIdleController可设置FLAG_IDLE_UNTIL,以进入Doze Idle状态</span><br><span class="line">      if (callingUid != Process.SYSTEM_UID) &#123;</span><br><span class="line">          flags &amp;= ~AlarmManager.FLAG_IDLE_UNTIL;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果是请求设置精确alarm，设置FLAG_STANDALONE，标志不对其进行batch批处理</span><br><span class="line">      if (windowLength == AlarmManager.WINDOW_EXACT) &#123;</span><br><span class="line">          flags |= AlarmManager.FLAG_STANDALONE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如果是alarmClock，设置FLAG_WAKE_FROM_IDLE可从idle唤醒，FLAG_STANDALONE不对其进行batch批处理</span><br><span class="line">      if (alarmClock != null) &#123;</span><br><span class="line">          flags |= AlarmManager.FLAG_WAKE_FROM_IDLE | AlarmManager.FLAG_STANDALONE;</span><br><span class="line"></span><br><span class="line">      // 如果caller是系统/用户设置mDeviceIdleUserWhitelist白名单，设置FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED标志</span><br><span class="line">      // 即在Doze Idle模式下精准时间，不受影响</span><br><span class="line">      &#125; else if (workSource == null &amp;&amp; (callingUid &lt; Process.FIRST_APPLICATION_UID</span><br><span class="line">              || Arrays.binarySearch(mDeviceIdleUserWhitelist,</span><br><span class="line">                      UserHandle.getAppId(callingUid)) &gt;= 0)) &#123;</span><br><span class="line">          flags |= AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED;</span><br><span class="line">          flags &amp;= ~AlarmManager.FLAG_ALLOW_WHILE_IDLE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setImpl(type, triggerAtTime, windowLength, interval, operation, directReceiver,</span><br><span class="line">              listenerTag, flags, workSource, alarmClock, callingUid, callingPackage);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>set()中对请求的参数进行了初步处理，然后继续调用setImpl()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">void setImpl(int type, long triggerAtTime, long windowLength, long interval,</span><br><span class="line">        PendingIntent operation, IAlarmListener directReceiver, String listenerTag,</span><br><span class="line">        int flags, WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock,</span><br><span class="line">        int callingUid, String callingPackage) &#123;</span><br><span class="line">    // PendingIntent与AlarmListener不能同时设置或同时为空</span><br><span class="line">    if ((operation == null &amp;&amp; directReceiver == null)</span><br><span class="line">            || (operation != null &amp;&amp; directReceiver != null)) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Alarms must either supply a PendingIntent or an AlarmReceiver&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // windowLength时间大于INTERVAL_HALF_DAY时，设置为INTERVAL_HOUR</span><br><span class="line">    if (windowLength &gt; AlarmManager.INTERVAL_HALF_DAY) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Window length &quot; + windowLength</span><br><span class="line">                + &quot;ms suspiciously long; limiting to 1 hour&quot;);</span><br><span class="line">        windowLength = AlarmManager.INTERVAL_HOUR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Repeating alarm的Repeat周期时间最短为MIN_INTERVAL即1s</span><br><span class="line">    final long minInterval = mConstants.MIN_INTERVAL;</span><br><span class="line">    if (interval &gt; 0 &amp;&amp; interval &lt; minInterval) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Suspiciously short interval &quot; + interval</span><br><span class="line">                + &quot; millis; expanding to &quot; + (minInterval/1000)</span><br><span class="line">                + &quot; seconds&quot;);</span><br><span class="line">        interval = minInterval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查定时器类型的合法性</span><br><span class="line">    if (type &lt; RTC_WAKEUP || type &gt; RTC_POWEROFF_WAKEUP) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Invalid alarm type &quot; + type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查triggerAtTime触发时间的合法性</span><br><span class="line">    if (triggerAtTime &lt; 0) &#123;</span><br><span class="line">        final long what = Binder.getCallingPid();</span><br><span class="line">        Slog.w(TAG, &quot;Invalid alarm trigger time! &quot; + triggerAtTime + &quot; from uid=&quot; + callingUid</span><br><span class="line">                + &quot; pid=&quot; + what);</span><br><span class="line">        triggerAtTime = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">    // 将触发绝对时间转化为相对时间</span><br><span class="line">    final long nominalTrigger = convertToElapsed(triggerAtTime, type);</span><br><span class="line">    // 为了防止定时器滥用，最小触发时间设置为当前时间之后5s</span><br><span class="line">    final long minTrigger = nowElapsed + mConstants.MIN_FUTURITY;</span><br><span class="line">    // 计算触发时间，当传入的触发时间大于最小触发时间时，使用传入触发时间，否则使用最小触发时间</span><br><span class="line">    final long triggerElapsed = (nominalTrigger &gt; minTrigger) ? nominalTrigger : minTrigger;</span><br><span class="line"></span><br><span class="line">    final long maxElapsed;</span><br><span class="line">    if (windowLength == AlarmManager.WINDOW_EXACT) &#123;</span><br><span class="line">        // 精确alarm，最大触发时间即为上面计算的触发时间</span><br><span class="line">        maxElapsed = triggerElapsed;</span><br><span class="line">    &#125; else if (windowLength &lt; 0) &#123;</span><br><span class="line">        // 非精准alarm，计算最大触发时间</span><br><span class="line">        maxElapsed = maxTriggerTime(nowElapsed, triggerElapsed, interval);</span><br><span class="line">        // 根据最大触发时间修正alarm的时间窗时间</span><br><span class="line">        windowLength = maxElapsed - triggerElapsed;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果时间窗口&gt;0，最大触发时间设置为触发时间加时间窗口</span><br><span class="line">        maxElapsed = triggerElapsed + windowLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        setImplLocked(type, triggerAtTime, triggerElapsed, windowLength, maxElapsed,</span><br><span class="line">                interval, operation, directReceiver, listenerTag, flags, true, workSource,</span><br><span class="line">                alarmClock, callingUid, callingPackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 非精准alarm，计算最大触发时间</span><br><span class="line">static final long MIN_FUZZABLE_INTERVAL = 10000;</span><br><span class="line">static long maxTriggerTime(long now, long triggerAtTime, long interval) &#123;</span><br><span class="line">    long futurity = (interval == 0)</span><br><span class="line">            ? (triggerAtTime - now)</span><br><span class="line">            : interval;</span><br><span class="line">    // 如果下一次触发的时间小于10秒，最大触发时间即为当前触发时间        </span><br><span class="line">    if (futurity &lt; MIN_FUZZABLE_INTERVAL) &#123;</span><br><span class="line">        futurity = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 下一次触发的时间大于10秒，把0.75倍的下次触发时间+当前触发时间作为alarm的最大触发时间maxElapsed</span><br><span class="line">    return triggerAtTime + (long)(.75 * futurity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setImpl中进一步对参数进行检查，然后调用setImplLocked()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void setImplLocked(int type, long when, long whenElapsed, long windowLength,</span><br><span class="line">        long maxWhen, long interval, PendingIntent operation, IAlarmListener directReceiver,</span><br><span class="line">        String listenerTag, int flags, boolean doValidate, WorkSource workSource,</span><br><span class="line">        AlarmManager.AlarmClockInfo alarmClock, int callingUid, String callingPackage) &#123;</span><br><span class="line">    // 将请求参数全部封装到Alarm对象中</span><br><span class="line">    Alarm a = new Alarm(type, when, whenElapsed, windowLength, maxWhen, interval,</span><br><span class="line">            operation, directReceiver, listenerTag, workSource, flags, alarmClock,</span><br><span class="line">            callingUid, callingPackage);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (ActivityManagerNative.getDefault().getAppStartMode(callingUid, callingPackage)</span><br><span class="line">                == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    // set Alarm之前先移除前面设置的alarm</span><br><span class="line">    removeLocked(operation, directReceiver);</span><br><span class="line">    // 继续调用setImplLocked设置Alarm</span><br><span class="line">    setImplLocked(a, false, doValidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setImplLocked将请求参数封装到Alarm后继续设置Alarm。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">private void setImplLocked(Alarm a, boolean rebatching, boolean doValidate) &#123;</span><br><span class="line">    // FLAG_IDLE_UNTIL该定时器是Doze Idle定时器</span><br><span class="line">    if ((a.flags&amp;AlarmManager.FLAG_IDLE_UNTIL) != 0) &#123;</span><br><span class="line">        // 如果有设置FLAG_WAKE_FROM_IDLE的Alarm mNextWakeFromIdle(第一次为null)且IDLE_UNTIL触发时间比它要长</span><br><span class="line">        // 设置IDLE_UNTIL Alarm的触发时间为mNextWakeFromIdle触发时间</span><br><span class="line">        if (mNextWakeFromIdle != null &amp;&amp; a.whenElapsed &gt; mNextWakeFromIdle.whenElapsed) &#123;</span><br><span class="line">            a.when = a.whenElapsed = a.maxWhenElapsed = mNextWakeFromIdle.whenElapsed;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将IDLE_UNTIL的触发时间随机提前一点触发</span><br><span class="line">        final long nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">        // 计算fuzz然后取随机值</span><br><span class="line">        final int fuzz = fuzzForDuration(a.whenElapsed-nowElapsed);</span><br><span class="line">        if (fuzz &gt; 0) &#123;</span><br><span class="line">            if (mRandom == null) &#123;</span><br><span class="line">                mRandom = new Random();</span><br><span class="line">            &#125;</span><br><span class="line">            final int delta = mRandom.nextInt(fuzz);</span><br><span class="line">            // 提前delta时间触发</span><br><span class="line">            a.whenElapsed -= delta;</span><br><span class="line">            a.when = a.maxWhenElapsed = a.whenElapsed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else if (mPendingIdleUntil != null) &#123;</span><br><span class="line">        // 当前已经处于Doze Idle状态，除了带FLAG_ALLOW_WHILE_IDLE，FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED</span><br><span class="line">        // FLAG_WAKE_FROM_IDLE flag的Alarm可以设置外，其他的Alarm被加入到mPendingWhileIdleAlarms后退出</span><br><span class="line">        if ((a.flags&amp;(AlarmManager.FLAG_ALLOW_WHILE_IDLE</span><br><span class="line">                | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED</span><br><span class="line">                | AlarmManager.FLAG_WAKE_FROM_IDLE))</span><br><span class="line">                == 0) &#123;</span><br><span class="line">            mPendingWhileIdleAlarms.add(a);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // FLAG_STANDALONE标志放到单独batch中，非FLAG_STANDALONE的在mAlarmBatches中查找合适的batch</span><br><span class="line">    int whichBatch = ((a.flags&amp;AlarmManager.FLAG_STANDALONE) != 0)</span><br><span class="line">            ? -1 : attemptCoalesceLocked(a.whenElapsed, a.maxWhenElapsed);</span><br><span class="line">    //　没有找到合适的batch，新建batch并加入到mAlarmBatches           </span><br><span class="line">    if (whichBatch &lt; 0) &#123;</span><br><span class="line">        Batch batch = new Batch(a);</span><br><span class="line">        addBatchLocked(mAlarmBatches, batch);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 找到了合适的batch，添加到batch中         </span><br><span class="line">        Batch batch = mAlarmBatches.get(whichBatch);</span><br><span class="line">        // 添加alarm，并更新了batch触发时间，需要对mAlarmBatches里面的所有batch进行排序</span><br><span class="line">        if (batch.add(a)) &#123;</span><br><span class="line">            mAlarmBatches.remove(whichBatch);</span><br><span class="line">            addBatchLocked(mAlarmBatches, batch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (a.alarmClock != null) &#123;</span><br><span class="line">        mNextAlarmClockMayChange = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean needRebatch = false;</span><br><span class="line"></span><br><span class="line">    if ((a.flags&amp;AlarmManager.FLAG_IDLE_UNTIL) != 0) &#123;</span><br><span class="line">        // 设置mPendingIdleUntil，即代表进入Doze Idle       </span><br><span class="line">        mPendingIdleUntil = a;　</span><br><span class="line">        mConstants.updateAllowWhileIdleMinTimeLocked();</span><br><span class="line">        // 需要重新rebatch所有的alarm</span><br><span class="line">        needRebatch = true;</span><br><span class="line">    &#125; else if ((a.flags&amp;AlarmManager.FLAG_WAKE_FROM_IDLE) != 0) &#123;</span><br><span class="line">        // 更新mNextWakeFromIdle</span><br><span class="line">        if (mNextWakeFromIdle == null || mNextWakeFromIdle.whenElapsed &gt; a.whenElapsed) &#123;</span><br><span class="line">            mNextWakeFromIdle = a;</span><br><span class="line">            if (mPendingIdleUntil != null) &#123;</span><br><span class="line">                needRebatch = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!rebatching) &#123;</span><br><span class="line">        // 对所有的Alarm重新进行batch操作</span><br><span class="line">        if (needRebatch) &#123;</span><br><span class="line">            rebatchAllAlarmsLocked(false);</span><br><span class="line">        &#125;</span><br><span class="line">        // 重新设置几个核心alarm</span><br><span class="line">        rescheduleKernelAlarmsLocked();</span><br><span class="line">        // 更新下一个alarm的alarmClock  </span><br><span class="line">        updateNextAlarmClockLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int fuzzForDuration(long duration) &#123;</span><br><span class="line">    if (duration &lt; 15*60*1000) &#123;</span><br><span class="line">        // 小于15分钟，返回实际时间</span><br><span class="line">        return (int)duration;</span><br><span class="line">    &#125; else if (duration &lt; 90*60*1000) &#123;</span><br><span class="line">        // 小于90分钟，最多提前15分钟</span><br><span class="line">        return 15*60*1000;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 90分钟以上，最多提前半小时</span><br><span class="line">        return 30*60*1000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据触发时间与最长触发时间从mAlarmBatches中找合适的batch，找到则返回index，否则返回-1</span><br><span class="line">int attemptCoalesceLocked(long whenElapsed, long maxWhen) &#123;</span><br><span class="line">    final int N = mAlarmBatches.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        Batch b = mAlarmBatches.get(i);</span><br><span class="line">        if ((b.flags&amp;AlarmManager.FLAG_STANDALONE) == 0 &amp;&amp; b.canHold(whenElapsed, maxWhen)) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Batch &#123;</span><br><span class="line">    long start;</span><br><span class="line">    long end;</span><br><span class="line">    ......</span><br><span class="line">    // 根据Alarm的触发时间及最大触发时间，与batch的触发时间与最大触发时间是否有重合，有重合即可以合入该batch</span><br><span class="line">    boolean canHold(long whenElapsed, long maxWhen) &#123;</span><br><span class="line">        return (end &gt;= whenElapsed) &amp;&amp; (start &lt;= maxWhen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加Alarm，并根据Alarm的触发时间判断是否需要更新batch时间，如果更新了batch时间则返回true，对batch重新排序</span><br><span class="line">    boolean add(Alarm alarm) &#123;</span><br><span class="line">        boolean newStart = false;</span><br><span class="line">        // narrows the batch if necessary; presumes that canHold(alarm) is true</span><br><span class="line">        int index = Collections.binarySearch(alarms, alarm, sIncreasingTimeOrder);</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            index = 0 - index - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        alarms.add(index, alarm);</span><br><span class="line">        // 如果Alarm的触发时间比batch的触发时间要早，则更新整个batch的触发时间</span><br><span class="line">        if (alarm.whenElapsed &gt; start) &#123;</span><br><span class="line">            start = alarm.whenElapsed;</span><br><span class="line">            newStart = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (alarm.maxWhenElapsed &lt; end) &#123;</span><br><span class="line">            end = alarm.maxWhenElapsed;</span><br><span class="line">        &#125;</span><br><span class="line">        flags |= alarm.flags;</span><br><span class="line">        return newStart;</span><br><span class="line">    &#125;    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将mAlarmBatches按照升序排序</span><br><span class="line">static boolean addBatchLocked(ArrayList&lt;Batch&gt; list, Batch newBatch) &#123;</span><br><span class="line">    int index = Collections.binarySearch(list, newBatch, sBatchOrder);</span><br><span class="line">    if (index &lt; 0) &#123;</span><br><span class="line">        index = 0 - index - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(index, newBatch);</span><br><span class="line">    return (index == 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setImplLocked中首先对FLAG_IDLE_UNTIL的alarm进行处理，然后根据mPendingIdleUntil是否null判断当前是否是Doze Idle模式，Doze Idle模式下会pending所有非FLAG_ALLOW_WHILE_IDLE，FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED，FLAG_WAKE_FROM_IDLE flag的alarm，然后添加alarm合适的batch中，最后调度设置alarm到kernel中。当涉及到FLAG_IDLE_UNTIL进入Doze Idle，或FLAG_WAKE_FROM_IDLE Doze下更新Alarm时，需重新进行rebatch操作，下面分析rebatchAllAlarmsLocked()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">void rebatchAllAlarms() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        rebatchAllAlarmsLocked(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rebatchAllAlarmsLocked(boolean doValidate) &#123;</span><br><span class="line">    // 备份mAlarmBatches，mPendingIdleUntil</span><br><span class="line">    ArrayList&lt;Batch&gt; oldSet = (ArrayList&lt;Batch&gt;) mAlarmBatches.clone();</span><br><span class="line">    mAlarmBatches.clear();</span><br><span class="line">    Alarm oldPendingIdleUntil = mPendingIdleUntil;</span><br><span class="line">    final long nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">    final int oldBatches = oldSet.size();</span><br><span class="line">    for (int batchNum = 0; batchNum &lt; oldBatches; batchNum++) &#123;</span><br><span class="line">        Batch batch = oldSet.get(batchNum);</span><br><span class="line">        final int N = batch.size();</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            // 重新添加alarm</span><br><span class="line">            reAddAlarmLocked(batch.get(i), nowElapsed, doValidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldPendingIdleUntil != null &amp;&amp; oldPendingIdleUntil != mPendingIdleUntil) &#123;</span><br><span class="line">        Slog.wtf(TAG, &quot;Rebatching: idle until changed from &quot; + oldPendingIdleUntil</span><br><span class="line">                + &quot; to &quot; + mPendingIdleUntil);</span><br><span class="line">        if (mPendingIdleUntil == null) &#123;</span><br><span class="line">            // Somehow we lost this...  we need to restore all of the pending alarms.</span><br><span class="line">            restorePendingWhileIdleAlarmsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rescheduleKernelAlarmsLocked();</span><br><span class="line">    updateNextAlarmClockLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rebatchAllAlarmsLocked中主要是对Alarm进行重新set及batch的操作。继续看rescheduleKernelAlarmsLocked()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">void rescheduleKernelAlarmsLocked() &#123;</span><br><span class="line">    // Schedule the next upcoming wakeup alarm.  If there is a deliverable batch</span><br><span class="line">    // prior to that which contains no wakeups, we schedule that as well.</span><br><span class="line">    long nextNonWakeup = 0;</span><br><span class="line">    if (mAlarmBatches.size() &gt; 0) &#123;</span><br><span class="line">        // 获取第一个wakeup的batch</span><br><span class="line">        final Batch firstWakeup = findFirstWakeupBatchLocked();</span><br><span class="line">        // 获取第一个batch</span><br><span class="line">        final Batch firstBatch = mAlarmBatches.get(0);</span><br><span class="line">        // 获取第一个RtcPowerOff的batch</span><br><span class="line">        final Batch firstRtcWakeup = findFirstRtcWakeupBatchLocked();</span><br><span class="line">        // 更新mNextWakeup并调用native方法设置alarm</span><br><span class="line">        if (firstWakeup != null &amp;&amp; mNextWakeup != firstWakeup.start) &#123;</span><br><span class="line">            mNextWakeup = firstWakeup.start;</span><br><span class="line">            mLastWakeupSet = SystemClock.elapsedRealtime();</span><br><span class="line">            setLocked(ELAPSED_REALTIME_WAKEUP, firstWakeup.start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //　设置RTC_POWEROFF类型的alarm到kernel</span><br><span class="line">        if (firstRtcWakeup != null &amp;&amp; mNextRtcWakeup != firstRtcWakeup.start) &#123;</span><br><span class="line">            mNextRtcWakeup = firstRtcWakeup.start;</span><br><span class="line">            Alarm alarm = firstRtcWakeup.getAlarmByElapsedTime(mNextRtcWakeup);</span><br><span class="line">            if (alarm != null) &#123;</span><br><span class="line">                // use packageName to check if the alarm is set from deskclock app</span><br><span class="line">                // (power off alarm)</span><br><span class="line">                String packageName = alarm.packageName;</span><br><span class="line">                if (DESKCLOCK_PACKAGE_NAME.equals(packageName)) &#123;</span><br><span class="line">                    mIsPowerOffAlarmSet = true;</span><br><span class="line">                    AlarmManager.writePowerOffAlarmFile(AlarmManager.POWER_OFF_ALARM_SET_FILE,</span><br><span class="line">                            AlarmManager.POWER_OFF_ALARM_SET);</span><br><span class="line">                    if (!mIsEncryptStatus) &#123;</span><br><span class="line">                        AlarmManager.writePowerOffAlarmFile(</span><br><span class="line">                                AlarmManager.POWER_OFF_ALARM_INSTANCE_FILE, &quot;&quot; + alarm.when);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (mIsPowerOffAlarmSet)&#123;</span><br><span class="line">                    mIsPowerOffAlarmSet = false;</span><br><span class="line">                    AlarmManager.writePowerOffAlarmFile(AlarmManager.POWER_OFF_ALARM_SET_FILE,</span><br><span class="line">                            AlarmManager.POWER_OFF_ALARM_NOT_SET);</span><br><span class="line">                &#125;</span><br><span class="line">                setLocked(RTC_POWEROFF_WAKEUP, alarm.when);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (firstRtcWakeup == null &amp;&amp; mIsPowerOffAlarmSet)&#123;</span><br><span class="line">            mIsPowerOffAlarmSet = false;</span><br><span class="line">            AlarmManager.writePowerOffAlarmFile(AlarmManager.POWER_OFF_ALARM_SET_FILE,</span><br><span class="line">                    AlarmManager.POWER_OFF_ALARM_NOT_SET);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果firstBatch没有wakeup类型的alarm，更新nextNonWakeup</span><br><span class="line">        if (firstBatch != firstWakeup) &#123;</span><br><span class="line">            nextNonWakeup = firstBatch.start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mPendingNonWakeupAlarms.size() &gt; 0) &#123;</span><br><span class="line">        if (nextNonWakeup == 0 || mNextNonWakeupDeliveryTime &lt; nextNonWakeup) &#123;</span><br><span class="line">            nextNonWakeup = mNextNonWakeupDeliveryTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新nextNonWakeup并设置到kernel</span><br><span class="line">    if (nextNonWakeup != 0 &amp;&amp; mNextNonWakeup != nextNonWakeup) &#123;</span><br><span class="line">        mNextNonWakeup = nextNonWakeup;</span><br><span class="line">        setLocked(ELAPSED_REALTIME, nextNonWakeup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Alarm-trigger"><a href="#Alarm-trigger" class="headerlink" title="Alarm trigger"></a>Alarm trigger</h1><p>在AlarmManagerService的启动时，创建并启动了AlarmThread线程，AlarmThread线程中循环等待Alarm的触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">private class AlarmThread extends Thread</span><br><span class="line">&#123;</span><br><span class="line">    public AlarmThread()</span><br><span class="line">    &#123;</span><br><span class="line">        super(&quot;AlarmManager&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList&lt;Alarm&gt; triggerList = new ArrayList&lt;Alarm&gt;();</span><br><span class="line"></span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            // 在waitForAlarm中阻塞等待Alarm的触发</span><br><span class="line">            int result = waitForAlarm(mNativeData);</span><br><span class="line">            // 记录触发时间mLastWakeup</span><br><span class="line">            mLastWakeup = SystemClock.elapsedRealtime();</span><br><span class="line">            // 清空triggerList</span><br><span class="line">            triggerList.clear();</span><br><span class="line">            // 获取当前绝对时间</span><br><span class="line">            final long nowRTC = System.currentTimeMillis();</span><br><span class="line">            // 获取当前相对时间</span><br><span class="line">            final long nowELAPSED = SystemClock.elapsedRealtime();</span><br><span class="line">            // 首先判断是否是时间改变事件</span><br><span class="line">            if ((result &amp; TIME_CHANGED_MASK) != 0) &#123;</span><br><span class="line">                // The kernel can give us spurious time change notifications due to</span><br><span class="line">                // small adjustments it makes internally; we want to filter those out.</span><br><span class="line">                final long lastTimeChangeClockTime;</span><br><span class="line">                final long expectedClockTime;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    lastTimeChangeClockTime = mLastTimeChangeClockTime;</span><br><span class="line">                    expectedClockTime = lastTimeChangeClockTime</span><br><span class="line">                            + (nowELAPSED - mLastTimeChangeRealtime);</span><br><span class="line">                &#125;</span><br><span class="line">                // 时间变化至少是 +/- 500 ms或者是第一次改变才进行处理</span><br><span class="line">                if (lastTimeChangeClockTime == 0 || nowRTC &lt; (expectedClockTime-500)</span><br><span class="line">                        || nowRTC &gt; (expectedClockTime+500)) &#123;</span><br><span class="line">                    // 由于时间变化，所以要重新批处理所有的alarm</span><br><span class="line">                    removeImpl(mTimeTickSender);</span><br><span class="line">                    removeImpl(mDateChangeSender);</span><br><span class="line">                    rebatchAllAlarms();</span><br><span class="line">                    mClockReceiver.scheduleTimeTickEvent();</span><br><span class="line">                    mClockReceiver.scheduleDateChangedEvent();</span><br><span class="line">                    synchronized (mLock) &#123;</span><br><span class="line">                        mNumTimeChanged++;</span><br><span class="line">                        mLastTimeChangeClockTime = nowRTC;</span><br><span class="line">                        mLastTimeChangeRealtime = nowELAPSED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Intent intent = new Intent(Intent.ACTION_TIME_CHANGED);</span><br><span class="line">                    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING</span><br><span class="line">                            | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</span><br><span class="line">                    getContext().sendBroadcastAsUser(intent, UserHandle.ALL);</span><br><span class="line"></span><br><span class="line">                    // The world has changed on us, so we need to re-evaluate alarms</span><br><span class="line">                    // regardless of whether the kernel has told us one went off.</span><br><span class="line">                    result |= IS_WAKEUP_MASK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (result != TIME_CHANGED_MASK) &#123;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    // 从mAlarmBatches中获取触发的batch的alarm并加入到triggerList中，返回是否有wakeup的alarm</span><br><span class="line">                    boolean hasWakeup = triggerAlarmsLocked(triggerList, nowELAPSED, nowRTC);</span><br><span class="line">                    // 没有wakeup类型的alarm，在灭屏情况下加入到mPendingNonWakeupAlarms延迟执行</span><br><span class="line">                    if (!hasWakeup &amp;&amp; checkAllowNonWakeupDelayLocked(nowELAPSED)) &#123;</span><br><span class="line">                        if (mPendingNonWakeupAlarms.size() == 0) &#123;</span><br><span class="line">                            mStartCurrentDelayTime = nowELAPSED;</span><br><span class="line">                            mNextNonWakeupDeliveryTime = nowELAPSED</span><br><span class="line">                                    + ((currentNonWakeupFuzzLocked(nowELAPSED)*3)/2);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingNonWakeupAlarms.addAll(triggerList);</span><br><span class="line">                        mNumDelayedAlarms += triggerList.size();</span><br><span class="line">                        rescheduleKernelAlarmsLocked();</span><br><span class="line">                        updateNextAlarmClockLocked();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 如果有wakeup类型的alarm，将mPendingNonWakeupAlarms加入到triggerList</span><br><span class="line">                        rescheduleKernelAlarmsLocked();</span><br><span class="line">                        updateNextAlarmClockLocked();</span><br><span class="line">                        if (mPendingNonWakeupAlarms.size() &gt; 0) &#123;</span><br><span class="line">                            calculateDeliveryPriorities(mPendingNonWakeupAlarms);</span><br><span class="line">                            triggerList.addAll(mPendingNonWakeupAlarms);</span><br><span class="line">                            Collections.sort(triggerList, mAlarmDispatchComparator);</span><br><span class="line">                            final long thisDelayTime = nowELAPSED - mStartCurrentDelayTime;</span><br><span class="line">                            mTotalDelayTime += thisDelayTime;</span><br><span class="line">                            if (mMaxDelayTime &lt; thisDelayTime) &#123;</span><br><span class="line">                                mMaxDelayTime = thisDelayTime;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mPendingNonWakeupAlarms.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 执行alarm</span><br><span class="line">                        deliverAlarmsLocked(triggerList, nowELAPSED);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    rescheduleKernelAlarmsLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AlarmThread线程通过waitForAlarm阻塞等待定时器触发，如果是时间改变事件，则发送时间改变通知并重新设置定时器。如果不是时间改变，则将mAlarmBatches中的首个batch的alarm加入到triggerList中，如果触发的alarm中没有wakeup类型，加入到mPendingNonWakeupAlarms中等下次执行，如果有wakeup类型的alarm，则调用deliverAlarmsLocked执行。继续看triggerAlarmsLocked的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">boolean triggerAlarmsLocked(ArrayList&lt;Alarm&gt; triggerList, final long nowELAPSED,</span><br><span class="line">        final long nowRTC) &#123;</span><br><span class="line">    boolean hasWakeup = false;</span><br><span class="line">    while (mAlarmBatches.size() &gt; 0) &#123;</span><br><span class="line">        // 触发时间最快的alarm排在最前，取第一个batch</span><br><span class="line">        Batch batch = mAlarmBatches.get(0);</span><br><span class="line">        if (batch.start &gt; nowELAPSED) &#123;</span><br><span class="line">            // 定时时间未到，先返回</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAlarmBatches.remove(0);</span><br><span class="line"></span><br><span class="line">        final int N = batch.size();</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            Alarm alarm = batch.get(i);</span><br><span class="line"></span><br><span class="line">            if ((alarm.flags&amp;AlarmManager.FLAG_ALLOW_WHILE_IDLE) != 0) &#123;</span><br><span class="line">                // 如果时FLAG_ALLOW_WHILE_IDLE类型定时器，需要至少mAllowWhileIdleMinTime的时间间隔触发</span><br><span class="line">                long lastTime = mLastAllowWhileIdleDispatch.get(alarm.uid, 0);</span><br><span class="line">                long minTime = lastTime + mAllowWhileIdleMinTime;</span><br><span class="line">                if (nowELAPSED &lt; minTime) &#123;</span><br><span class="line">                    alarm.whenElapsed = minTime;</span><br><span class="line">                    if (alarm.maxWhenElapsed &lt; minTime) &#123;</span><br><span class="line">                        alarm.maxWhenElapsed = minTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setImplLocked(alarm, true, false);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            alarm.count = 1;</span><br><span class="line">            // 加入到triggerList</span><br><span class="line">            triggerList.add(alarm);</span><br><span class="line">            if ((alarm.flags&amp;AlarmManager.FLAG_WAKE_FROM_IDLE) != 0) &#123;</span><br><span class="line">                EventLogTags.writeDeviceIdleWakeFromIdle(mPendingIdleUntil != null ? 1 : 0,</span><br><span class="line">                        alarm.statsTag);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果时mPendingIdleUntil触发，说明是Doze Idle状态时间到期</span><br><span class="line">            if (mPendingIdleUntil == alarm) &#123;</span><br><span class="line">                mPendingIdleUntil = null;</span><br><span class="line">                rebatchAllAlarmsLocked(false);</span><br><span class="line">                // 恢复pending的alarm</span><br><span class="line">                restorePendingWhileIdleAlarmsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            if (mNextWakeFromIdle == alarm) &#123;</span><br><span class="line">                mNextWakeFromIdle = null;</span><br><span class="line">                rebatchAllAlarmsLocked(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果是周期性alarm，设置下一个alarm触发</span><br><span class="line">            if (alarm.repeatInterval &gt; 0) &#123;</span><br><span class="line">                // this adjustment will be zero if we&apos;re late by</span><br><span class="line">                // less than one full repeat interval</span><br><span class="line">                alarm.count += (nowELAPSED - alarm.whenElapsed) / alarm.repeatInterval;</span><br><span class="line"></span><br><span class="line">                // Also schedule its next recurrence</span><br><span class="line">                final long delta = alarm.count * alarm.repeatInterval;</span><br><span class="line">                final long nextElapsed = alarm.whenElapsed + delta;</span><br><span class="line">                setImplLocked(alarm.type, alarm.when + delta, nextElapsed, alarm.windowLength,</span><br><span class="line">                        maxTriggerTime(nowELAPSED, nextElapsed, alarm.repeatInterval),</span><br><span class="line">                        alarm.repeatInterval, alarm.operation, null, null, alarm.flags, true,</span><br><span class="line">                        alarm.workSource, alarm.alarmClock, alarm.uid, alarm.packageName);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果该alarm是wakeup类型，设置hasWakeup为true</span><br><span class="line">            if (alarm.wakeup) &#123;</span><br><span class="line">                hasWakeup = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We removed an alarm clock. Let the caller recompute the next alarm clock.</span><br><span class="line">            if (alarm.alarmClock != null) &#123;</span><br><span class="line">                mNextAlarmClockMayChange = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // This is a new alarm delivery set; bump the sequence number to indicate that</span><br><span class="line">    // all apps&apos; alarm delivery classes should be recalculated.</span><br><span class="line">    mCurrentSeq++;</span><br><span class="line">    calculateDeliveryPriorities(triggerList);</span><br><span class="line">    Collections.sort(triggerList, mAlarmDispatchComparator);</span><br><span class="line"></span><br><span class="line">    return hasWakeup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之AlarmManagerService(一)]]></title>
      <url>http://robinheztto.com/2017/03/10/android-alarm-1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android系统通过AlarmManager向应用提供定时/闹钟服务，以使应用在其生命周期之外可执行基于特定时间的操作，本篇将具体分析AlarmManager的使用及AlarmManagerService服务的初始化。</p>
<p>相关源码位于以下文件中:<br>frameworks/base/core/java/android/app/AlarmManager.java<br>frameworks/base/services/core/java/com/android/server/AlarmManagerService.java<br>frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</p>
</blockquote>
<h1 id="AlarmManager的使用"><a href="#AlarmManager的使用" class="headerlink" title="AlarmManager的使用"></a>AlarmManager的使用</h1><p><strong>1. 获取AlarmManager:</strong><br>Alarm相关的服务接口定义在AlarmManager中，与其他系统服务一样，通过Context获取AlarmManager。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context.getSystemService(Context.ALARM_SERVICE);</span><br></pre></td></tr></table></figure></p>
<p><strong>2. Alarm的类型:</strong></p>
<ul>
<li>AlarmManager.RTC_WAKEUP<br>使用系统绝对时间(当前系统时间，System.currentTimeMillis())，系统休眠状态也将唤醒系统。</li>
<li>AlarmManager.RTC<br>使用系统绝对时间(当前系统时间，System.currentTimeMillis())，系统休眠状态下不可用。</li>
<li>AlarmManager.ELAPSED_REALTIME_WAKEUP<br>使用系统相对时间(相对系统启动时间，SystemClock.elapsedRealtime())，系统休眠状态也将唤醒系统。</li>
<li>AlarmManager.ELAPSED_REALTIME<br>使用系统相对时间(相对系统启动时间，SystemClock.elapsedRealtime())，系统休眠状态下不可用。</li>
</ul>
<p>RTC/RTC_WAKEUP和ELAPSED_REALTIME/ELAPSED_REALTIME_WAKEUP最大的差别就是RTC受time zone/locale的影响，可以通过修改手机时间触发闹钟事件，ELAPSED_REALTIME/ELAPSED_REALTIME_WAKEUP要通过真实时间的流逝，即使在休眠状态时间也会被计算。<br>WAKEUP类型的Alarm会唤醒系统，休眠状态下会增加系统的功耗，所以在使用中应尽量避免使用该种类型的Alarm。</p>
<p><strong>2. Alarm的Flag:</strong></p>
<ul>
<li>FLAG_STANDALONE<br>指定stand-alone精准alarm，该alarm不会被batch，设置WINDOW_EXACT的alarm会指定此flag。</li>
<li>FLAG_WAKE_FROM_IDLE<br>指定alarm即使在idle模式也将唤醒系统，如alarm clock。</li>
<li>FLAG_ALLOW_WHILE_IDLE<br>针对Doze模式，alarm即使在系统idle状态下也会执行，但是不会使系统退出idle mode，只有特殊alarm才需要标记该Flag。</li>
<li>FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED<br>针对Doze模式，alarm即使在系统idle状态下也会执行而且没有时间限制，但是不会使系统退出idle mode，只有特殊alarm才需要标记该Flag。</li>
<li>FLAG_IDLE_UNTIL<br>只有调用AlarmManager.setIdleUntil()接口才可能设置该flag，用来使系统进入idle mode直到marker alarm被执行，执行marker alarm时系统会退出idle mode(设置后进入DozeIdle状态让Alarm系统挂起，直到这个Alarm到期)。</li>
</ul>
<p><strong>3. Alarm的set:</strong><br>非精准Alarm，其window被指定为WINDOW_HEURISTIC：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void set(int type, long triggerAtMillis, PendingIntent operation) &#123;&#125;</span><br><span class="line">public void set(int type, long triggerAtMillis, String tag, OnAlarmListener listener,Handler targetHandler) &#123;&#125;</span><br><span class="line">public void setRepeating(int type, long triggerAtMillis,long intervalMillis, PendingIntent operation) &#123;&#125;</span><br><span class="line">public void setInexactRepeating(int type, long triggerAtMillis,long intervalMillis, PendingIntent operation) &#123;&#125;</span><br><span class="line">// Doze模式下</span><br><span class="line">public void setAndAllowWhileIdle(int type, long triggerAtMillis, PendingIntent operation) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>精准Alarm，其window被标记为WINDOW_EXACT：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void setWindow(int type, long windowStartMillis, long windowLengthMillis,PendingIntent operation) &#123;&#125;</span><br><span class="line">public void setWindow(int type, long windowStartMillis, long windowLengthMillis, String tag, OnAlarmListener listener, Handler targetHandler) &#123;&#125;</span><br><span class="line">public void setExact(int type, long triggerAtMillis, PendingIntent operation) &#123;&#125;   </span><br><span class="line">public void setExact(int type, long triggerAtMillis, String tag, OnAlarmListener listener, Handler targetHandler) &#123;&#125;  </span><br><span class="line">public void setAlarmClock(AlarmClockInfo info, PendingIntent operation) &#123;&#125;</span><br><span class="line">// Doze模式下</span><br><span class="line">public void setIdleUntil(int type, long triggerAtMillis, String tag, OnAlarmListener listener,Handler targetHandler) &#123;&#125;</span><br><span class="line">public void setExactAndAllowWhileIdle(int type, long triggerAtMillis, PendingIntent operation) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>AlarmManager中的set方法最终都是调用setImpl，下面是setImpl的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/app/AlarmManager.java</span><br><span class="line"></span><br><span class="line">private void setImpl(int type, long triggerAtMillis, long windowMillis, long intervalMillis,</span><br><span class="line">        int flags, PendingIntent operation, final OnAlarmListener listener, String listenerTag,</span><br><span class="line">        Handler targetHandler, WorkSource workSource, AlarmClockInfo alarmClock) &#123;</span><br><span class="line">    // 检查触发时间，不小于０      </span><br><span class="line">    if (triggerAtMillis &lt; 0) &#123;</span><br><span class="line">        triggerAtMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // OnAlarmListener封装到ListenerWrapper，并添加到sWrappers管理</span><br><span class="line">    ListenerWrapper recipientWrapper = null;</span><br><span class="line">    if (listener != null) &#123;</span><br><span class="line">        synchronized (AlarmManager.class) &#123;</span><br><span class="line">            if (sWrappers == null) &#123;</span><br><span class="line">                sWrappers = new ArrayMap&lt;OnAlarmListener, ListenerWrapper&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            recipientWrapper = sWrappers.get(listener);</span><br><span class="line">            // no existing wrapper =&gt; build a new one</span><br><span class="line">            if (recipientWrapper == null) &#123;</span><br><span class="line">                recipientWrapper = new ListenerWrapper(listener);</span><br><span class="line">                sWrappers.put(listener, recipientWrapper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Handler handler = (targetHandler != null) ? targetHandler : mMainThreadHandler;</span><br><span class="line">        recipientWrapper.setHandler(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用AlarmManagerService</span><br><span class="line">    try &#123;</span><br><span class="line">        mService.set(mPackageName, type, triggerAtMillis, windowMillis, intervalMillis, flags,</span><br><span class="line">                operation, recipientWrapper, listenerTag, workSource, alarmClock);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        throw ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="AlarmManagerService初始化"><a href="#AlarmManagerService初始化" class="headerlink" title="AlarmManagerService初始化"></a>AlarmManagerService初始化</h1><p>AlarmManagerService在SystemServer的startOtherServices中启动，下面从AlarmManagerService的构造方法开始分析，首先看整个初始化流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">public AlarmManagerService(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">    // 创建常量类，负责Alarm相关的常量读取及更新</span><br><span class="line">    mConstants = new Constants(mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面先看Constants类的具体实现，主要负责Alarm相关的常量的读取及更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">private final class Constants extends ContentObserver &#123;</span><br><span class="line">    // settings数据库中的key value</span><br><span class="line">    private static final String KEY_MIN_FUTURITY = &quot;min_futurity&quot;;</span><br><span class="line">    private static final String KEY_MIN_INTERVAL = &quot;min_interval&quot;;</span><br><span class="line">    private static final String KEY_ALLOW_WHILE_IDLE_SHORT_TIME = &quot;allow_while_idle_short_time&quot;;</span><br><span class="line">    private static final String KEY_ALLOW_WHILE_IDLE_LONG_TIME = &quot;allow_while_idle_long_time&quot;;</span><br><span class="line">    private static final String KEY_ALLOW_WHILE_IDLE_WHITELIST_DURATION</span><br><span class="line">            = &quot;allow_while_idle_whitelist_duration&quot;;</span><br><span class="line">    private static final String KEY_LISTENER_TIMEOUT = &quot;listener_timeout&quot;;</span><br><span class="line">    //　默认Alarm最小执行时间</span><br><span class="line">    private static final long DEFAULT_MIN_FUTURITY = 5 * 1000;</span><br><span class="line">    // 默认Repeat Alarm的最短周期时间</span><br><span class="line">    private static final long DEFAULT_MIN_INTERVAL = 60 * 1000;</span><br><span class="line">    // Doze IDLE下flag为ALLOW_WHILE_IDLE Alarm的最短时间间隔</span><br><span class="line">    private static final long DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME = DEFAULT_MIN_FUTURITY;</span><br><span class="line">    // Doze IDLE下flag为ALLOW_WHILE_IDLE Alarm的最长时间间隔</span><br><span class="line">    private static final long DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME = 9*60*1000;</span><br><span class="line">    // 默认的Idle白名单时间</span><br><span class="line">    private static final long DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION = 10*1000;</span><br><span class="line">    // 默认Listener的timeout</span><br><span class="line">    private static final long DEFAULT_LISTENER_TIMEOUT = 5 * 1000;</span><br><span class="line"></span><br><span class="line">    // Minimum futurity of a new alarm</span><br><span class="line">    public long MIN_FUTURITY = DEFAULT_MIN_FUTURITY;</span><br><span class="line"></span><br><span class="line">    // Minimum alarm recurrence interval</span><br><span class="line">    public long MIN_INTERVAL = DEFAULT_MIN_INTERVAL;</span><br><span class="line"></span><br><span class="line">    // Minimum time between ALLOW_WHILE_IDLE alarms when system is not idle.</span><br><span class="line">    public long ALLOW_WHILE_IDLE_SHORT_TIME = DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME;</span><br><span class="line"></span><br><span class="line">    // Minimum time between ALLOW_WHILE_IDLE alarms when system is idling.</span><br><span class="line">    public long ALLOW_WHILE_IDLE_LONG_TIME = DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME;</span><br><span class="line"></span><br><span class="line">    // BroadcastOptions.setTemporaryAppWhitelistDuration() to use for FLAG_ALLOW_WHILE_IDLE.</span><br><span class="line">    public long ALLOW_WHILE_IDLE_WHITELIST_DURATION</span><br><span class="line">            = DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION;</span><br><span class="line"></span><br><span class="line">    // Direct alarm listener callback timeout</span><br><span class="line">    public long LISTENER_TIMEOUT = DEFAULT_LISTENER_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    private ContentResolver mResolver;</span><br><span class="line">    private final KeyValueListParser mParser = new KeyValueListParser(&apos;,&apos;);</span><br><span class="line">    private long mLastAllowWhileIdleWhitelistDuration = -1;</span><br><span class="line"></span><br><span class="line">    public Constants(Handler handler) &#123;</span><br><span class="line">        super(handler);</span><br><span class="line">        // 更新Doze IDLE下flag为ALLOW_WHILE_IDLE Alarm的执行时间</span><br><span class="line">        updateAllowWhileIdleMinTimeLocked();</span><br><span class="line">        updateAllowWhileIdleWhitelistDurationLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 注册监听Settings数据库的变化并更新</span><br><span class="line">    public void start(ContentResolver resolver) &#123;</span><br><span class="line">        mResolver = resolver;</span><br><span class="line">        mResolver.registerContentObserver(Settings.Global.getUriFor(</span><br><span class="line">                Settings.Global.ALARM_MANAGER_CONSTANTS), false, this);</span><br><span class="line">        updateConstants();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateAllowWhileIdleMinTimeLocked() &#123;</span><br><span class="line">        mAllowWhileIdleMinTime = mPendingIdleUntil != null</span><br><span class="line">                ? ALLOW_WHILE_IDLE_LONG_TIME : ALLOW_WHILE_IDLE_SHORT_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateAllowWhileIdleWhitelistDurationLocked() &#123;</span><br><span class="line">        if (mLastAllowWhileIdleWhitelistDuration != ALLOW_WHILE_IDLE_WHITELIST_DURATION) &#123;</span><br><span class="line">            mLastAllowWhileIdleWhitelistDuration = ALLOW_WHILE_IDLE_WHITELIST_DURATION;</span><br><span class="line">            BroadcastOptions opts = BroadcastOptions.makeBasic();</span><br><span class="line">            opts.setTemporaryAppWhitelistDuration(ALLOW_WHILE_IDLE_WHITELIST_DURATION);</span><br><span class="line">            mIdleOptions = opts.toBundle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onChange(boolean selfChange, Uri uri) &#123;</span><br><span class="line">        updateConstants();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void updateConstants() &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mParser.setString(Settings.Global.getString(mResolver,</span><br><span class="line">                        Settings.Global.ALARM_MANAGER_CONSTANTS));</span><br><span class="line">            &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                // Failed to parse the settings string, log this and move on</span><br><span class="line">                // with defaults.</span><br><span class="line">                Slog.e(TAG, &quot;Bad device idle settings&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MIN_FUTURITY = mParser.getLong(KEY_MIN_FUTURITY, MIN_FUTURITY/*DEFAULT_MIN_FUTURITY*/);</span><br><span class="line">            MIN_INTERVAL = mParser.getLong(KEY_MIN_INTERVAL, DEFAULT_MIN_INTERVAL);</span><br><span class="line">            ALLOW_WHILE_IDLE_SHORT_TIME = mParser.getLong(KEY_ALLOW_WHILE_IDLE_SHORT_TIME,</span><br><span class="line">                    DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME);</span><br><span class="line">            ALLOW_WHILE_IDLE_LONG_TIME = mParser.getLong(KEY_ALLOW_WHILE_IDLE_LONG_TIME,</span><br><span class="line">                    DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME);</span><br><span class="line">            ALLOW_WHILE_IDLE_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">                    KEY_ALLOW_WHILE_IDLE_WHITELIST_DURATION,</span><br><span class="line">                    DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION);</span><br><span class="line">            LISTENER_TIMEOUT = mParser.getLong(KEY_LISTENER_TIMEOUT,</span><br><span class="line">                    DEFAULT_LISTENER_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            updateAllowWhileIdleMinTimeLocked();</span><br><span class="line">            updateAllowWhileIdleWhitelistDurationLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AlarmManagerService实例化后即调用onStart()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">public void onStart() &#123;</span><br><span class="line">    // native层初始化</span><br><span class="line">    mNativeData = init();</span><br><span class="line">    // mNextWakeup - 下一个包含wakeup alarm的batch的start时间,</span><br><span class="line">    // mNextRtcWakeup - 下一个包含Rtc关机闹钟batch的start时间  </span><br><span class="line">    // mNextNonWakeup - 下一个非wakeup的batch的start时间</span><br><span class="line">    mNextWakeup = mNextRtcWakeup = mNextNonWakeup = 0;</span><br><span class="line"></span><br><span class="line">    AlarmManager.writePowerOffAlarmFile(AlarmManager.POWER_OFF_ALARM_SET_FILE,</span><br><span class="line">            AlarmManager.POWER_OFF_ALARM_NOT_SET);</span><br><span class="line"></span><br><span class="line">    // 设置TimeZone</span><br><span class="line">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">    if (ENCRYPTING_STATE.equals(cryptState) || ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mIsEncryptStatus = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mIsEncryptStatus) &#123;</span><br><span class="line">        String tz =  AlarmManager</span><br><span class="line">                    .readPowerOffAlarmFile(AlarmManager.POWER_OFF_ALARM_TIMEZONE_FILE);</span><br><span class="line">        setTimeZoneImpl(tz);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        setTimeZoneImpl(SystemProperties.get(TIMEZONE_PROPERTY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化wakelock</span><br><span class="line">    PowerManager pm = (PowerManager) getContext().getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;*alarm*&quot;);</span><br><span class="line"></span><br><span class="line">    // 初始化ACTION_TIME_TICK发送</span><br><span class="line">    mTimeTickSender = PendingIntent.getBroadcastAsUser(getContext(), 0,</span><br><span class="line">            new Intent(Intent.ACTION_TIME_TICK).addFlags(</span><br><span class="line">                    Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                    | Intent.FLAG_RECEIVER_FOREGROUND), 0,</span><br><span class="line">                    UserHandle.ALL);</span><br><span class="line">    Intent intent = new Intent(Intent.ACTION_DATE_CHANGED);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);</span><br><span class="line">    mDateChangeSender = PendingIntent.getBroadcastAsUser(getContext(), 0, intent,</span><br><span class="line">            Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, UserHandle.ALL);</span><br><span class="line"></span><br><span class="line">    // 注册时间/日期变化广播接收并调度</span><br><span class="line">    mClockReceiver = new ClockReceiver();</span><br><span class="line">    mClockReceiver.scheduleTimeTickEvent();</span><br><span class="line">    mClockReceiver.scheduleDateChangedEvent();</span><br><span class="line">    // 注册灭屏/亮屏广播</span><br><span class="line">    mInteractiveStateReceiver = new InteractiveStateReceiver();</span><br><span class="line">    // 注册应用卸载，SD移除广播</span><br><span class="line">    mUninstallReceiver = new UninstallReceiver();</span><br><span class="line"></span><br><span class="line">    // native初始化成功，运行AlarmThread</span><br><span class="line">    if (mNativeData != 0) &#123;</span><br><span class="line">        AlarmThread waitThread = new AlarmThread();</span><br><span class="line">        waitThread.start();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Failed to open alarm driver. Falling back to a handler.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 监听应用退出以移除Alarm</span><br><span class="line">    try &#123;</span><br><span class="line">        ActivityManagerNative.getDefault().registerUidObserver(new UidObserver(),</span><br><span class="line">                ActivityManager.UID_OBSERVER_IDLE);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // ignored; both services live in system_server</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发布binderservice与localservice，分别供其他进程与system_server内部服务调用</span><br><span class="line">    publishBinderService(Context.ALARM_SERVICE, mService);</span><br><span class="line">    publishLocalService(LocalService.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在onStart()后，SYSTEM_SERVICES_READY时onBootPhase()将被回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onBootPhase(int phase) &#123;</span><br><span class="line">    if (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">        // 监听设置常量变化</span><br><span class="line">        mConstants.start(getContext().getContentResolver());</span><br><span class="line">        // 获取AppOpsManager与DeviceIdleController服务对象</span><br><span class="line">        mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">        mLocalDeviceIdleController</span><br><span class="line">                = LocalServices.getService(DeviceIdleController.LocalService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到onStart()，分析native层init的调用，下面看native init()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/AlarmManagerService.java</span><br><span class="line">private native long init();</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</span><br><span class="line">static const JNINativeMethod sMethods[] = &#123;</span><br><span class="line">     /* name, signature, funcPtr */</span><br><span class="line">    &#123;&quot;init&quot;, &quot;()J&quot;, (void*)android_server_AlarmManagerService_init&#125;,</span><br><span class="line">    &#123;&quot;close&quot;, &quot;(J)V&quot;, (void*)android_server_AlarmManagerService_close&#125;,</span><br><span class="line">    &#123;&quot;set&quot;, &quot;(JIJJ)V&quot;, (void*)android_server_AlarmManagerService_set&#125;,</span><br><span class="line">    &#123;&quot;clear&quot;, &quot;(JIJJ)V&quot;, (void*)android_server_AlarmManagerService_clear&#125;,</span><br><span class="line">    &#123;&quot;waitForAlarm&quot;, &quot;(J)I&quot;, (void*)android_server_AlarmManagerService_waitForAlarm&#125;,</span><br><span class="line">    &#123;&quot;setKernelTime&quot;, &quot;(JJ)I&quot;, (void*)android_server_AlarmManagerService_setKernelTime&#125;,</span><br><span class="line">    &#123;&quot;setKernelTimezone&quot;, &quot;(JI)I&quot;, (void*)android_server_AlarmManagerService_setKernelTimezone&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int register_android_server_AlarmManagerService(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    return jniRegisterNativeMethods(env, &quot;com/android/server/AlarmManagerService&quot;,</span><br><span class="line">                                    sMethods, NELEM(sMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>register_android_server_AlarmManagerService中注册了native方法，init()即调用android_server_AlarmManagerService_init。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</span><br><span class="line"></span><br><span class="line">static jlong android_server_AlarmManagerService_init(JNIEnv*, jobject)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化/dev/alarm</span><br><span class="line">    jlong ret = init_alarm_driver();</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果初始化/dev/alarm不成功，则进入timerfd初始化，现一般采用timerfd方式采用</span><br><span class="line">    return init_timerfd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Native Alarm初始化采用了二种方案，AlarmDriver与timerfd，当alarm_driver失败时则使用timerfd，现在基本使用的是timerfd。如下，AlarmImpl是Native层Alarm操作的统一接口，AlarmImplAlarmDriver与AlarmImplTimerFd是AlarmDriver与timerfd二种不同方式的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class AlarmImpl</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AlarmImpl(int *fds, size_t n_fds);</span><br><span class="line">    virtual ~AlarmImpl();</span><br><span class="line"></span><br><span class="line">    virtual int set(int type, struct timespec *ts) = 0;</span><br><span class="line">    virtual int clear(int type, struct timespec *ts) = 0;</span><br><span class="line">    virtual int setTime(struct timeval *tv) = 0;</span><br><span class="line">    virtual int waitForAlarm() = 0;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    int *fds;</span><br><span class="line">    size_t n_fds;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AlarmImplAlarmDriver : public AlarmImpl</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AlarmImplAlarmDriver(int fd) : AlarmImpl(&amp;fd, 1) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    int set(int type, struct timespec *ts);</span><br><span class="line">    int clear(int type, struct timespec *ts);</span><br><span class="line">    int setTime(struct timeval *tv);</span><br><span class="line">    int waitForAlarm();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AlarmImplTimerFd : public AlarmImpl</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AlarmImplTimerFd(int fds[N_ANDROID_TIMERFDS], int epollfd, int rtc_id) :</span><br><span class="line">        AlarmImpl(fds, N_ANDROID_TIMERFDS), epollfd(epollfd), rtc_id(rtc_id) &#123; &#125;</span><br><span class="line">    ~AlarmImplTimerFd();</span><br><span class="line"></span><br><span class="line">    int set(int type, struct timespec *ts);</span><br><span class="line">    int clear(int type, struct timespec *ts);</span><br><span class="line">    int setTime(struct timeval *tv);</span><br><span class="line">    int waitForAlarm();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int epollfd;</span><br><span class="line">    int rtc_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面先看AlarmDriver的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</span><br><span class="line"></span><br><span class="line">static jlong init_alarm_driver()</span><br><span class="line">&#123;</span><br><span class="line">    // 打开/dev/alarm,失败则退出</span><br><span class="line">    int fd = open(&quot;/dev/alarm&quot;, O_RDWR);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        ALOGV(&quot;opening alarm driver failed: %s&quot;, strerror(errno));</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据fd创建AlarmImplAlarmDriver对象</span><br><span class="line">    AlarmImpl *ret = new AlarmImplAlarmDriver(fd);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int AlarmImplAlarmDriver::set(int type, struct timespec *ts)</span><br><span class="line">&#123;</span><br><span class="line">    return ioctl(fds[0], ANDROID_ALARM_SET(type), ts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int AlarmImplAlarmDriver::clear(int type, struct timespec *ts)</span><br><span class="line">&#123;</span><br><span class="line">    return ioctl(fds[0], ANDROID_ALARM_CLEAR(type), ts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int AlarmImplAlarmDriver::setTime(struct timeval *tv)</span><br><span class="line">&#123;</span><br><span class="line">    struct timespec ts;</span><br><span class="line">    int res;</span><br><span class="line"></span><br><span class="line">    ts.tv_sec = tv-&gt;tv_sec;</span><br><span class="line">    ts.tv_nsec = tv-&gt;tv_usec * 1000;</span><br><span class="line">    res = ioctl(fds[0], ANDROID_ALARM_SET_RTC, &amp;ts);</span><br><span class="line">    if (res &lt; 0)</span><br><span class="line">        ALOGV(&quot;ANDROID_ALARM_SET_RTC ioctl failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int AlarmImplAlarmDriver::waitForAlarm()</span><br><span class="line">&#123;</span><br><span class="line">    return ioctl(fds[0], ANDROID_ALARM_WAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AlarmImplAlarmDriver中主要通过ioctl来实现Alarm的操作。当init_alarm_driver打开/dev/alarm失败时，选择timerfd实现Alarm的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</span><br><span class="line"></span><br><span class="line">static const size_t N_ANDROID_TIMERFDS = ANDROID_ALARM_TYPE_COUNT + 1;</span><br><span class="line">static const clockid_t android_alarm_to_clockid[N_ANDROID_TIMERFDS] = &#123;</span><br><span class="line">    CLOCK_REALTIME_ALARM,</span><br><span class="line">    CLOCK_REALTIME,</span><br><span class="line">    CLOCK_BOOTTIME_ALARM,</span><br><span class="line">    CLOCK_BOOTTIME,</span><br><span class="line">    CLOCK_MONOTONIC,</span><br><span class="line">    CLOCK_POWEROFF_ALARM,</span><br><span class="line">    CLOCK_REALTIME,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static jlong init_timerfd()</span><br><span class="line">&#123;</span><br><span class="line">    int epollfd;</span><br><span class="line">    int fds[N_ANDROID_TIMERFDS];</span><br><span class="line"></span><br><span class="line">    // 创建epoll句柄，监听N_ANDROID_TIMERFDS个文件描述符</span><br><span class="line">    epollfd = epoll_create(N_ANDROID_TIMERFDS);</span><br><span class="line">    if (epollfd &lt; 0) &#123;</span><br><span class="line">        ALOGV(&quot;epoll_create(%zu) failed: %s&quot;, N_ANDROID_TIMERFDS,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; N_ANDROID_TIMERFDS; i++) &#123;</span><br><span class="line">        // 创建定时器文件</span><br><span class="line">        fds[i] = timerfd_create(android_alarm_to_clockid[i], 0);</span><br><span class="line">        if (fds[i] &lt; 0) &#123;</span><br><span class="line">            ALOGV(&quot;timerfd_create(%u) failed: %s&quot;,  android_alarm_to_clockid[i],</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            close(epollfd);</span><br><span class="line">            for (size_t j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                close(fds[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据fds创建AlarmImplTimerFd对象，AlarmImplTimerFd也继承于AlarmImpl</span><br><span class="line">    AlarmImpl *ret = new AlarmImplTimerFd(fds, epollfd, wall_clock_rtc());</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; N_ANDROID_TIMERFDS; i++) &#123;</span><br><span class="line">        epoll_event event;</span><br><span class="line">        event.events = EPOLLIN | EPOLLWAKEUP;</span><br><span class="line">        event.data.u32 = i;</span><br><span class="line"></span><br><span class="line">        // 将创建的定时器文件列表加入到epoll监听中</span><br><span class="line">        int err = epoll_ctl(epollfd, EPOLL_CTL_ADD, fds[i], &amp;event);</span><br><span class="line">        if (err &lt; 0) &#123;</span><br><span class="line">            ALOGV(&quot;epoll_ctl(EPOLL_CTL_ADD) failed: %s&quot;, strerror(errno));</span><br><span class="line">            delete ret;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct itimerspec spec;</span><br><span class="line">    memset(&amp;spec, 0, sizeof(spec));</span><br><span class="line"></span><br><span class="line">    int err = timerfd_settime(fds[ANDROID_ALARM_TYPE_COUNT],</span><br><span class="line">            TFD_TIMER_ABSTIME | TFD_TIMER_CANCEL_ON_SET, &amp;spec, NULL);</span><br><span class="line">    if (err &lt; 0) &#123;</span><br><span class="line">        ALOGV(&quot;timerfd_settime() failed: %s&quot;, strerror(errno));</span><br><span class="line">        delete ret;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>init_timerfd()中利用epoll+timerfd的方式，创建timerfd文件并加入到epoll监听中，创建的定时器文件中，我们主要使用的是CLOCK_REALTIME_ALARM，CLOCK_BOOTTIME_ALARM，CLOCK_POWEROFF_ALARM，分别对应RTC_WAKEUP(RTC)，ELAPSED_REALTIME_WAKEUP(ELAPSED_REALTIME)，RTC_POWEROFF_WAKEUP。下面具体看一下AlarmImplTimerFd::set设置定时器的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</span><br><span class="line"></span><br><span class="line">int AlarmImplTimerFd::set(int type, struct timespec *ts)</span><br><span class="line">&#123;</span><br><span class="line">    if (type &gt; ANDROID_ALARM_TYPE_COUNT) &#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!ts-&gt;tv_nsec &amp;&amp; !ts-&gt;tv_sec) &#123;</span><br><span class="line">        ts-&gt;tv_nsec = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    /* timerfd interprets 0 = disarm, so replace with a practically</span><br><span class="line">       equivalent deadline of 1 ns */</span><br><span class="line"></span><br><span class="line">    struct itimerspec spec;</span><br><span class="line">    memset(&amp;spec, 0, sizeof(spec));</span><br><span class="line">    memcpy(&amp;spec.it_value, ts, sizeof(spec.it_value));</span><br><span class="line"></span><br><span class="line">    // 直接调用timerfd_settime设置Alarm定时时间</span><br><span class="line">    return timerfd_settime(fds[type], TFD_TIMER_ABSTIME, &amp;spec, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在waitForAlarm中将等待Alarm的到来，下面看AlarmImplTimerFd::waitForAlarm的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp</span><br><span class="line"></span><br><span class="line">int AlarmImplTimerFd::waitForAlarm()</span><br><span class="line">&#123;</span><br><span class="line">    epoll_event events[N_ANDROID_TIMERFDS];</span><br><span class="line"></span><br><span class="line">    // 利用epolle_wait监听定时器的事件</span><br><span class="line">    int nevents = epoll_wait(epollfd, events, N_ANDROID_TIMERFDS, -1);</span><br><span class="line">    if (nevents &lt; 0) &#123;</span><br><span class="line">        return nevents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    // 事件到来，循环读取定时器文件</span><br><span class="line">    for (int i = 0; i &lt; nevents; i++) &#123;</span><br><span class="line">        uint32_t alarm_idx = events[i].data.u32;</span><br><span class="line">        uint64_t unused;</span><br><span class="line">        ssize_t err = read(fds[alarm_idx], &amp;unused, sizeof(unused));</span><br><span class="line">        if (err &lt; 0) &#123;</span><br><span class="line">            if (alarm_idx == ANDROID_ALARM_TYPE_COUNT &amp;&amp; errno == ECANCELED) &#123;</span><br><span class="line">                // 时间改变</span><br><span class="line">                result |= ANDROID_ALARM_TIME_CHANGE_MASK;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 设置result为触发的alarm_idx</span><br><span class="line">            result |= (1 &lt;&lt; alarm_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回结果给AlarmManagerService</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>waitForAlarm中一直在epoll_wait监听等待Alarm fd事件，当事件到来，循环读取定时器文件并向上层返回触发的Alarm index或时间改变事件。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Debug之ANR]]></title>
      <url>http://robinheztto.com/2017/03/08/android-debug-anr/</url>
      <content type="html"><![CDATA[<blockquote>
<p>ANR(Application Not Responding)，即应用程序未响应。AMS与WMS会监控应用程序的执行情况，如果出现长时间未处理的情况，系统就会显示ANR对话框提示用户对应的应用处于无响应状态，提示用户继续等待或强行停止。</p>
</blockquote>
<h1 id="ANR的类型"><a href="#ANR的类型" class="headerlink" title="ANR的类型"></a>ANR的类型</h1><ul>
<li>Input Dispatching Timeout<br>按键或触摸事件在特定时间内(5s)无响应</li>
<li>Broadcast Timeout<br>Broadcast在特定的时间内(10s)无法处理完成</li>
<li>Service Timeout<br>Service在特定的时间内(前台线程20s，后台线程200s)无法处理完成</li>
</ul>
<h1 id="Debug流程"><a href="#Debug流程" class="headerlink" title="Debug流程"></a>Debug流程</h1><blockquote>
<p>ANR发生，对应的应用会收到SIGQUIT异常终止信号，虚拟机会自动在/data/anr/目录下生成trace.txt文件，该文件记录了在发生ANR时刻系统各个线程的执行状态</p>
</blockquote>
<ol>
<li><p>首先根据event log与main log判断确定ANR发生的时间，进程，类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Event log搜索关键字&quot;am_anr&quot;</span><br><span class="line">可以发现PID为12618的com.protruly.music在11-25 16:26:50.248时间点出现了Input dispatching timed out类型的ANR</span><br><span class="line">11-25 16:26:50.248  3544  3572 I am_anr  : [0,12618,com.protruly.music,950582884,Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)]</span><br><span class="line"></span><br><span class="line">Main log中搜索关键字&quot;ANR in&quot;</span><br><span class="line">可以发现Event log中同样的信息，并且可以看到ANR发生时CPU的负载信息，查看user，kernel，iowait的CPU占用是否出现异常导致ANR</span><br><span class="line">11-25 16:26:53.530  3544  3572 I Process : Sending signal. PID: 13582 SIG: 3</span><br><span class="line">11-25 16:26:53.531 13582 13588 I art     : Thread[3,tid=13588,WaitingInMainSignalCatcherLoop,Thread*=0xe52c0800,peer=0x12c48af0,&quot;Signal Catcher&quot;]: reacting to signal 3</span><br><span class="line">11-25 16:26:53.531 13582 13588 I art     :</span><br><span class="line">11-25 16:26:53.713 13582 13588 I art     : Wrote stack traces to &apos;/data/anr/traces.txt&apos;</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager: ANR in com.protruly.music (com.protruly.music/.ui.HBPlayerActivity)</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager: PID: 12618</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager: Reason: Input dispatching timed out (Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.)</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager: Load: 6.56 / 6.01 / 5.65</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager: CPU usage from 42413ms to 0ms ago (2017-11-25 16:26:07.788 to 2017-11-25 16:26:50.201):</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   23% 709/surfaceflinger: 12% user + 11% kernel / faults: 6408 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   12% 2792/media.codec: 3.4% user + 9% kernel / faults: 2980 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   10% 3544/system_server: 7.2% user + 3.5% kernel / faults: 5379 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   9.3% 576/logd: 3.9% user + 5.4% kernel / faults: 8 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   9.2% 4541/com.android.systemui: 6.8% user + 2.4% kernel / faults: 24806 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   7.3% 2787/audioserver: 3.7% user + 3.6% kernel / faults: 1178 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   4.9% 5264/com.android.incallui: 3% user + 1.8% kernel / faults: 271 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   3.4% 13380/screenrecord: 1.4% user + 1.9% kernel / faults: 1119 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   2.9% 2795/mediaserver: 1.8% user + 1.1% kernel / faults: 2955 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   2.8% 361/irq/329-fts_ts: 0% user + 2.8% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   2.5% 7288/kworker/u16:31: 0% user + 2.5% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   2.2% 10709/kworker/u16:17: 0% user + 2.2% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   2.1% 10712/kworker/u16:18: 0% user + 2.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   1.6% 77/lpass_smem_glin: 0% user + 1.6% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   1.6% 10707/kworker/u16:16: 0% user + 1.6% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   1.4% 13264/logcat: 0.6% user + 0.7% kernel / faults: 5 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   1.4% 13277/logcat: 0.6% user + 0.7% kernel / faults: 5 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   1% 12342/mdss_fb0: 0% user + 1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.9% 7664/kworker/0:5: 0% user + 0.9% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.2% 13864/kworker/u16:14: 0% user + 0.2% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.8% 532/msm-core:sampli: 0% user + 0.8% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.8% 9905/kworker/2:4: 0% user + 0.8% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.7% 76/smem_native_lpa: 0% user + 0.7% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.6% 2794/media.extractor: 0.3% user + 0.3% kernel / faults: 539 minor 1 major</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.6% 10963/kworker/1:5: 0% user + 0.6% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.6% 11053/kworker/3:2: 0% user + 0.6% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.5% 5250/com.android.nfc: 0.2% user + 0.3% kernel / faults: 358 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.5% 12618/com.protruly.music: 0.3% user + 0.2% kernel / faults: 1037 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.5% 4854/com.android.phone: 0.4% user + 0% kernel / faults: 363 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.4% 80/smem_native_rpm: 0% user + 0.4% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.4% 13269/inputlog: 0.2% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.4% 302/irq/497-i2c_pmi: 0% user + 0.4% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.3% 461/cfinteractive: 0% user + 0.3% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 2899/wtemonitor: 0% user + 0% kernel / faults: 42 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.3% 5955/com.android.dlauncher: 0.3% user + 0% kernel / faults: 1655 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.3% 13788/com.android.bluetooth: 0.1% user + 0.2% kernel / faults: 94 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 6562/com.wingtech.logupload: 0% user + 0% kernel / faults: 389 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.2% 7/rcu_preempt: 0% user + 0.2% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.2% 5776/com.hb.netmanage: 0.2% user + 0% kernel / faults: 549 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.2% 20490/kworker/0:2: 0% user + 0.2% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.2% 96/system: 0% user + 0.2% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.2% 3/ksoftirqd/0: 0% user + 0.2% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.2% 13287/lognode: 0% user + 0.2% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 708/servicemanager: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 4435/cds_mc_thread: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 4838/.dataservices: 0.1% user + 0% kernel / faults: 261 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 8/rcu_sched: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 10/rcuop/0: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 14389/wcnss_filter: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 25/rcuop/2: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 4465/com.hmb.manager: 0% user + 0% kernel / faults: 248 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 10713/kworker/u16:20: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 22/ksoftirqd/2: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 29/ksoftirqd/3: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 5236/com.wing.safemgr: 0% user + 0% kernel / faults: 237 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 5278/com.protruly.powermanager: 0% user + 0% kernel / faults: 249 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 10877/kworker/u16:23: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 11698/com.moji.daling: 0% user + 0% kernel / faults: 378 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0.1% 29229/kworker/3:3: 0% user + 0.1% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 499/irq/746-ima-rdy: 0% user + 0% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 614/debuggerd64: 0% user + 0% kernel / faults: 64 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 2766/jbd2/dm-1-8: 0% user + 0% kernel</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 5319/com.quicinc.wbcserviceapp: 0% user + 0% kernel / faults: 237 minor</span><br><span class="line">11-25 16:26:53.715  3544  3572 E ActivityManager:   0% 5334/com.qualcomm.qti.services.secureui:sui_service: 0% user + 0%</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析/data/anr/trace.txt文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在trace.txt文件中，最上面二行标志这pid为12618的com.protruly.music出现ANR，在该进程中出现ANR的概率比较大(但也可能受到其他问题的影响)</span><br><span class="line"></span><br><span class="line">----- pid 12618 at 2017-11-25 16:26:50 -----</span><br><span class="line">Cmd line: com.protruly.music</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一般在主线程中出现ANR的概率较大，callstack</p>
<ol>
<li>如果trace.txt中不能定位问题，继续分析mainlog与eventlog，过滤pid信息，跟踪ANR时间点前进程的活动。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android AMS系列之进程管理]]></title>
      <url>http://robinheztto.com/2017/01/05/android-ams-process/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之SystemService]]></title>
      <url>http://robinheztto.com/2016/12/20/android-systemservice/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android系统中，大部分的系统服务都运行在SystemServer中，且基本上都继承于SystemService(除AMS,PMS等特例外)，本篇具体分析SystemService。相关代码在以下文件中：<br>frameworks/base/services/core/java/com/android/server/SystemService.java<br>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java<br>frameworks/base/core/java/com/android/server/LocalServices.java<br>frameworks/base/services/java/com/android/server/SystemServer.java<br>frameworks/base/core/java/android/app/SystemServiceRegistry.java<br>frameworks/base/core/java/android/content/Context.java<br>frameworks/base/core/java/android/app/ContextImpl.java</p>
</blockquote>
<h1 id="SystemService"><a href="#SystemService" class="headerlink" title="SystemService"></a>SystemService</h1><p>SystemService是一个抽象类，具体的系统服务继承并实现其抽象方法，在SystemService中定义了<code>Boot Phases</code>启动阶段及系统服务启动与事件的回调。下面首先看一下<code>Boot Phases</code>的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/SystemService.java</span><br><span class="line"></span><br><span class="line">public abstract class SystemService &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 创建ActivityManagerService，PowerManagerService，LightsService，</span><br><span class="line">   * DisplayManagerService之后，PackageManagerService之前.</span><br><span class="line">   */  </span><br><span class="line">  public static final int PHASE_WAIT_FOR_DEFAULT_DISPLAY = 100;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 创建PackageManagerService，WindowManagerService等等诸多服务.</span><br><span class="line">   */</span><br><span class="line">  public static final int PHASE_LOCK_SETTINGS_READY = 480;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * PHASE_LOCK_SETTINGS_READY到PHASE_SYSTEM_SERVICES_READY之间无任何操作，PHASE_SYSTEM_SERVICES_READY之后，</span><br><span class="line">   *　系统服务（例如PowerManager，PackageManager等等）能够被调用.</span><br><span class="line">   */</span><br><span class="line">  public static final int PHASE_SYSTEM_SERVICES_READY = 500;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * ActivityManagerService ready.</span><br><span class="line">   */</span><br><span class="line">  public static final int PHASE_ACTIVITY_MANAGER_READY = 550;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 启动SystemUI，Watchdog，services能够start/bind三方应用，App能够通过Binder调用系统服务.</span><br><span class="line">   */</span><br><span class="line">  public static final int PHASE_THIRD_PARTY_APPS_CAN_START = 600;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 启动完成，系统服务执行PHASE_BOOT_COMPLETED回调比注册ACTION_BOOT_COMPLETED广播能减低延迟.</span><br><span class="line">   */</span><br><span class="line">  public static final int PHASE_BOOT_COMPLETED = 1000;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面继续看SystemService中定义的方法，主要是系统服务生命周期/系统事件的回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构造方法，初始化system server context.</span><br><span class="line"> *</span><br><span class="line"> * @param context The system server context.</span><br><span class="line"> */</span><br><span class="line">public SystemService(Context context) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取system context.</span><br><span class="line"> */</span><br><span class="line">public final Context getContext() &#123;</span><br><span class="line">    return mContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否是安全模式.</span><br><span class="line"> */</span><br><span class="line">public final boolean isSafeMode() &#123;</span><br><span class="line">    return getManager().isSafeMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在构造方法后调用.</span><br><span class="line"> */</span><br><span class="line">public abstract void onStart();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 不同BootPhase阶段的回调.</span><br><span class="line"> */</span><br><span class="line">public void onBootPhase(int phase) &#123;&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Publish the service到ServiceManager，对其他进程提供binder服务.</span><br><span class="line"> */</span><br><span class="line">protected final void publishBinderService(String name, IBinder service) &#123;</span><br><span class="line">    publishBinderService(name, service, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Publish the service到ServiceManager，对其他进程提供binder服务.</span><br><span class="line"> */</span><br><span class="line">protected final void publishBinderService(String name, IBinder service,</span><br><span class="line">        boolean allowIsolated) &#123;</span><br><span class="line">    ServiceManager.addService(name, service, allowIsolated);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过服务名获取binder服务.</span><br><span class="line"> */</span><br><span class="line">protected final IBinder getBinderService(String name) &#123;</span><br><span class="line">    return ServiceManager.getService(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Publish service到LocalServices，以供SystemServer进程中的其他服务调用.</span><br><span class="line"> */</span><br><span class="line">protected final &lt;T&gt; void publishLocalService(Class&lt;T&gt; type, T service) &#123;</span><br><span class="line">    LocalServices.addService(type, service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过Class Type从LocalServices中获取服务.</span><br><span class="line"> */</span><br><span class="line">protected final &lt;T&gt; T getLocalService(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return LocalServices.getService(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从LocalServices中获取SystemServiceManager（SystemServiceManager也被注册到了从LocalServices）.</span><br><span class="line"> */</span><br><span class="line">private SystemServiceManager getManager() &#123;</span><br><span class="line">    return LocalServices.getService(SystemServiceManager.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="SystemServiceManager"><a href="#SystemServiceManager" class="headerlink" title="SystemServiceManager"></a>SystemServiceManager</h1><p>SystemServiceManager用来管理系统服务的生命周期，事件回调等。在SystemServer启动过程中创建SystemServiceManager，并通过SystemServiceManager启动系统服务并根据事件回调其方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line"></span><br><span class="line">private void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ......</span><br><span class="line">        // 在启动系统服务之前，先创建SystemServiceManager并注册到LocalServices中.</span><br><span class="line">        mSystemServiceManager = new SystemServiceManager(mSystemContext);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Start services.</span><br><span class="line">    try &#123;</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SystemServiceManag它的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span><br><span class="line"></span><br><span class="line">public class SystemServiceManager &#123;</span><br><span class="line">    private final Context mContext;</span><br><span class="line">    private boolean mSafeMode;</span><br><span class="line"></span><br><span class="line">    // 系统服务列表.</span><br><span class="line">    private final ArrayList&lt;SystemService&gt; mServices = new ArrayList&lt;SystemService&gt;();</span><br><span class="line"></span><br><span class="line">    private int mCurrentPhase = -1;</span><br><span class="line"></span><br><span class="line">    public SystemServiceManager(Context context) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过className启动系统服务.</span><br><span class="line">     *</span><br><span class="line">     * @return The service instance.</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public SystemService startService(String className) &#123;</span><br><span class="line">        final Class&lt;SystemService&gt; serviceClass;</span><br><span class="line">        try &#123;</span><br><span class="line">            serviceClass = (Class&lt;SystemService&gt;)Class.forName(className);</span><br><span class="line">        &#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">          ......</span><br><span class="line">        &#125;</span><br><span class="line">        return startService(serviceClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建系统服务实例并返回，同时调用其onStart()方法.</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            final String name = serviceClass.getName();</span><br><span class="line">            // Create the service.</span><br><span class="line">            if (!SystemService.class.isAssignableFrom(serviceClass)) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Failed to create &quot; + name</span><br><span class="line">                        + &quot;: service must extend &quot; + SystemService.class.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            final T service;</span><br><span class="line">            try &#123;</span><br><span class="line">                Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">                service = constructor.newInstance(mContext);</span><br><span class="line">            &#125; catch (......) &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Register it.</span><br><span class="line">            mServices.add(service);</span><br><span class="line"></span><br><span class="line">            // Start it.</span><br><span class="line">            try &#123;</span><br><span class="line">                service.onStart();</span><br><span class="line">            &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125;</span><br><span class="line">            return service;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">              ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *　根据boot phase不同阶段，回调系统服务中的onBootPhase()方法．</span><br><span class="line">     * @param phase The boot phase to start.</span><br><span class="line">     */</span><br><span class="line">    public void startBootPhase(final int phase) &#123;</span><br><span class="line">        if (phase &lt;= mCurrentPhase) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Next phase must be larger than previous&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentPhase = phase;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            final int serviceLen = mServices.size();</span><br><span class="line">            for (int i = 0; i &lt; serviceLen; i++) &#123;</span><br><span class="line">                final SystemService service = mServices.get(i);</span><br><span class="line">                try &#123;</span><br><span class="line">                    service.onBootPhase(mCurrentPhase);</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                  ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">              ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    /** 设置安全模式供系统服务查询. */</span><br><span class="line">    public void setSafeMode(boolean safeMode) &#123;</span><br><span class="line">        mSafeMode = safeMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回当前是否是安全模式启动.</span><br><span class="line">     * @return safe mode flag</span><br><span class="line">     */</span><br><span class="line">    public boolean isSafeMode() &#123;</span><br><span class="line">        return mSafeMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="LocalServices"><a href="#LocalServices" class="headerlink" title="LocalServices"></a>LocalServices</h1><p>LocalServices的作用与SystemServiceManager类似，不过LocalService的主要目的是提供系统服务的查询，注册，以供<code>SystemServer进程内部</code>的其他服务调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/com/android/server/LocalServices.java</span><br><span class="line"></span><br><span class="line">public final class LocalServices &#123;</span><br><span class="line">    private LocalServices() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 保存所有系统服务，包过SystemServiceManager    </span><br><span class="line">    private static final ArrayMap&lt;Class&lt;?&gt;, Object&gt; sLocalServiceObjects =</span><br><span class="line">            new ArrayMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取服务</span><br><span class="line">     *</span><br><span class="line">     * @param type The type of service.</span><br><span class="line">     * @return The service object.</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T getService(Class&lt;T&gt; type) &#123;</span><br><span class="line">        synchronized (sLocalServiceObjects) &#123;</span><br><span class="line">            return (T) sLocalServiceObjects.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册服务</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; void addService(Class&lt;T&gt; type, T service) &#123;</span><br><span class="line">        synchronized (sLocalServiceObjects) &#123;</span><br><span class="line">            if (sLocalServiceObjects.containsKey(type)) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;Overriding service registration&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sLocalServiceObjects.put(type, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Context-getSystemService"><a href="#Context-getSystemService" class="headerlink" title="Context.getSystemService"></a>Context.getSystemService</h1><p>系统服务运行在SystemServer进程中，App使用系统服务首先得通过Context.getSystemService()获取系统服务的代理，下面继续看Context.getSystemService()的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/content/Context.java</span><br><span class="line"></span><br><span class="line">public abstract class Context &#123;</span><br><span class="line">    ......</span><br><span class="line">    public abstract Object getSystemService(@ServiceName @NonNull String name);</span><br><span class="line"></span><br><span class="line">    public final &lt;T&gt; T getSystemService(Class&lt;T&gt; serviceClass) &#123;</span><br><span class="line">    String serviceName = getSystemServiceName(serviceClass);</span><br><span class="line">    return serviceName != null ? (T)getSystemService(serviceName) : null;</span><br><span class="line">    &#125;</span><br><span class="line">    ......        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Context.getSystemService()在ContextImpl中具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line"></span><br><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">  ......</span><br><span class="line">  @Override</span><br><span class="line">  public Object getSystemService(String name) &#123;</span><br><span class="line">      return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String getSystemServiceName(Class&lt;?&gt; serviceClass) &#123;</span><br><span class="line">      return SystemServiceRegistry.getSystemServiceName(serviceClass);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p>
<p>ContextImpl中是直接调用SystemServiceRegistry.getSystemService()来获取系统服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/app/SystemServiceRegistry.java</span><br><span class="line"></span><br><span class="line">private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line">        new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">public static Object getSystemService(ContextImpl ctx, String name) &#123;</span><br><span class="line">    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">    return fetcher != null ? fetcher.getService(ctx) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据服务名从SYSTEM_SERVICE_FETCHERS找到服务对应的ServiceFetcher，并通过ServiceFetcher.getService()获取到对应的服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/app/SystemServiceRegistry.java</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    registerService(Context.ACTIVITY_SERVICE, ActivityManager.class,</span><br><span class="line">            new CachedServiceFetcher&lt;ActivityManager&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public ActivityManager createService(ContextImpl ctx) &#123;</span><br><span class="line">            return new ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,</span><br><span class="line">        ServiceFetcher&lt;T&gt; serviceFetcher) &#123;</span><br><span class="line">    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在SystemServiceRegistry中的静态区域中完成了系统服务的注册，serviceName，serviceClass，serviceFetcher保存到SYSTEM_SERVICE_NAMES与SYSTEM_SERVICE_FETCHERS中。下面接着看fetcher.getService(ctx)的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/app/SystemServiceRegistry.java</span><br><span class="line"></span><br><span class="line">static abstract interface ServiceFetcher&lt;T&gt; &#123;</span><br><span class="line">    T getService(ContextImpl ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123;</span><br><span class="line">    private final int mCacheIndex;</span><br><span class="line"></span><br><span class="line">    public CachedServiceFetcher() &#123;</span><br><span class="line">        mCacheIndex = sServiceCacheSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public final T getService(ContextImpl ctx) &#123;</span><br><span class="line">        final Object[] cache = ctx.mServiceCache;</span><br><span class="line">        synchronized (cache) &#123;</span><br><span class="line">            // Fetch or create the service.</span><br><span class="line">            Object service = cache[mCacheIndex];</span><br><span class="line">            if (service == null) &#123;</span><br><span class="line">                service = createService(ctx);</span><br><span class="line">                cache[mCacheIndex] = service;</span><br><span class="line">            &#125;</span><br><span class="line">            return (T)service;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract T createService(ContextImpl ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据前面静态区域注册服务代码可知，注册服务时创建CachedServiceFetcher并实现了其createService方法，当通过fetcher.getService(ctx)获取服务时，首先判断cache中是否存在缓存的对象，如果没有，则调用createService()创建服务代理对象并返回，至此，APP就获取到了系统服务代理对象，通过该代理就可以调用各种系统服务了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之SystemServer启动(下)]]></title>
      <url>http://robinheztto.com/2016/11/28/android-systemserver-2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>上篇已经分析了SystemServer进程的创建过程，在ZygoteInit.main() catch MethodAndArgsCaller异常后，将执行MethodAndArgsCaller.run并反射SystemServer.main()方法，下面将从SystemServer.main()开始分析。<br>相关的源代码在以下文件中：</p>
<ul>
<li>frameworks/base/services/java/com/android/server/SystemServer.java</li>
<li>frameworks/base/core/java/android/app/ActivityThread.java</li>
<li>frameworks/base/core/java/android/app/ContextImpl.java</li>
</ul>
</blockquote>
<h1 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main()"></a>SystemServer.main()</h1><p>SystemServer.main()的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The main entry point from zygote.</span><br><span class="line"> */</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SystemServer() &#123;</span><br><span class="line">    // Check for factory test mode.</span><br><span class="line">    mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main()中创建SystemServer对象并调用其run()方法，run()的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line"></span><br><span class="line">// system_server进程binder线程池最大线程数</span><br><span class="line">private static final int sMaxBinderThreads = 31;</span><br><span class="line"></span><br><span class="line">private void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;InitBeforeStartServices&quot;);</span><br><span class="line">        // 如果系统时间早于1970年，调整为1970年</span><br><span class="line">        if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</span><br><span class="line">            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置language相关属性</span><br><span class="line">        if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</span><br><span class="line">            final String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">            SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Here we go!</span><br><span class="line">        Slog.i(TAG, &quot;Entered the Android system server!&quot;);</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">        // 设置persist.sys.dalvik.vm.lib.2属性值为当前虚拟机运行库，默认libart.so</span><br><span class="line">        SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">        // 开启sampling profiler.</span><br><span class="line">        if (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">            SamplingProfilerIntegration.start();</span><br><span class="line">            mProfilerSnapshotTimer = new Timer();</span><br><span class="line">            mProfilerSnapshotTimer.schedule(new TimerTask() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 清除VM内存增长上限</span><br><span class="line">        VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">        // 设置VM堆内存利用率为0.8</span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</span><br><span class="line"></span><br><span class="line">        // Some devices rely on runtime fingerprint generation, so make sure</span><br><span class="line">        // we&apos;ve defined it before booting further.</span><br><span class="line">        Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">        // 设置需指定用户访问环境变量</span><br><span class="line">        Environment.setUserRequired(true);</span><br><span class="line"></span><br><span class="line">        // Within the system server, any incoming Bundles should be defused</span><br><span class="line">        // to avoid throwing BadParcelableException.</span><br><span class="line">        BaseBundle.setShouldDefuse(true);</span><br><span class="line"></span><br><span class="line">        // 确保binder调用运行在前台优先级(foreground priority)</span><br><span class="line">        BinderInternal.disableBackgroundScheduling(true);</span><br><span class="line"></span><br><span class="line">        // 设置system_server binder线程池最大线程数为sMaxBinderThreads</span><br><span class="line">        BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br><span class="line"></span><br><span class="line">        // 主线程的Looper在当前线程中循环</span><br><span class="line">        android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        android.os.Process.setCanSelfBackground(false);</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        // 加载libandroid_servers.so(对应源码frameworks/base/services/core/jni/)，初始化本地服务</span><br><span class="line">        System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line"></span><br><span class="line">        // Check whether we failed to shut down last time we tried.</span><br><span class="line">        // This call may not return.</span><br><span class="line">        performPendingShutdown();</span><br><span class="line"></span><br><span class="line">        // 获取系统Context，后面具体分析</span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        // 创建SystemServiceManager，用于启动系统服务</span><br><span class="line">        mSystemServiceManager = new SystemServiceManager(mSystemContext);</span><br><span class="line">        // 将SystemServiceManager也添加到LocalServices中管理</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动服务</span><br><span class="line">    try &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;StartServices&quot;);</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // debug版本log输出到dropbox</span><br><span class="line">    if (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">        Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 消息队列循环.</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>run()中主要完成相关的初始化工作，启动系统服务，随后进入到消息队列的循环中。下面将具体分析一下createSystemContext()与启动服务的过程。</p>
<h1 id="createSystemContext"><a href="#createSystemContext" class="headerlink" title="createSystemContext()"></a>createSystemContext()</h1><p>createSystemContext()的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line"></span><br><span class="line">private void createSystemContext() &#123;</span><br><span class="line">    ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">    mSystemContext = activityThread.getSystemContext();</span><br><span class="line">    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>createSystemContext()中创建了ActivityThread对象，并通过其getSystemContext获取系统Context，然后通过系统Context设置主题，接下来一步步分析此过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public static ActivityThread systemMain() &#123;</span><br><span class="line">    // The system process on low-memory devices do not get to use hardware</span><br><span class="line">    // accelerated drawing, since this can add too much overhead to the</span><br><span class="line">    // process.</span><br><span class="line">    if (!ActivityManager.isHighEndGfx()) &#123;</span><br><span class="line">        HardwareRenderer.disable(true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        HardwareRenderer.enableForegroundTrimming();</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(true);</span><br><span class="line">    return thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ActivityThread.systemMain()中创建ActivityThread对象并调用其attch方法，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">ActivityThread() &#123;</span><br><span class="line">    mResourcesManager = ResourcesManager.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    if (!system) &#123;</span><br><span class="line">    ......  </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 设置DDMS中名称</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;,</span><br><span class="line">                UserHandle.myUserId());</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建Instrumentation对象   </span><br><span class="line">            mInstrumentation = new Instrumentation();</span><br><span class="line">            // 通过ContextImpl创建context对象</span><br><span class="line">            ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                    this, getSystemContext().mPackageInfo);</span><br><span class="line">            // 创建Application对象并调用onCreate()方法                    </span><br><span class="line">            mInitialApplication = context.mPackageInfo.makeApplication(true, null);</span><br><span class="line">            mInitialApplication.onCreate();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate Application():&quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // add dropbox logging to libcore</span><br><span class="line">    DropBox.setReporter(new DropBoxReporter());</span><br><span class="line"></span><br><span class="line">    ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123;</span><br><span class="line">        public void onConfigurationChanged(Configuration newConfig) &#123;...&#125;</span><br><span class="line">        public void onLowMemory() &#123;...&#125;</span><br><span class="line">        public void onTrimMemory(int level) &#123;...&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ActivityThread的attach方法中通过getSystemContext获取系统Context对象，getSystemContext的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public ContextImpl getSystemContext() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mSystemContext == null) &#123;</span><br><span class="line">            mSystemContext = ContextImpl.createSystemContext(this);</span><br><span class="line">        &#125;</span><br><span class="line">        return mSystemContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt; frameworks/base/core/java/android/app/ContextImpl.java</span><br><span class="line"></span><br><span class="line">static ContextImpl createSystemContext(ActivityThread mainThread) &#123;</span><br><span class="line">    LoadedApk packageInfo = new LoadedApk(mainThread);</span><br><span class="line">    ContextImpl context = new ContextImpl(null, mainThread,</span><br><span class="line">            packageInfo, null, null, false, null, null, Display.INVALID_DISPLAY);</span><br><span class="line">    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(),</span><br><span class="line">            context.mResourcesManager.getDisplayMetricsLocked());</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt; frameworks/base/core/java/android/app/LoadedApk.java</span><br><span class="line"></span><br><span class="line">LoadedApk(ActivityThread activityThread) &#123;</span><br><span class="line">    mActivityThread = activityThread;</span><br><span class="line">    mApplicationInfo = new ApplicationInfo();</span><br><span class="line">    // packageName设置成android</span><br><span class="line">    mApplicationInfo.packageName = &quot;android&quot;;</span><br><span class="line">    mPackageName = &quot;android&quot;;</span><br><span class="line">    mAppDir = null;</span><br><span class="line">    mResDir = null;</span><br><span class="line">    mSplitAppDirs = null;</span><br><span class="line">    mSplitResDirs = null;</span><br><span class="line">    mOverlayDirs = null;</span><br><span class="line">    mSharedLibraries = null;</span><br><span class="line">    mDataDir = null;</span><br><span class="line">    mDataDirFile = null;</span><br><span class="line">    mLibDir = null;</span><br><span class="line">    mBaseClassLoader = null;</span><br><span class="line">    mSecurityViolation = false;</span><br><span class="line">    mIncludeCode = true;</span><br><span class="line">    mRegisterPackage = false;</span><br><span class="line">    mClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">    mResources = Resources.getSystem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getSystemContext()中调用ContextImpl.createSystemContext()创建了ContextImpl对象，以获取类似apk的Context上下文环境，在创建ContextImpl同时也需要LoadedApk对象，对应framework-res.apk，PackageName命名为android。</p>
<h1 id="StartServices"><a href="#StartServices" class="headerlink" title="StartServices"></a>StartServices</h1><p>SystemServer分成三类启动服务，分别时Bootstrap，Core，Other，首先分析startBootstrapServices启动Bootstrap服务流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    // 等待与installd建立socket通信</span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    // 启动ActivityManagerService</span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    // 启动PowerManagerService</span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line"></span><br><span class="line">    // 初始化PowerManagement</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    // 启动LightsService</span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">    // 启动DisplayManagerService</span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    // Phase100阶段</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    // 当设备加密时仅仅运行core</span><br><span class="line">    String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">    if (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</span><br><span class="line">        mOnlyCore = true;</span><br><span class="line">    &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</span><br><span class="line">        mOnlyCore = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动PackageManagerService</span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    // Manages A/B OTA dexopting. This is a bootstrap service as we need it to rename</span><br><span class="line">    // A/B artifacts after boot, before anything else might touch/need them.</span><br><span class="line">    // Note: this isn&apos;t needed during decryption (we don&apos;t have /data anyways).</span><br><span class="line">    if (!mOnlyCore) &#123;</span><br><span class="line">        boolean disableOtaDexopt = SystemProperties.getBoolean(&quot;config.disable_otadexopt&quot;,</span><br><span class="line">                false);</span><br><span class="line">        if (!disableOtaDexopt) &#123;</span><br><span class="line">            traceBeginAndSlog(&quot;StartOtaDexOptService&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                reportWtf(&quot;starting OtaDexOptService&quot;, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动UserManagerService</span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle.class);</span><br><span class="line"></span><br><span class="line">    // Initialize attribute cache used to cache resources from packages.</span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    // Set up the Application instance for the system process and get started.</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    // 启动SensorService</span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>startBootstrapServices()中主要启动了ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">    // 启动BatteryService(Tracks the battery level.  Requires LightService)</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    // 启动UsageStatsService</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line">    // Update after UsageStatsService is available, needed before performBootDexOpt.</span><br><span class="line">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line"></span><br><span class="line">    // 启动WebViewUpdateService</span><br><span class="line">    mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>startCoreServices()中主要启动了BatteryService，UsageStatsService，WebViewUpdateService。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之SystemServer启动(上)]]></title>
      <url>http://robinheztto.com/2016/11/28/android-systemserver-1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>SystemServer是Android Framework的核心，大部分的Android系统核心服务都运行在SystemServer进程当中。此篇博客主要分析SystemServer的进程创建流程，下篇分析SystemServer的初始化流程，相关的源代码在以下文件中：</p>
<ul>
<li>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</li>
<li>frameworks/base/core/java/com/android/internal/os/Zygote.java</li>
<li>frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</li>
<li>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</li>
<li>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</li>
<li>frameworks/base/core/jni/AndroidRuntime.cpp</li>
<li>frameworks/base/cmds/app_process/app_main.cpp</li>
</ul>
</blockquote>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>SystemServer(system_server进程)是通过Zygote fork生成的，如下init.zygote32.rc/init.zygote64_32.rc中的定义，参数<code>--start-system-server</code>指定了Zygote启动SystemServer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks /sys/fs/cgroup/stune/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary</span><br><span class="line">    class main</span><br><span class="line">    socket zygote_secondary stream 660 root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USER      PID   PPID  VSIZE  RSS   WCHAN              PC  NAME</span><br><span class="line">root      1     0     16980  2636  SyS_epoll_ 0000500ab0 S /init</span><br><span class="line">root      929   1     2166716 82876 poll_sched 7f8efff61c S zygote64</span><br><span class="line">system    1695  929   2488940 152772 SyS_epoll_ 7f8efff4fc S system_server</span><br></pre></td></tr></table></figure>
<p>SystemServer的启动流程大概可以分为二个阶段，第一阶段Zygote fork system_server进程，第二阶段执行SystemServer类，进行系统服务的启动及初始化，此篇博客分析SystemServer进程创建过程，下篇分析系统服务启动初始化过程。Zygote fork SystemServer的流程如下图示：</p>
<div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/android_systemserver_init_flow.jpg?raw=true" alt="android_systemserver_init_flow"><br></div>

<h1 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h1><p>ZygoteInit.main()通过解析argv[]参数列表来确定是否启动SystemServer，如果有定义参数<code>--start-system-server</code>则启动调用startSystemServer启动SystemServer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean startSystemServer = false;</span><br><span class="line">        ......</span><br><span class="line">        for (int i = 1; i &lt; argv.length; i++) &#123;</span><br><span class="line">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = true;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ZygoteInit-startSystemServer"><a href="#ZygoteInit-startSystemServer" class="headerlink" title="ZygoteInit.startSystemServer()"></a>ZygoteInit.startSystemServer()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line">private static boolean startSystemServer(String abiList, String socketName)</span><br><span class="line">        throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">    long capabilities = posixCapabilitiesAsBits(</span><br><span class="line">        OsConstants.CAP_IPC_LOCK,</span><br><span class="line">        OsConstants.CAP_KILL,</span><br><span class="line">        OsConstants.CAP_NET_ADMIN,</span><br><span class="line">        OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">        OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">        OsConstants.CAP_NET_RAW,</span><br><span class="line">        OsConstants.CAP_SYS_MODULE,</span><br><span class="line">        OsConstants.CAP_SYS_NICE,</span><br><span class="line">        OsConstants.CAP_SYS_RESOURCE,</span><br><span class="line">        OsConstants.CAP_SYS_TIME,</span><br><span class="line">        OsConstants.CAP_SYS_TTY_CONFIG</span><br><span class="line">    );</span><br><span class="line">    /* Containers run without this capability, so avoid setting it in that case */</span><br><span class="line">    if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) &#123;</span><br><span class="line">        capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);</span><br><span class="line">    &#125;</span><br><span class="line">    /* Hardcoded command line to start the system server */</span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        &quot;--setuid=1000&quot;,</span><br><span class="line">        &quot;--setgid=1000&quot;,</span><br><span class="line">        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010&quot;,</span><br><span class="line">        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,</span><br><span class="line">        &quot;--nice-name=system_server&quot;,</span><br><span class="line">        &quot;--runtime-args&quot;,</span><br><span class="line">        &quot;com.android.server.SystemServer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = null;</span><br><span class="line"></span><br><span class="line">    int pid;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 准备执行参数</span><br><span class="line">        parsedArgs = new ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        // fork SystemServer并返回进程id</span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                null,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 子进程即system_server进程中执行handleSystemServerProcess</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startSystemServer中，首先为SystemServer准备启动参数，指定uid，gid为1000，进程名为“system_server”，并指定执行类为“com.android.server.SystemServer”。然后执行Zygote.forkSystemServer() fork出进程，Zygote fork完成后将在子进程<code>system_server</code>中继续执行handleSystemServerProcess()。</p>
<h1 id="Zygote-forkSystemServer"><a href="#Zygote-forkSystemServer" class="headerlink" title="Zygote.forkSystemServer()"></a>Zygote.forkSystemServer()</h1><p>forkSystemServer()继续调用native方法nativeForkSystemServer()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/com/android/internal/os/Zygote.java</span><br><span class="line"></span><br><span class="line">public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,</span><br><span class="line">        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123;</span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    int pid = nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    // Enable tracing as soon as we enter the system_server.</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        Trace.setTracingEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与fork普通应用进程实现一样，nativeForkSystemServer在frameworks/base/core/jni/com_android_internal_os_Zygote.cpp中实现，映射关联到com_android_internal_os_Zygote_nativeForkSystemServer()</p>
<h1 id="nativeForkSystemServer"><a href="#nativeForkSystemServer" class="headerlink" title="nativeForkSystemServer()"></a>nativeForkSystemServer()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span><br><span class="line"></span><br><span class="line">&#123; &quot;nativeForkSystemServer&quot;, &quot;(II[II[[IJJ)I&quot;,</span><br><span class="line">  (void *) com_android_internal_os_Zygote_nativeForkSystemServer &#125;,</span><br><span class="line"></span><br><span class="line">static jint com_android_internal_os_Zygote_nativeForkSystemServer(</span><br><span class="line">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span><br><span class="line">        jlong effectiveCapabilities) &#123;</span><br><span class="line">  // 与fork普通应用进程一样调用ForkAndSpecializeCommon创建出子进程</span><br><span class="line">  pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities, effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,</span><br><span class="line">                                      NULL, NULL);</span><br><span class="line">  if (pid &gt; 0) &#123;</span><br><span class="line">      // 保存system_server进程pid</span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line"></span><br><span class="line">      int status;</span><br><span class="line">      // 判断system_server是否启动成功，不成功则重启zygote</span><br><span class="line">      if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          ALOGE(&quot;System server process %d has died. Restarting Zygote!&quot;, pid);</span><br><span class="line">          RuntimeAbort(env, __LINE__, &quot;System server process has died. Restarting Zygote!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与创建普通进程的执行流程一样，com_android_internal_os_Zygote_nativeForkSystemServer()最终也是通过调用ForkAndSpecializeCommon()来创建system_server进程，然后执行waitpid来判断system_server是否退出(WNOHANG-若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若结束，则返回该子进程的ID)，如果返回了system_server的pid说明system_server启动失败，Zygote执行RuntimeAbort自杀，然后通过Init重启Zygote与system_server。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span><br><span class="line"></span><br><span class="line">// Utility routine to fork zygote and specialize the child process.</span><br><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span><br><span class="line">                                     jint debug_flags, jobjectArray javaRlimits,</span><br><span class="line">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span><br><span class="line">                                     jint mount_external,</span><br><span class="line">                                     jstring java_se_info, jstring java_se_name,</span><br><span class="line">                                     bool is_system_server, jintArray fdsToClose,</span><br><span class="line">                                     jstring instructionSet, jstring dataDir) &#123;                               </span><br><span class="line">　SetSigChldHandler();　//设置SIGCHLD处理函数SigChldHandler</span><br><span class="line">  ......                      </span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  if (pid == 0) &#123;</span><br><span class="line">    // The child process.</span><br><span class="line">    ......</span><br><span class="line">  &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">    // the parent process</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ForkAndSpecializeCommon中通过设置SetSigChldHandler接收子进程退出的消息，如果接收到gSystemServerPid退出，那么Zygote将自杀，然后通过Init重启Zygote与system_server。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span><br><span class="line"></span><br><span class="line">static void SigChldHandler(int /*signal_number*/) &#123;</span><br><span class="line">  pid_t pid;</span><br><span class="line">　......</span><br><span class="line">  while ((pid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) &#123;</span><br><span class="line">    ......</span><br><span class="line">    // If the just-crashed process is the system_server, bring down zygote</span><br><span class="line">    // so that it is restarted by init and system server will be restarted</span><br><span class="line">    // from there.</span><br><span class="line">    if (pid == gSystemServerPid) &#123;</span><br><span class="line">      ALOGE(&quot;Exit zygote because system server (%d) has terminated&quot;, pid);</span><br><span class="line">      kill(getpid(), SIGKILL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在ForkAndSpecializeCommon中fork出子进程systemServer后，父子进程返回继续执行，子进程(pid == 0)继续执行handleSystemServerProcess。</p>
<h1 id="Zygote-handleSystemServerProcess"><a href="#Zygote-handleSystemServerProcess" class="headerlink" title="Zygote.handleSystemServerProcess()"></a>Zygote.handleSystemServerProcess()</h1><p>在Zygote成功fork出子进程后，将在子进程system_server中执行handleSystemServerProcess()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line">private static void handleSystemServerProcess(</span><br><span class="line">        ZygoteConnection.Arguments parsedArgs)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    //关闭继承自父进程zygote的Socket</span><br><span class="line">    closeServerSocket();</span><br><span class="line"></span><br><span class="line">    //umask 0077后system_server创建的文件属性为0700</span><br><span class="line">    Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line"></span><br><span class="line">    //设置进程名&quot;system_server&quot;,ps可以看到这个进程名</span><br><span class="line">    if (parsedArgs.niceName != null) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);　</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取环境变量SYSTEMSERVERCLASSPATH</span><br><span class="line">    //SYSTEMSERVERCLASSPATH=/system/framework/services.jar:/system/framework/ethernet-service.jar:/system/framework/wifi-service.jar:/system/framework/container-service.jar</span><br><span class="line">    final String systemServerClasspath = Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">    if (systemServerClasspath != null) &#123;</span><br><span class="line">        // 创建与installd的socket连接，对systemServerClasspath执行dex优化操作</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith != null) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ClassLoader cl = null;</span><br><span class="line">        // 创建systemServer ClassLoader</span><br><span class="line">        if (systemServerClasspath != null) &#123;</span><br><span class="line">            cl = createSystemServerClassLoader(systemServerClasspath,</span><br><span class="line">                                               parsedArgs.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Pass the remaining arguments to SystemServer.</span><br><span class="line">         */</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* should never reach here */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>handleSystemServerProcess()中在关闭Zygote中复制而来的socket，设置进程名，并继续执行RuntimeInit.zygoteInit()。</p>
<h1 id="RuntimeInit-zygoteInit"><a href="#RuntimeInit-zygoteInit" class="headerlink" title="RuntimeInit.zygoteInit()"></a>RuntimeInit.zygoteInit()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span><br><span class="line"></span><br><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line"></span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zygoteInit()中主要执行初始化相关的工作，最后将调到startClas(SystemServer)的main方法。commonInit中主要设置了默认的未捕获异常处理方法，timezone等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span><br><span class="line"></span><br><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    // 设置Default未捕捉异常处理方法</span><br><span class="line">    /* set default handler; this applies to all threads in the VM */</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Install a TimezoneGetter subclass for ZoneInfo.db</span><br><span class="line">     */</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Sets handler for java.util.logging to use Android log facilities.</span><br><span class="line">     * The odd &quot;new instance-and-then-throw-away&quot; is a mirror of how</span><br><span class="line">     * the &quot;java.util.logging.config.class&quot; system property works. We</span><br><span class="line">     * can&apos;t use the system property here since the logger has almost</span><br><span class="line">     * certainly already been initialized.</span><br><span class="line">     */</span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Sets the default HTTP User-Agent used by HttpURLConnection.</span><br><span class="line">     */</span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    initialized = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nativeZygoteInit最终将调用到jni/AndroidRuntime.cpp中的onZygoteInit方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;　frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"></span><br><span class="line">&#123; &quot;nativeZygoteInit&quot;, &quot;()V&quot;,</span><br><span class="line">    (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line"></span><br><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void onZygoteInit()</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(&quot;App process: starting thread pool.\n&quot;);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onZygoteInit中创建SystemServer进程的ProcessState对象，打开并映射binder，并开启binder线程池。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span><br><span class="line"></span><br><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ......</span><br><span class="line">    设置虚拟机的内存利用率及targetSdkVersion</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args = new Arguments(argv);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        Slog.e(TAG, ex.getMessage());</span><br><span class="line">        // let the process exit</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    // Remaining arguments are passed to the start class&apos;s static main</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        cl = Class.forName(className, true, classLoader);</span><br><span class="line">    &#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Missing class when invoking static main &quot; + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    try &#123;</span><br><span class="line">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Missing static main on &quot; + className, ex);</span><br><span class="line">    &#125; catch (SecurityException ex) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Problem getting static main on &quot; + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int modifiers = m.getModifiers();</span><br><span class="line">    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Main method is not public and static on &quot; + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * This throw gets caught in ZygoteInit.main(), which responds</span><br><span class="line">     * by invoking the exception&apos;s run() method. This arrangement</span><br><span class="line">     * clears up all the stack frames that were required in setting</span><br><span class="line">     * up the process.</span><br><span class="line">     */</span><br><span class="line">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终在invokeStaticMain中抛出MethodAndArgsCaller异常，并传递参数”com.android.server.SystemServer.main”,ZygoteInit.main()中catch该异常，并调用MethodAndArgsCaller.run反射执行SystemServer.main方法。</p>
<h1 id="MethodAndArgsCaller-run"><a href="#MethodAndArgsCaller-run" class="headerlink" title="MethodAndArgsCaller.run()"></a>MethodAndArgsCaller.run()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">        Throwable cause = ex.getCause();</span><br><span class="line">        if (cause instanceof RuntimeException) &#123;</span><br><span class="line">            throw (RuntimeException) cause;</span><br><span class="line">        &#125; else if (cause instanceof Error) &#123;</span><br><span class="line">            throw (Error) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之消息机制]]></title>
      <url>http://robinheztto.com/2016/11/24/android-handler/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>消息驱动是一种进程/线程的运行模式,内部或者外部的消息事件被放到进程/线程的消息队列中按序处理是现在的操作系统普遍采用的机制.Android也是采用了消息驱动的机制来处理各种外部按键,触屏,系统Intent,广播事件等消息.</p>
<p>Android的消息队列是线程相关的,每启动一个线程,都可以在内部创建一个消息队列,然后在消息队列中不断循环检查是否有新的消息需要处理,如果有,则对该消息进行处理,如果没有,线程就进入休眠状态直到有新的消息需要处理为止.</p>
<hr>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Android中与消息机制相关的类主要有Looper,MessageQueue,Handler,Message,相关的代码主要在以下文件中:  </p>
<blockquote>
<ul>
<li>frameworks/base/core/java/android/os/Looper.java</li>
<li>frameworks/base/core/java/android/os/Message.java</li>
<li>frameworks/base/core/java/android/os/MessageQueue.java</li>
<li>frameworks/base/core/java/android/os/Handler.java</li>
<li>frameworks/base/core/jni/android_os_MessageQueue.cpp</li>
<li>system/core/libutils/Looper.cpp</li>
</ul>
</blockquote>
<ul>
<li>Looper<br>Looper对象是用来创建消息队列并进入消息循环处理的.每个线程只能有一个Looper对象，同时对应着一个MessageQueue，发送到该线程的消息都将存放在该队列中，并由Looper循环处理。Android默认只为主线程)(UI线程)创建了Looper，所以当我们新建线程需要使用消息队列时必须手动创建Looper.</li>
<li>MessageQueue<br>MessageQueue即消息队列，由Looper创建管理,一个Looper对象对应一个MessageQueue对象.</li>
<li>Handler<br>Handler是消息的接收与处理者，Handler将Message添加到消息队列，同时也通过Handler的回调方法handleMessage()处理对应的消息.一个Handler对象只能关联一个Looper对象，但多个Handler对象可以关联到同一个Looper.默认情况下Handler会关联到实例化Handler线程的Lopper，也可以通过Handler的构造函数的Looper参数指定Handler关联到某个线程的Looper，即发送消息到某个指定线程并在该线程中回调Handler处理该消息.</li>
<li>Message<br>Message是消息的载体，Parcelable的派生类，通过其成员变量target关联到Handler对象.  </li>
</ul>
<p>它们之间关系如下图示：<br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/handler-looper-messagequeue.jpg?raw=true" alt="Handler,Looper,MessageQueue之间的关系"></p>
<p>在代码中我们一般如下使用线程的消息机制:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="线程消息队列的创建"><a href="#线程消息队列的创建" class="headerlink" title="线程消息队列的创建"></a>线程消息队列的创建</h3><p>线程的消息队列通过Looper创建并维护的，主线程中调用Looper.prepareMainLooper(),其他子线程中调用Looper.prepare()来创建消息队列.一个线程多次调用prepareMainLooper()或prepare()将会抛出异常.</p>
<p>在介绍消息队列创建之前,首先了解一下Looper与MessageQueue,再看消息队列创建的流程.</p>
<ol>
<li><p>Looper类的主要成员变量与方法如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  </span><br><span class="line">      <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">      <span class="keyword">final</span> Thread mThread;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sThreadLocal是静态成员变量,用于保存线程私有的Looper对象</li>
<li>sMainLooper是主线程的Looper对象.在prepareMainLooper()中赋值,可通过调用getMainLooper获取</li>
<li>mQueue即消息队列,在Looper构造函数中初始化</li>
<li>mThread即Looper所在的线程</li>
</ul>
</li>
<li><p>MessageQueue类的主要成员变量与方法如下:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mQuitAllowed;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">long</span> mPtr;</span><br><span class="line">      Message mMessages;</span><br><span class="line"></span><br><span class="line">      MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mQuitAllowed代表是否允许退出消息循环,主线程中默认为false,子线程默认false</li>
<li>mPtr保存的是NativeMessageQueue的地址,通过该地址就可以找到java层MessageQueue所对应native的MessageQueue.</li>
<li>mMessages即消息队列,通过mMessages可以遍历整个消息队列</li>
</ul>
</li>
<li>消息队列的创建:<br>消息队列的创建从Looper.prepare()/Looper.prepareMainLooper()开始</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      prepare(<span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          sMainLooper = myLooper();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">      mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">      mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用prepare()或prepareMainLooper()创建Looper对象,然后保存到sThreadLocal中,sThreadLocal是模板类ThreadLocal<t>,它通过线程ID与对象关联的方式实现线程本地存储功能.这样放入sThreadLocal对象中的Looper对象就与创建它的线程关联起来了.所以可以从sThreadLocal中获取到保存的Looper对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>主线程的Loopper对象保存在sMainLooper,可以通过getMainLooper获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">          <span class="keyword">return</span> sMainLooper;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Looper同时会创建Looper关联的MessageQueue并赋值给成员变量mQueue,接下来再看new MessageQueue(quitAllowed)的过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">      mQuitAllowed = quitAllowed;</span><br><span class="line">      mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到,直接调用了nativeInit().这个JNI方法定义在android_os_MessageQueue.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">      NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">      <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">          jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nativeInit()中首先创建了nativeMessageQueue,然后又将nativeMessageQueue的地址赋值给java层的mPtr,所以java层的MessageQueue就可以通过mPtr找到nativeMessageQueue了.<br>再看new NativeMessageQueue()过程,NativeMessageQueue的构造如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() : mInCallback(<span class="literal">false</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">      mLooper = Looper::getForThread();</span><br><span class="line">      <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">          Looper::setForThread(mLooper);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它首先通过Looper::getForThread()判断当前线程是否已创建过Looper对象,如果没有则创建.注意,这个Looper对象是实现在JNI层的,与上面Java层的Looper是不一样的,不过也是对应的关系.JNI层的Looper对象的创建过程是在Looper.cpp中实现的.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">        mPolling(<span class="literal">false</span>), mEpollFd(<span class="number">-1</span>), mEpollRebuildRequired(<span class="literal">false</span>),</span><br><span class="line">        mNextRequestSeq(<span class="number">0</span>), mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; <span class="number">0</span>, <span class="string">"Could not make wake event fd.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    rebuildEpollLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建eventfd并赋值给mWakeEventFd,在以前的Android版本上,这里创建的是pipe管道.eventfd是较新的API,被用作一个事件等待/响应,实现了线程之间事件通知.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class="line">    <span class="comment">// Close old epoll instance if we have one.</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_CALLBACKS</span></span><br><span class="line">        ALOGD(<span class="string">"%p ~ rebuildEpollLocked - rebuilding epoll set"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        close(mEpollFd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate the new epoll instance and register the wake pipe.</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd;</span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake event fd to epoll instance.  errno=%d"</span>,</span><br><span class="line">            errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> Request&amp; request = mRequests.valueAt(i);</span><br><span class="line">        <span class="keyword">struct</span> epoll_event eventItem;</span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d"</span>,</span><br><span class="line">                    request.fd, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rebuildEpollLocked中通过epoll_create创建了一个epoll专用的文件描述符,EPOLL_SIZE_HINT表示mEpollFd上能监控的最大文件描述符数.最后调用epoll_ctl监控mWakeEventFd文件描述符的EPOLLIN事件，即当eventfd中有内容可读时，就唤醒当前正在等待的线程.  </p>
<p>C++层的这个Looper对象创建好了之后，就返回到JNI层的NativeMessageQueue的构造函数，再返回到Java层的消息队列MessageQueue的创建过程,最后从Looper的构造函数中返回.线程消息队列的创建过程也就此完成.</p>
<p>总结一下:  </p>
<ul>
<li>首先在Java层创建了一个Looper对象，然后创建MessageQueue对象mQueue,进入MessageQueue的创建过程</li>
<li>MessageQueue在JNI层创建了一个NativeMessageQueue对象,并将这个对象保存在MessageQueue的成员变量mPtr中</li>
<li>在JNI层，创建了NativeMessageQueue对象时,会创建了一个Looper对象，保存在JNI层的NativeMessageQueue对象的成员变量mLooper中，这个对象的作用是，当Java层的消息队列中没有消息时，就使Android应用程序线程进入等待状态，而当Java层的消息队列中来了新的消息后，就唤醒Android应用程序的线程来处理这个消息</li>
<li>关于java层与JNI层的Looper,MessageQueue对象可以这样理解,java层的Looper,MessageQueue主要实现了消息队列发送处理逻辑,而JNI层的主要实现是线程的等待/唤醒.在逻辑上他们还是一一对应的关系,只不过侧重点不同.<br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/Looper_MessageQueue.png?raw=true" alt="java与jni层Looper,MessageQueue关系"></li>
</ul>
<hr>
<h3 id="线程消息队列的循环"><a href="#线程消息队列的循环" class="headerlink" title="线程消息队列的循环"></a>线程消息队列的循环</h3><p>当线程消息队列创建完成后,即进入消息队列循环处理过程中,Android消息队列的循环通过Loop.Loop()来实现,整个流程如下图示.<br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/loop_message.jpg?raw=true" alt="消息队列循环流程"></p>
<p>下面具体来看具体分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">      <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">          <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          msg.target.dispatchMessage(msg);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进入loop前,首先通过myLooper()拿到前面创建的Looper对象,如果为null将会抛出异常,这也就是为什么必须在Looper.loop()之前调用Looper.prepare()或者Looper.prepareMainLooper()的原因.接下来通过me.mQueue拿到MessageQueue对象,而后进入到无尽循环处理中.在循环中通过queue.next()从队列中取消息,再调用msg.target.dispatchMessage(msg)处理.下面看一下queue.next()流程.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">              Binder.flushPendingCommands();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">              Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">              Message msg = mMessages;</span><br><span class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  do &#123;</span><br><span class="line">                      prevMsg = msg;</span><br><span class="line">                      msg = msg.next;</span><br><span class="line">                  &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                      nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                      <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          prevMsg.next = msg.next;</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          mMessages = msg.next;</span><br><span class="line">                      &#125;</span><br><span class="line">                      msg.next = <span class="keyword">null</span>;</span><br><span class="line">                      <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                      <span class="keyword">return</span> msg;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                  dispose();</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                      &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">              &#125;</span><br><span class="line">              mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">              <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">              mPendingIdleHandlers[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  keep = idler.queueIdle();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                      mIdleHandlers.remove(idler);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">          nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先看一下开始定义的2个变量的含义,pendingIdleHandlerCount表示消息队列空闲消息处理器(IdleHandler)的个数,nextPollTimeoutMillis表示没有消息处理时,线程需睡眠等待的时间.nativePollOnce将会睡眠等待nextPollTimeoutMillis时间.从nativePollOnce返回后,再从消息队列中取消息,如果没有任何消息,那么nextPollTimeoutMillis赋值为-1,表示下一次nativePollOnce无限制等待直到其他线程把它唤醒.如果取到消息,比较消息处理的时间与当前时间,如果消息处理的时间未到(now &lt; msg.when),那么计算nextPollTimeoutMillis,等下一次时间到时再处理.如果消息处理时间已到,那么取出消息返回到Looperde的loop中处理.另外如果当前没有消息处理时,会回调注册的IdleHandler.<br>下面继续分析nativePollOnce.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终nativePollOnce调用的JNI层Looper的pollOnce<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在pollOnce中不断的循环调用pollInner来检查线程是否有新消息需要处理.如果有新消息处理或者timeoutMillis时间到,则返回到java层MessageQueue的next()继续执行.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> epoll_event eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake event fd."</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>epoll_wait会监听前面创建的epoll实例的文件描述符上的IO读写事件,如果文件描述上没有IO事件出现,那么则等待timeoutMillis延时,检测到EPOLLIN事件即文件描述符上发生了写事件,随后调用awoken读出数据,以便接收新的数据.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::awoken() &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> counter;</span><br><span class="line">    TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在awoken中读出数据.然后一步步返回到java层的MessageQueue继续消息处理.</p>
<hr>
<h3 id="线程消息的发送"><a href="#线程消息的发送" class="headerlink" title="线程消息的发送"></a>线程消息的发送</h3><p>消息的发送是通过Handler来执行的,下面我们从new Handler()开始,一步步分析消息的发送过程<br>首先看一下Handler类的主要数据成员与方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">      <span class="keyword">final</span> Looper mLooper;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;...&#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable r)</span></span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span>&#123;...&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>mQueue handler对应的MessageQueue对象,通过handler发送的消息都将插入到mQueue队列中</li>
<li>mLooper handler对应的Looper对象,如果创建Handler前没有实例化Looper对象将抛出异常.</li>
</ul>
<p>Handler是与Looper对象相关联的,我们创建的Handler对象都会关联到某一Looper,默认情况下,Handler会关联到创建Handler对象所在线程的Looper对象,也可通过Handler的构造函数来指定关联到的Looper.Handler发送消息有二类接口,post类与send类,一般send类用来发送传统带消息ID的消息，post类用来发送带消息处理方法的消息.</p>
<p>下面来看消息发送的具体流程<br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/send_message.jpg?raw=true" alt="消息发送流程"><br>Handler或Post类方法最终都会调用enqueueMessage将消息发送到消息队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">      msg.target = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">          msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Message的成员变量target赋值为this，即关联到handler.然后继续调用MessageQueue的enqueueMessage方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/// M: Add message protect mechanism @&#123;</span></span><br><span class="line">      <span class="keyword">if</span> (msg.hasRecycle) &#123;</span><br><span class="line">          Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"Warning: message has been recycled. msg="</span> + msg);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/// Add message protect mechanism @&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">              IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                      msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">              Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</span><br><span class="line">              msg.recycle();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.markInUse();</span><br><span class="line">          msg.when = when;</span><br><span class="line">          Message p = mMessages;</span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MessageQueue中的enqueueMessage主要工作是将message插入到队列，然后根据情况判断是否应该调用nativeWake唤醒目标线程.当前队列为空或者插入消息处理时间延时为0或者处理时间小于队头处理时间时，消息被插入到头部，否则按时间遍历插入到对应位置，并设置needWake标志，needWake是根据mBlocked来判断的，mBlocked记录了当前线程是否处于睡眠状态，如果消息插入队头且线程在睡眠中，neeWake为true，调用nativeWake唤醒目标线程.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">      NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">      <span class="keyword">return</span> nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">      mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nativeWake最终会调用到jni层的Looper对象的wake方法中,Looper wake方法的实现非常简单,即向mWakeEventFd写入一个uint64_t,这样目标线程就会因为mWakeEventFd发生的IO事件而唤醒.消息的发送流程就此结束.</p>
<hr>
<h3 id="线程消息的处理"><a href="#线程消息的处理" class="headerlink" title="线程消息的处理"></a>线程消息的处理</h3><p>从前面的分析可以知道,当线程没有消息需要处理时,会在c++层Looper对象的pollInner中进入睡眠等待,当有新消息唤醒该目标线程时或这延时时间到,执行流程将沿着pollInner调用路径一直返回,直到java层Looper类的loop.<br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/hand_message.jpg?raw=true" alt="消息处理流程"><br>loop中将调用msg.target.dispatchMessage(msg)处理消息,这里的msg.target就是上面enqueueMessage中所赋值的handler,即进入handler的dispatchMessage处理消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          handleCallback(msg);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          handleMessage(msg);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dispatchMessage进行消息处理,先检查是否有设置msg.callback,如果有则执行msg.callback处理消息,如果没有则继续判断mCallback的执行,最后才是handleMessage处理.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Debug之ADB]]></title>
      <url>http://robinheztto.com/2016/11/12/android-debug-adb/</url>
      <content type="html"><![CDATA[<h1 id="Log抓取"><a href="#Log抓取" class="headerlink" title="Log抓取"></a>Log抓取</h1><ul>
<li><p>Logcat<br><code>$ adb logcat -v threadtime -b main -b events -b radio -b system -b crash &gt; logcat.txt</code><br><code>$ adb logcat *:v &gt;logcat.txt</code></p>
</li>
<li><p>Kernel<br><code>$ adb root</code><br><code>$ adb shell cat /proc/kmsg &gt; klog.txt</code></p>
</li>
<li><p>Others<br>bugreport log: <code>$ adb bugreport &gt; bugreport.txt</code><br>dumpstate log: <code>$ adb dumpstate &gt;dumpstate.txt</code><br>dumpsys log: <code>$ adb shell dumpsys &gt; dumpsys.txt</code><br>memory usage log: <code>$ adb shell procrank &gt; procrank.txt</code><br>memory information log: <code>$ adb shell cat /proc/meminfo &gt; meminfo.txt</code></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Debug之系统启动]]></title>
      <url>http://robinheztto.com/2016/11/05/android-debug-boot/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Debug:系统启动问题</p>
</blockquote>
<h1 id="Boot-Flow"><a href="#Boot-Flow" class="headerlink" title="Boot Flow"></a>Boot Flow</h1><p>Android Boot Flow如下图示：</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/android-debug-boot.jpg?raw=true" alt="Android Boot Flow"><br></div></p>
<h1 id="Boot-Debug"><a href="#Boot-Debug" class="headerlink" title="Boot Debug"></a>Boot Debug</h1><h2 id="BootRom"><a href="#BootRom" class="headerlink" title="BootRom"></a>BootRom</h2><h2 id="LK"><a href="#LK" class="headerlink" title="LK"></a>LK</h2><p>抓取Uart log<br>LK执行时间的计算需借助Trace32并在<code>start of kernel</code>设置断点计算执行时间。</p>
<h2 id="Android-Boot"><a href="#Android-Boot" class="headerlink" title="Android Boot"></a>Android Boot</h2><ol>
<li><p>Catch log:<br>开机后执行以下命令抓取log。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb wait-for-device root</span><br><span class="line">adb wait-for-device</span><br><span class="line">adb shell dmesg &gt; dmesg.txt</span><br><span class="line">adb logcat -b events -d &gt; logcat_events.txt</span><br><span class="line">adb logcat -v time thread -d &gt; logcat.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>Log analysis:<br>根据关键的event log进行分析，正常启动的events log中应该包含如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">01-08 11:46:10.253   760   760 I boot_progress_start: 27961</span><br><span class="line">//Zygote64 begin to start</span><br><span class="line">01-08 11:46:11.828   760   760 I boot_progress_preload_start: 29537</span><br><span class="line">//Zygote32 begin to start</span><br><span class="line">01-08 11:46:12.185   761   761 I boot_progress_preload_start: 29892</span><br><span class="line">//Zygote64 end</span><br><span class="line">01-08 11:46:14.595   760   760 I boot_progress_preload_end: 32303</span><br><span class="line">//Zygote32 end</span><br><span class="line">01-08 11:46:14.774   761   761 I boot_progress_preload_end: 32483</span><br><span class="line">//System ready</span><br><span class="line">01-08 11:46:14.956  1429  1429 I boot_progress_system_run: 32664</span><br><span class="line">// package scan begin</span><br><span class="line">01-08 11:46:15.496  1429  1429 I boot_progress_pms_start: 33204</span><br><span class="line">//scan system folder</span><br><span class="line">01-08 11:46:16.069  1429  1429 I boot_progress_pms_system_scan_start: 33777</span><br><span class="line">//scan data folder</span><br><span class="line">01-08 11:46:17.757  1429  1429 I boot_progress_pms_data_scan_start: 35466</span><br><span class="line">//scan end</span><br><span class="line">01-08 11:46:17.868  1429  1429 I boot_progress_pms_scan_end: 35577</span><br><span class="line">//PMS ready</span><br><span class="line">01-08 11:46:18.401  1429  1429 I boot_progress_pms_ready: 36109</span><br><span class="line">//AMS ready</span><br><span class="line">01-08 11:46:20.632  1429  1429 I boot_progress_ams_ready: 38341</span><br><span class="line">//Home activiy start</span><br><span class="line">01-08 11:46:22.081  1429  1464 I boot_progress_enable_screen: 39789</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据以上log可以清楚的计算出每个步骤所用时间：</p>
<ul>
<li>Kernel part : boot_progress_start</li>
<li>Zygote time : boot_progress_preload_end - boot_progress_preload_start</li>
<li>/system Scan time : boot_progress_pms_data_scan_start - boot_progress_pms_system_scan_start</li>
<li>/data Scan time : boot_progress_pms_scan_end- boot_progress_pms_data_scan_start</li>
<li>Home activity start time : boot_progress_enable_screen- boot_progress_ams_ready</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之Zygote-应用进程创建]]></title>
      <url>http://robinheztto.com/2016/07/02/android-zygote-2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android上应用程序是各种组件(<strong>activity</strong>,<strong>service</strong>,<strong>broadcastReceiver</strong>,<strong>contentProvider</strong>)的组合，组件以进程作为运行的容器，当启动应用的组件之前，必须通过AMS向zygote发送创建应用进程请求，Zygote创建进程后才能启动组件运行。此篇博客主要分析Zygote创建应用进程的过程。相关源码在以下文件中：<br>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java<br>frameworks/base/core/java/android/os/Process.java<br>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java<br>frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java<br>frameworks/base/core/java/com/android/internal/os/Zygote.java<br>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</p>
</blockquote>
<p>根据上篇<strong><a href="http://www.robinheztto.com/2016/07/01/android-zygote-1/" target="_blank" rel="external">Android之Zygote-启动流程</a></strong>的分析，Zygote通过/dev/socket/zygote来接收客户端的请求，而发起请求的客户端则是运行在system_server进程中的ActivityManagerService，下面先从ActivityManagerService请求创建进程开始分析。</p>
<h1 id="AMS-Request"><a href="#AMS-Request" class="headerlink" title="AMS Request"></a>AMS Request</h1><p>AMS需要创建新的进程来执行某个组件时，调用ActivityManagerService.startProcessLocked()向Zygote发送创建新进程的请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType,</span><br><span class="line">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">    ......</span><br><span class="line">    try &#123;</span><br><span class="line">        int uid = app.uid;</span><br><span class="line">        int[] gids = null;</span><br><span class="line">        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">        app.gids = gids;</span><br><span class="line">        app.requiredAbi = requiredAbi;</span><br><span class="line">        app.instructionSet = instructionSet;</span><br><span class="line">        ......</span><br><span class="line">        boolean isActivityProcess = (entryPoint == null);</span><br><span class="line">        if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;</span><br><span class="line">        Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                app.info.dataDir, entryPointArgs);</span><br><span class="line">        ......</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        Slog.e(TAG, &quot;Failure starting process &quot; + app.processName, e);</span><br><span class="line">        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,</span><br><span class="line">                false, true, false, false, UserHandle.getUserId(app.userId), &quot;start failure&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>startProcessLocked中指定uid，gid，应用程序入口等信息，并调用Process.start()启动进程，下面是Process.start()的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/android/os/Process.java</span><br><span class="line"></span><br><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                              final String niceName,</span><br><span class="line">                              int uid, int gid, int[] gids,</span><br><span class="line">                              int debugFlags, int mountExternal,</span><br><span class="line">                              int targetSdkVersion,</span><br><span class="line">                              String seInfo,</span><br><span class="line">                              String abi,</span><br><span class="line">                              String instructionSet,</span><br><span class="line">                              String appDataDir,</span><br><span class="line">                              String[] zygoteArgs) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">    &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                &quot;Starting VM process through Zygote failed&quot;);</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Starting VM process through Zygote failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Process.start()进一步调用startViaZygote()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult startViaZygote(final String processClass,</span><br><span class="line">                              final String niceName,</span><br><span class="line">                              final int uid, final int gid,</span><br><span class="line">                              final int[] gids,</span><br><span class="line">                              int debugFlags, int mountExternal,</span><br><span class="line">                              int targetSdkVersion,</span><br><span class="line">                              String seInfo,</span><br><span class="line">                              String abi,</span><br><span class="line">                              String instructionSet,</span><br><span class="line">                              String appDataDir,</span><br><span class="line">                              String[] extraArgs)</span><br><span class="line">                              throws ZygoteStartFailedEx &#123;</span><br><span class="line">    synchronized(Process.class) &#123;</span><br><span class="line">        // 构造发送给Zygote的进程启动参数argsForZygote</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        // --runtime-args, --setuid=, --setgid=,</span><br><span class="line">        // and --setgroups= must go first</span><br><span class="line">        argsForZygote.add(&quot;--runtime-args&quot;);  // 指定zygote在fork进程后执行ZygoteInit()方法并启动binder线程池</span><br><span class="line">        argsForZygote.add(&quot;--setuid=&quot; + uid); // 指定进程的user id</span><br><span class="line">        argsForZygote.add(&quot;--setgid=&quot; + gid); // 指定进程的group id</span><br><span class="line">        ...... //argsForZygote.add(...)</span><br><span class="line">        argsForZygote.add(&quot;--target-sdk-version=&quot; + targetSdkVersion);　// app target SDK</span><br><span class="line">        ...... //argsForZygote.add(...)</span><br><span class="line">        argsForZygote.add(processClass);  // 指定fork以后执行的java类，“android.app.ActivityThread”</span><br><span class="line"></span><br><span class="line">        if (extraArgs != null) &#123;</span><br><span class="line">            for (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>startViaZygote()的主要工作是创进程启动参数argsForZygote，并通过zygoteSendArgsAndGetResult发送给zygote请求fork子进程。<br>zygoteSendArgsAndGetResult()的第一个参数类型是ZygoteState，ZygoteState是Process类中的静态内部类，负责与zygote socket通信细节。在分析zygoteSendArgsAndGetResult之前先看一下ZygoteState的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public static class ZygoteState &#123;</span><br><span class="line">    // LocalSocket,用来与zygote的LocalServerSocket通信</span><br><span class="line">    final LocalSocket socket;</span><br><span class="line">    // 输入流</span><br><span class="line">    final DataInputStream inputStream;</span><br><span class="line">    // 输出流</span><br><span class="line">    final BufferedWriter writer;</span><br><span class="line">    // abilist(application binary interface)，用与判断32/64位执行</span><br><span class="line">    final List&lt;String&gt; abiList;</span><br><span class="line"></span><br><span class="line">    boolean mClosed;</span><br><span class="line"></span><br><span class="line">    private ZygoteState(LocalSocket socket, DataInputStream inputStream,</span><br><span class="line">            BufferedWriter writer, List&lt;String&gt; abiList) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">        this.inputStream = inputStream;</span><br><span class="line">        this.writer = writer;</span><br><span class="line">        this.abiList = abiList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 连接ZYGOTE_SOCKET(使用字符串作为地址)</span><br><span class="line">    public static ZygoteState connect(String socketAddress) throws IOException &#123;</span><br><span class="line">        DataInputStream zygoteInputStream = null;</span><br><span class="line">        BufferedWriter zygoteWriter = null;</span><br><span class="line">        final LocalSocket zygoteSocket = new LocalSocket();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // socketAddress为ZYGOTE_SOCKET即“zygote”</span><br><span class="line">            zygoteSocket.connect(new LocalSocketAddress(socketAddress,</span><br><span class="line">                    LocalSocketAddress.Namespace.RESERVED));</span><br><span class="line"></span><br><span class="line">            // 初始输入输出流</span><br><span class="line">            zygoteInputStream = new DataInputStream(zygoteSocket.getInputStream());</span><br><span class="line"></span><br><span class="line">            zygoteWriter = new BufferedWriter(new OutputStreamWriter(</span><br><span class="line">                    zygoteSocket.getOutputStream()), 256);</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                zygoteSocket.close();</span><br><span class="line">            &#125; catch (IOException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String abiListString = getAbiList(zygoteWriter, zygoteInputStream);</span><br><span class="line"></span><br><span class="line">        return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter,</span><br><span class="line">                Arrays.asList(abiListString.split(&quot;,&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 通过match来判断primaryZygoteState或secondaryZygoteState</span><br><span class="line">    boolean matches(String abi) &#123;</span><br><span class="line">        return abiList.contains(abi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            Log.e(LOG_TAG,&quot;I/O exception on routine close&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mClosed = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isClosed() &#123;</span><br><span class="line">        return mClosed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zygoteSendArgsAndGetResult的第一个参数为openZygoteSocketIfNeeded(abi),即通过abi选择对应的ZygoteState(分别connect /dev/socket/zygote或/dev/socket/zygote_secondary)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</span><br><span class="line">    if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建localSocket,connect zygote并返回ZygoteState</span><br><span class="line">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The primary zygote didn&apos;t match. Try the secondary.</span><br><span class="line">    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line">        &#125; catch (IOException ioe) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        return secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到zygoteSendArgsAndGetResult方法，继续分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">        throws ZygoteStartFailedEx &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // ......</span><br><span class="line">        // 从zygoteState获取输入输出流</span><br><span class="line">        final BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        final DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">        // 向socket写入请求参数.</span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        // Should there be a timeout on this?</span><br><span class="line">        ProcessStartResult result = new ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        //等待zygote返回新创建的进程pid;</span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        if (result.pid &lt; 0) &#123;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        throw new ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zygoteSendArgsAndGetResult通过socket向zygote发送创建进程请求及参数，并等待创建结束返回pid。</p>
<h1 id="Zygote-Handle"><a href="#Zygote-Handle" class="headerlink" title="Zygote Handle"></a>Zygote Handle</h1><p>Zygote端的处理流程如下图示：<br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/android-zygote-fork-app.jpg?raw=true" alt="android-zygote-fork-app-process"></p>
<p>下面从ZygoteInit.main()开始分析在Zygote服务端处理创建进程的流程．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ......</span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line">        ......</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ZygoteInit.main()中首先通过registerZygoteSocket创建服务端LocalServerSocket，然后在runSelectLoop()中循环等待处理客户端连接并处理．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static final String ANDROID_SOCKET_PREFIX = &quot;ANDROID_SOCKET_&quot;;</span><br><span class="line">private static LocalServerSocket sServerSocket;</span><br><span class="line"></span><br><span class="line">private static void registerZygoteSocket(String socketName) &#123;</span><br><span class="line">    if (sServerSocket == null) &#123;</span><br><span class="line">        int fileDesc;</span><br><span class="line">        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 从环境变量ANDROID_SOCKET_zygote获取/dev/socket/zygote*句柄(可参考上篇博客Android之Zygote-启动流程中init进程启动zygote服务的分析)</span><br><span class="line">            String env = System.getenv(fullSocketName);</span><br><span class="line">            fileDesc = Integer.parseInt(env);</span><br><span class="line">        &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">            throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            FileDescriptor fd = new FileDescriptor();</span><br><span class="line">            fd.setInt$(fileDesc);</span><br><span class="line">            sServerSocket = new LocalServerSocket(fd);</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Error binding to local socket &apos;&quot; + fileDesc + &quot;&apos;&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>registerZygoteSocket()的主要作用创建Zygote服务端sServerSocket，并设置/dev/socket/zygote*的文件描述符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        StructPollfd[] pollFds = new StructPollfd[fds.size()];</span><br><span class="line">        for (int i = 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = new StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (short) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 监控pollFds上POLLIN可读事件，有数据可读表示收到一个连接或者请求</span><br><span class="line">            Os.poll(pollFds, -1);</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 0) &#123;</span><br><span class="line">                // i == 0，创建与客户端的连接，并添加到监听的fds中</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 收到请求的数据，通过ZygoteConnection.runOnce()处理客户端请求</span><br><span class="line">                boolean done = peers.get(i).runOnce();</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ZygoteConnection acceptCommandPeer(String abiList) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取请求连接的客户端socket并创建ZygoteConnection对象</span><br><span class="line">        return new ZygoteConnection(sServerSocket.accept(), abiList);</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;IOException during accept()&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在监听到与客户端连接的socket有数据到来时，调用ZygoteConnection.runOnce()处理客户端的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 读取客户端发送的的创建进程的启动参数</span><br><span class="line">        args = readArgumentList();</span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, &quot;IOException on command socket &quot; + ex.getMessage());</span><br><span class="line">        closeSocket();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 解析参数</span><br><span class="line">        parsedArgs = new Arguments(args);</span><br><span class="line">        ......</span><br><span class="line">        // fork子进程</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, &quot;Exception creating pipe&quot;, ex);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, &quot;Invalid zygote arguments&quot;, ex);</span><br><span class="line">    &#125; catch (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                &quot;Zygote security policy prevents request: &quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            // in child</span><br><span class="line">            ......</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // in parent...pid of &lt; 0 means failure</span><br><span class="line">            ......</span><br><span class="line">            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在runOnce中读取并解析客户端发送的启动参数，并调用Zygote.forkAndSpecialize()方法fork子进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,</span><br><span class="line">      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,</span><br><span class="line">      String instructionSet, String appDataDir) &#123;</span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    int pid = nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir);</span><br><span class="line">    ......</span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>forkAndSpecialize中直接调用native方法nativeForkAndSpecialize，nativeForkAndSpecialize在register_com_android_internal_os_Zygote在AndroidRuntime.start()中通过startReg注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static const JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123; &quot;nativeForkAndSpecialize&quot;,</span><br><span class="line">      &quot;(II[II[[IILjava/lang/String;Ljava/lang/String;[ILjava/lang/String;Ljava/lang/String;)I&quot;,</span><br><span class="line">      (void *) com_android_internal_os_Zygote_nativeForkAndSpecialize &#125;,</span><br><span class="line">    &#123; &quot;nativeForkSystemServer&quot;, &quot;(II[II[[IJJ)I&quot;,</span><br><span class="line">      (void *) com_android_internal_os_Zygote_nativeForkSystemServer &#125;,</span><br><span class="line">    &#123; &quot;nativeUnmountStorageOnInit&quot;, &quot;()V&quot;,</span><br><span class="line">      (void *) com_android_internal_os_Zygote_nativeUnmountStorageOnInit &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int register_com_android_internal_os_Zygote(JNIEnv* env) &#123;</span><br><span class="line">  gZygoteClass = MakeGlobalRefOrDie(env, FindClassOrDie(env, kZygoteClassName));</span><br><span class="line">  gCallPostForkChildHooks = GetStaticMethodIDOrDie(env, gZygoteClass, &quot;callPostForkChildHooks&quot;,</span><br><span class="line">                                                   &quot;(IZLjava/lang/String;)V&quot;);</span><br><span class="line"></span><br><span class="line">  return RegisterMethodsOrDie(env, &quot;com/android/internal/os/Zygote&quot;, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nativeForkAndSpecialize映射到jni方法com_android_internal_os_Zygote_nativeForkAndSpecialize，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static jint com_android_internal_os_Zygote_nativeForkAndSpecialize(</span><br><span class="line">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span><br><span class="line">        jint debug_flags, jobjectArray rlimits,</span><br><span class="line">        jint mount_external, jstring se_info, jstring se_name,</span><br><span class="line">        jintArray fdsToClose, jstring instructionSet, jstring appDataDir) &#123;</span><br><span class="line">    jlong capabilities = 0;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, false, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span><br><span class="line">                                     jint debug_flags, jobjectArray javaRlimits,</span><br><span class="line">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span><br><span class="line">                                     jint mount_external,</span><br><span class="line">                                     jstring java_se_info, jstring java_se_name,</span><br><span class="line">                                     bool is_system_server, jintArray fdsToClose,</span><br><span class="line">                                     jstring instructionSet, jstring dataDir) &#123;</span><br><span class="line">  ......</span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  if (pid == 0) &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 设置进程各个属性</span><br><span class="line">    rc = setresgid(gid, gid, gid);</span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    ......</span><br><span class="line">  &#125; else if (pid &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终ForkAndSpecializeCommon中通过fork创建出子进程并返回，接着在子进程(pid == 0)中执行handleChildProc。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void handleChildProc(Arguments parsedArgs,</span><br><span class="line">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    // close继承与Zygote的socket</span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line"></span><br><span class="line">    // 恢复子进程中的STDIN_FILENO，STDOUT_FILENO，STDERR_FILENO</span><br><span class="line">    if (descriptors != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Os.dup2(descriptors[0], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[1], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[2], STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">            for (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr = System.err;</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Error reopening stdio&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置进程名</span><br><span class="line">    if (parsedArgs.niceName != null) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (parsedArgs.invokeWith != null) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 进入到zygoteInit执行</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, null /* classLoader */);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在handleChildProc()中关闭sServerSocket,设置进程名，并进入到RuntimeInit.zygoteInit()中执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ......</span><br><span class="line">    commonInit();</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>zygoteInit()中主要是对新创建的进程执行一些初始化的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private static final void commonInit() &#123;</span><br><span class="line">    // 设置默认的caughtHandler</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    // 设置时区信息</span><br><span class="line">    TimezoneGetter.setInstance(new TimezoneGetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getId() &#123;</span><br><span class="line">            return SystemProperties.get(&quot;persist.sys.timezone&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(null);</span><br><span class="line"></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    new AndroidConfig();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Sets the default HTTP User-Agent used by HttpURLConnection.</span><br><span class="line">     */</span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(&quot;http.agent&quot;, userAgent);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Wire socket tagging to traffic stats.</span><br><span class="line">     */</span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    initialized = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>commonInit()中主要做一些通用的初始化。继续看nativeZygoteInit()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static const JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123; &quot;nativeFinishInit&quot;, &quot;()V&quot;,</span><br><span class="line">        (void*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;,</span><br><span class="line">    &#123; &quot;nativeZygoteInit&quot;, &quot;()V&quot;,</span><br><span class="line">        (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#123; &quot;nativeSetExitWithoutCleanup&quot;, &quot;(Z)V&quot;,</span><br><span class="line">        (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int register_com_android_internal_os_RuntimeInit(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    return jniRegisterNativeMethods(env, &quot;com/android/internal/os/RuntimeInit&quot;,</span><br><span class="line">        gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    // 调用AppRuntime.onZygoteInit()</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>nativeZygoteInit最终由AndroidRuntime.cpp中的com_android_internal_os_RuntimeInit_nativeZygoteInit实现，onZygoteInit()是AndroidRuntime中的定义的virtual方法，在AppRuntime中实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtual void onZygoteInit()</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到onZygoteInit()中的主要操作是启动线程池，用于Binder进程间通信(参考Binder篇的分析)。继续分析applicationInit()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    ......</span><br><span class="line">    final Arguments args;</span><br><span class="line">    try &#123;</span><br><span class="line">        args = new Arguments(argv);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>applicationInit()中调用invokeStaticMain并抛出ZygoteInit.MethodAndArgsCaller异常，在ZygoteInit.main()中会catch住这个异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        cl = Class.forName(className, true, classLoader);</span><br><span class="line">    &#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Missing class when invoking static main &quot; + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    try &#123;</span><br><span class="line">        m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Missing static main on &quot; + className, ex);</span><br><span class="line">    &#125; catch (SecurityException ex) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">                &quot;Problem getting static main on &quot; + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw new ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeStaticMain()中className即由AMS所传递的”android.app.ActivityThread”，在invokeStaticMain抛出ZygoteInit.MethodAndArgsCaller异常后，系统沿着调用栈找到ZygoteInit.main()处理这个异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    ......</span><br><span class="line">    try &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mMethod.invoke(null, new Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终，在MethodAndArgsCaller.run()中执行应用程序入口”android.app.ActivityThread”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ......</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ......</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line">    ......</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之Zygote-启动流程]]></title>
      <url>http://robinheztto.com/2016/07/01/android-zygote-1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Zygote是Android系统中的进程孵化器，它孵化了Android系统核心进程system_server及所有的应用程序进程。此篇博客主要分析Zygote的启动流程。相关源码在以下文件中：<br>system/core/init/service.cpp<br>frameworks/base/cmds/app_process/app_main.cpp<br>frameworks/base/core/jni/AndroidRuntime.cpp<br>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p>
</blockquote>
<div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/android_zygote.jpg?raw=true" alt="android_zygote_init_flow"><br></div>

<h1 id="init-ro-zygote-rc"><a href="#init-ro-zygote-rc" class="headerlink" title="init.${ro.zygote}.rc"></a>init.${ro.zygote}.rc</h1><p>Zygote以服务的形式定义在init.${ro.zygote}.rc文件中，并通过<code>import /init.${ro.zygote}.rc</code>的形式包含到/init.rc文件，其中ro.zygote是用来区分32与64位版本的属性值，在default.prop中定义ro.zygote属性值，其可取的值有”zygote32”，”zygote32_64”，”zygote64”，”zygote64_32”。下面是init.zygote64_32.rc中的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks /sys/fs/cgroup/stune/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary</span><br><span class="line">    class main</span><br><span class="line">    socket zygote_secondary stream 660 root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据以上的定义对应生成二个zygote进程</span><br><span class="line">root:/ $ ps | grep zygote</span><br><span class="line">root      754   1     2237660 82604 poll_sched 0000000000 S zygote64</span><br><span class="line">root      755   1     1668956 69200 poll_sched 0000000000 S zygote</span><br></pre></td></tr></table></figure></p>
<p>init.zygote64_32.rc文件中定义了zygote与zygote_secondary二个service，系统启动后可以看到存在zygote64与zygote二个进程，即分别通过/system/bin/下的app_process64与app_process32启动。<code>class main</code>定义zygote服务属于class main，通过<code>class_start main</code>启动，并为其创建名为”zygote”的socket用于进程间通信，如果zygote重启，audioserver，cameraserver，media，netd进程也将重新启动。<br>下面首先从init解析rc启动Service开始看Zygote的启动流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; system/core/init/service.cpp</span><br><span class="line">bool Service::Start() &#123;</span><br><span class="line">    ......</span><br><span class="line">    // fork service进程</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        // 创建/dev/socket/zygote</span><br><span class="line">        for (const auto&amp; si : sockets_) &#123;</span><br><span class="line">            int socket_type = ((si.type == &quot;stream&quot; ? SOCK_STREAM :</span><br><span class="line">                                (si.type == &quot;dgram&quot; ? SOCK_DGRAM :</span><br><span class="line">                                 SOCK_SEQPACKET)));</span><br><span class="line">            const char* socketcon =</span><br><span class="line">                !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();</span><br><span class="line"></span><br><span class="line">            int s = create_socket(si.name.c_str(), socket_type, si.perm,</span><br><span class="line">                                  si.uid, si.gid, socketcon);</span><br><span class="line">            if (s &gt;= 0) &#123;</span><br><span class="line">                // 把socket的fd保存在环境变量ANDROID_SOCKET_zygote中</span><br><span class="line">                PublishSocket(si.name, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        setpgid(0, getpid());</span><br><span class="line"></span><br><span class="line">        // As requested, set our gid, supplemental gids, and uid.</span><br><span class="line">        if (gid_) &#123;</span><br><span class="line">            if (setgid(gid_) != 0) &#123;</span><br><span class="line">                ERROR(&quot;setgid failed: %s\n&quot;, strerror(errno));</span><br><span class="line">                _exit(127);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!supp_gids_.empty()) &#123;</span><br><span class="line">            if (setgroups(supp_gids_.size(), &amp;supp_gids_[0]) != 0) &#123;</span><br><span class="line">                ERROR(&quot;setgroups failed: %s\n&quot;, strerror(errno));</span><br><span class="line">                _exit(127);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (uid_) &#123;</span><br><span class="line">            if (setuid(uid_) != 0) &#123;</span><br><span class="line">                ERROR(&quot;setuid failed: %s\n&quot;, strerror(errno));</span><br><span class="line">                _exit(127);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!seclabel_.empty()) &#123;</span><br><span class="line">            if (setexeccon(seclabel_.c_str()) &lt; 0) &#123;</span><br><span class="line">                ERROR(&quot;cannot setexeccon(&apos;%s&apos;): %s\n&quot;,</span><br><span class="line">                      seclabel_.c_str(), strerror(errno));</span><br><span class="line">                _exit(127);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;char*&gt; strs;</span><br><span class="line">        for (const auto&amp; s : args_) &#123;</span><br><span class="line">            strs.push_back(const_cast&lt;char*&gt;(s.c_str()));</span><br><span class="line">        &#125;</span><br><span class="line">        strs.push_back(nullptr);</span><br><span class="line">        // 执行app_process启动zygote</span><br><span class="line">        if (execve(args_[0].c_str(), (char**) &amp;strs[0], (char**) ENV) &lt; 0) &#123;</span><br><span class="line">            ERROR(&quot;cannot execve(&apos;%s&apos;): %s\n&quot;, args_[0].c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(127);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="app-process"><a href="#app-process" class="headerlink" title="app_process"></a>app_process</h1><p>app_process64/app_process32是system/bin下的可执行文件，其源码在frameworks/base/cmds/app_process/下，app_process不仅可以用来启动Zygote进程还可以用来执行系统中的某个类(/system/bin/am就是通过app_process来实现的)。它的的Usage如下：</p>
<blockquote>
<p>app_process [java-options] cmd-dir start-class-name [options]<br>java-options: 以”-“开头，启动虚拟机时传递给虚拟机的参数。<br>cmd-dir: cmd的目录，/system/bin。<br>start-class-name: 需要启动的java类，需包含静态main()方法。<br>options: “--zygote”表示启动zygote进程，”--application”表示启动应用程序进程。</p>
</blockquote>
<p>下面从app_process的main函数开始分析，main()中主要是对参数解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/cmds/app_process/app_main.cpp</span><br><span class="line"></span><br><span class="line">//AppRuntime继承自AndroidRuntime</span><br><span class="line">class AppRuntime : public AndroidRuntime</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AppRuntime(char* argBlockStart, const size_t argBlockLength)</span><br><span class="line">        : AndroidRuntime(argBlockStart, argBlockLength)</span><br><span class="line">        , mClass(NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    String8 mClassName;</span><br><span class="line">    Vector&lt;String8&gt; mArgs;</span><br><span class="line">    jclass mClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) &#123;</span><br><span class="line">        // Older kernels don&apos;t understand PR_SET_NO_NEW_PRIVS and return</span><br><span class="line">        // EINVAL. Don&apos;t die on such kernels.</span><br><span class="line">        if (errno != EINVAL) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(&quot;PR_SET_NO_NEW_PRIVS failed: %s&quot;, strerror(errno));</span><br><span class="line">            return 12;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建AppRuntime并保存参数，AppRuntime继承自AndroidRuntime，主要工作是创建加载ART虚拟机</span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line"></span><br><span class="line">    // 过滤掉argv[0]</span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    // runtime参数解析</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; argc; i++) &#123;</span><br><span class="line">        if (argv[i][0] != &apos;-&apos;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (argv[i][1] == &apos;-&apos; &amp;&amp; argv[i][2] == 0) &#123;</span><br><span class="line">            ++i; // Skip --.</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // --zygote : 启动zygote.</span><br><span class="line">    // --start-system-server : 启动systemServer.</span><br><span class="line">    // --application : 启动application.</span><br><span class="line">    // --nice-name : 进程名</span><br><span class="line">    bool zygote = false;</span><br><span class="line">    bool startSystemServer = false;</span><br><span class="line">    bool application = false;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  // 跳过没有使用的参数&quot;parent dir&quot;，即/system/bin</span><br><span class="line">    while (i &lt; argc) &#123;</span><br><span class="line">        const char* arg = argv[i++];</span><br><span class="line">        if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123;</span><br><span class="line">            zygote = true;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;　// zygote的进程名为zygote64或zygote</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123;</span><br><span class="line">            startSystemServer = true;</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--application&quot;) == 0) &#123;</span><br><span class="line">            application = true;</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) &#123;</span><br><span class="line">            niceName.setTo(arg + 12);</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--&quot;, 2) != 0) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            --i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 准备执行参数</span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    if (!className.isEmpty()) &#123;</span><br><span class="line">        // 指定执行class,非zygote模式</span><br><span class="line">        args.add(application ? String8(&quot;application&quot;) : String8(&quot;tool&quot;));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // zygote模式，创建/data/dalvik-cache/arm64,/data/dalvik-cache/arm*缓存目录</span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        // 添加zygote参数，start-system-server</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(&quot;start-system-server&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 添加zygote参数,--abi-list</span><br><span class="line">        // [ro.product.cpu.abilist64]: [arm64-v8a]</span><br><span class="line">        // [ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]</span><br><span class="line">        char prop[PROP_VALUE_MAX];</span><br><span class="line">        if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(&quot;app_process: Unable to determine ABI list from property %s.&quot;,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            return 11;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String8 abiFlag(&quot;--abi-list=&quot;);</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        // 所有参数将传递给ZygoteInit.main()</span><br><span class="line">        for (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置进程名niceName</span><br><span class="line">    if (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (zygote) &#123;</span><br><span class="line">        // zygote模式执行ZygoteInit类</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</span><br><span class="line">    &#125; else if (className) &#123;</span><br><span class="line">        //　非zygote模式执行RuntimeInit类</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>app_main的main函数主要是对参数进行解析，并判断启动模式zygote或者application,而后进入到AndroidRuntime执行。</p>
<h1 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h1><p>接下来进入到AndroidRuntime::start中执行，主要工作是启动虚拟机并加载执行参数className指定的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"></span><br><span class="line">void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)</span><br><span class="line">&#123;</span><br><span class="line">    // 启动时可以看到log信息 -&gt; “AndroidRuntime: &gt;&gt;&gt;&gt;&gt;&gt; START com.android.internal.os.ZygoteInit uid 0 &lt;&lt;&lt;&lt;&lt;&lt;”</span><br><span class="line">    ALOGD(&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;,</span><br><span class="line">            className != NULL ? className : &quot;(unknown)&quot;, getuid());</span><br><span class="line"></span><br><span class="line">    static const String8 startSystemServer(&quot;start-system-server&quot;);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * &apos;startSystemServer == true&apos; means runtime is obsolete and not run from</span><br><span class="line">     * init.rc anymore, so we print out the boot start event here.</span><br><span class="line">     */</span><br><span class="line">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        if (options[i] == startSystemServer) &#123;</span><br><span class="line">           /* track our progress through the boot sequence */</span><br><span class="line">           const int LOG_BOOT_PROGRESS_START = 3000;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置系统目录环境变量ANDROID_ROOT=/system</span><br><span class="line">    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);</span><br><span class="line">    if (rootDir == NULL) &#123;</span><br><span class="line">        rootDir = &quot;/system&quot;;</span><br><span class="line">        if (!hasDir(&quot;/system&quot;)) &#123;</span><br><span class="line">            LOG_FATAL(&quot;No root directory specified, and /android does not exist.&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用JniInvocation启动虚拟机</span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(NULL);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用AppRuntime的重载函数onVmCreated，zygote模式下直接返回</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    // 注册系统jni函数，将全局数组gRegJNI中的jni函数逐一注册</span><br><span class="line">    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;Unable to register all android natives\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建执行类main()的String argv[]参数</span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">    assert(stringClass != NULL);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);</span><br><span class="line">    assert(strArray != NULL);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != NULL);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());</span><br><span class="line">        assert(optionsStr != NULL);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将&quot;com.android.internal.os.ZygoteInit&quot;转换为&quot;com/android/internal/os/ZygoteInit&quot;</span><br><span class="line">    char* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    if (startClass == NULL) &#123;</span><br><span class="line">        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\n&quot;, slashClassName);</span><br><span class="line">        /* keep going */</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</span><br><span class="line">            &quot;([Ljava/lang/String;)V&quot;);</span><br><span class="line">        if (startMeth == NULL) &#123;</span><br><span class="line">            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\n&quot;, className);</span><br><span class="line">            /* keep going */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          　 // 执行com.android.internal.os.ZygoteInit或</span><br><span class="line">            //　com.android.internal.os.RuntimeInit中的main()方法</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(slashClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AndroidRuntime::start中，先通过JNI invocation API创建加载虚拟机，然后加载执行ZygoteInit.java类main方法(启动虚拟机后即默认主线程)。创建加载虚拟机执行的是startVm()，下面是startVm()的具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;　frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"></span><br><span class="line">int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)</span><br><span class="line">&#123;</span><br><span class="line">    JavaVMInitArgs initArgs;</span><br><span class="line"></span><br><span class="line">    // 主要是通过addOption添加虚拟机启动参数,大多参数都是通过parseRuntimeOption从系统属性值中读取</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    /* 以下是通过logcat打印出来的虚拟机启动参数</span><br><span class="line">    01-06 13:44:08.556   757   757 I art     : option[0]=-Xzygote</span><br><span class="line">    01-06 13:44:08.557   757   757 I art     : option[1]=-Xstacktracefile:/data/anr/traces.txt</span><br><span class="line">    01-06 13:44:08.557   757   757 I art     : option[2]=exit</span><br><span class="line">    01-06 13:44:08.558   757   757 I art     : option[3]=vfprintf</span><br><span class="line">    01-06 13:44:08.558   757   757 I art     : option[4]=sensitiveThread</span><br><span class="line">    01-06 13:44:08.559   757   757 I art     : option[5]=-verbose:gc</span><br><span class="line">    01-06 13:44:08.560   757   757 I art     : option[6]=-Xms8m</span><br><span class="line">    01-06 13:44:08.560   757   757 I art     : option[7]=-Xmx512m</span><br><span class="line">    01-06 13:44:08.560   757   757 I art     : option[8]=-XX:HeapGrowthLimit=256m</span><br><span class="line">    01-06 13:44:08.560   757   757 I art     : option[9]=-XX:HeapMinFree=512k</span><br><span class="line">    01-06 13:44:08.561   757   757 I art     : option[10]=-XX:HeapMaxFree=8m</span><br><span class="line">    01-06 13:44:08.562   757   757 I art     : option[11]=-XX:HeapTargetUtilization=0.75</span><br><span class="line">    01-06 13:44:08.562   757   757 I art     : option[12]=-Xusejit:true</span><br><span class="line">    01-06 13:44:08.562   757   757 I art     : option[13]=-Xjitsaveprofilinginfo</span><br><span class="line">    01-06 13:44:08.563   757   757 I art     : option[14]=-agentlib:jdwp=transport=dt_android_adb,suspend=n,server=y</span><br><span class="line">    01-06 13:44:08.563   757   757 I art     : option[15]=-Xlockprofthreshold:500</span><br><span class="line">    01-06 13:44:08.563   757   757 I art     : option[16]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.570   757   757 I art     : option[17]=--runtime-arg</span><br><span class="line">    01-06 13:44:08.571   757   757 I art     : option[18]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.571   757   757 I art     : option[19]=-Xms64m</span><br><span class="line">    01-06 13:44:08.571   757   757 I art     : option[20]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.571   757   757 I art     : option[21]=--runtime-arg</span><br><span class="line">    01-06 13:44:08.571   757   757 I art     : option[22]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.571   757   757 I art     : option[23]=-Xmx64m</span><br><span class="line">    01-06 13:44:08.592   757   757 I art     : option[24]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.592   757   757 I art     : option[25]=--image-classes=/system/etc/preloaded-classes</span><br><span class="line">    01-06 13:44:08.592   757   757 I art     : option[26]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.592   757   757 I art     : option[27]=--compiled-classes=/system/etc/compiled-classes</span><br><span class="line">    01-06 13:44:08.593   757   757 I art     : option[28]=-Xcompiler-option</span><br><span class="line">    01-06 13:44:08.593   757   757 I art     : option[29]=--runtime-arg</span><br><span class="line">    01-06 13:44:08.593   757   757 I art     : option[30]=-Xcompiler-option</span><br><span class="line">    01-06 13:44:08.593   757   757 I art     : option[31]=-Xms64m</span><br><span class="line">    01-06 13:44:08.593   757   757 I art     : option[32]=-Xcompiler-option</span><br><span class="line">    01-06 13:44:08.593   757   757 I art     : option[33]=--runtime-arg</span><br><span class="line">    01-06 13:44:08.594   757   757 I art     : option[34]=-Xcompiler-option</span><br><span class="line">    01-06 13:44:08.594   757   757 I art     : option[35]=-Xmx512m</span><br><span class="line">    01-06 13:44:08.594   757   757 I art     : option[36]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.594   757   757 I art     : option[37]=--instruction-set-variant=kryo</span><br><span class="line">    01-06 13:44:08.594   757   757 I art     : option[38]=-Xcompiler-option</span><br><span class="line">    01-06 13:44:08.594   757   757 I art     : option[39]=--instruction-set-variant=kryo</span><br><span class="line">    01-06 13:44:08.595   757   757 I art     : option[40]=-Ximage-compiler-option</span><br><span class="line">    01-06 13:44:08.595   757   757 I art     : option[41]=--instruction-set-features=default</span><br><span class="line">    01-06 13:44:08.595   757   757 I art     : option[42]=-Xcompiler-option</span><br><span class="line">    01-06 13:44:08.595   757   757 I art     : option[43]=--instruction-set-features=default</span><br><span class="line">    01-06 13:44:08.595   757   757 I art     : option[44]=-Duser.locale=zh-cn</span><br><span class="line">    01-06 13:44:08.595   757   757 I art     : option[45]=--cpu-abilist=arm64-v8a</span><br><span class="line">    01-06 13:44:08.596   757   757 I art     : option[46]=-Xfingerprint:TCL/london/london:7.0/London-V1.0.1.1C-11170539/jenkin11170539:userdebug/release-keys</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    initArgs.version = JNI_VERSION_1_4;</span><br><span class="line">    initArgs.options = mOptions.editArray();</span><br><span class="line">    initArgs.nOptions = mOptions.size();</span><br><span class="line">    initArgs.ignoreUnrecognized = JNI_FALSE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 通过JNI_CreateJavaVM创建加载虚拟机，其中JavaVM*整个进程只有一个，JNIEnv*每个线程一个,pEnv是保存jni接口的指针</span><br><span class="line">    if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;JNI_CreateJavaVM failed\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a>ZygoteInit</h1><p>加载虚拟机后将调用到ZygoteInit的静态main方法对Zygote java层的初始化，下面继续分析ZygoteInit.main()的执行流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    ......</span><br><span class="line">    try &#123;</span><br><span class="line">        ......</span><br><span class="line">        // 解析参数，根据参数决定是否启动SystemServer，获取abiList及socketName</span><br><span class="line">        boolean startSystemServer = false;</span><br><span class="line">        String socketName = &quot;zygote&quot;;</span><br><span class="line">        String abiList = null;</span><br><span class="line">        for (int i = 1; i &lt; argv.length; i++) &#123;</span><br><span class="line">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = true;</span><br><span class="line">            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (abiList == null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No ABI list supplied.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 注册zygote socket监听端口</span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line"></span><br><span class="line">        // 加载系统资源。zygote fork的子进程将继承zygote的虚拟机和加载的资源，以加快应用启动的速度。</span><br><span class="line">        preload();</span><br><span class="line">        ......</span><br><span class="line">        // 启动SystemServer进程</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 循环监听socket消息</span><br><span class="line">        Log.i(TAG, &quot;Accepting command socket connections&quot;);</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line"></span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ZygoteInit.main()主要工作是预加载系统类与资源，启动systemServer，注册并监听socket连接消息。其中注册并监听socket连接消息内容在 <strong><a href="http://www.robinheztto.com/2016/07/02/android-zygote-2/" target="_blank" rel="external">Android之Zygote-应用进程创建</a></strong> 分析，启动systemServer流程在 <strong><a href="http://www.robinheztto.com/2016/11/28/android-systemserver-1/" target="_blank" rel="external">Android之SystemServer启动(上)</a></strong> 中分析，下面分析preload预加载系统类与资源的过程。</p>
<p><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/android-zygote-proload.jpg?raw=true" alt="进程共享资源图解"><br></div><br>Linux中的进程通过系统调用fork产生后，其父子进程的内存映像(代码段，数据段，堆/栈)是共享的，只有子进程改写这些区域时才为子进程分配新的page(Copy On Write机制)，另外zygote fork子进程后并没有调用exec，即未替换掉zygote进程的代码段，数据段，堆栈，这样zygote fork出的子进程就可以共享它预加载的资源及类库了。<br>在preload中，zygote预加载系统常用类库及资源，以减短应用启动的时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span><br><span class="line"></span><br><span class="line">static void preload() &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 根据frameworks/base/preloaded-classes加载java类</span><br><span class="line">    preloadClasses();</span><br><span class="line">    ......</span><br><span class="line">    // 根据frameworks/base/core/res/res/values/array.xml中</span><br><span class="line">    // 的preloaded_drawables及preloaded_color_state_lists标签加载drawable及color资源</span><br><span class="line">    preloadResources();</span><br><span class="line">    ......</span><br><span class="line">    preloadOpenGL();</span><br><span class="line">    ......</span><br><span class="line">    // 加载libandroid.so，libcompiler_rt.so，libjnigraphics.so</span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line">    preloadTextResources();</span><br><span class="line">    ......</span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SystemServer进程的启动，及应用程序的创建在后面的博客中单独分析。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之Java接口]]></title>
      <url>http://robinheztto.com/2016/04/23/android-binder-7/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android中应用程序大部分使用Java开发，Android系统在frameworks中也提供了一套Binder进程间通信的接口。<br>相关源码集中在以下文件中：<br>frameworks/base/core/java/android/os/IInterface.java<br>frameworks/base/core/java/android/os/IBinder.java<br>frameworks/base/core/java/android/os/IServiceManager.java<br>frameworks/base/core/java/android/os/ServiceManager.java<br>frameworks/base/core/java/android/os/ServiceManagerNative.java</p>
</blockquote>
<h1 id="ServiceManager-java代理获取"><a href="#ServiceManager-java代理获取" class="headerlink" title="ServiceManager java代理获取"></a>ServiceManager java代理获取</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之Service代理获取]]></title>
      <url>http://robinheztto.com/2016/04/18/android-binder-6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Service组件注册到Service Manager后，就在Server进程中等待Client的请求，而在Client请求之前，必须得先通过ServiceManager获取到Service的代理，才能与Service进行通信。本篇继续以MediaPlayerService为例，分析获取MediaPlayerService的代理对象的流程。相关代码在以下文件中:<br>frameworks/av/media/libmedia/IMediaDeathNotifier.cpp<br>frameworks/native/libs/binder/IServiceManager.cpp</p>
</blockquote>
<p>根据前面Binder的分析，获取MediaPlayerService的代理对象，首先需要从驱动中拿到MediaPlayerService对应的binder_ref的句柄值，根据句柄值创建Binder代理对象BpBinder，然后根据BpBinder封装成BpMediaPlayerService。下面从MediaPlayer的getService入口开始分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/av/media/libmedia/IMediaDeathNotifier.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;IMediaPlayerService&gt; IMediaDeathNotifier::sMediaPlayerService;</span><br><span class="line"></span><br><span class="line">IMediaDeathNotifier::getMediaPlayerService()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(sServiceLock);</span><br><span class="line">    if (sMediaPlayerService == 0) &#123;</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        do &#123;</span><br><span class="line">            binder = sm-&gt;getService(String16(&quot;media.player&quot;));</span><br><span class="line">            if (binder != 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            usleep(500000); // 0.5 s</span><br><span class="line">        &#125; while (true);</span><br><span class="line"></span><br><span class="line">        if (sDeathNotifier == NULL) &#123;</span><br><span class="line">            sDeathNotifier = new DeathNotifier();</span><br><span class="line">        &#125;</span><br><span class="line">        binder-&gt;linkToDeath(sDeathNotifier);</span><br><span class="line">        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    return sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过defaultServiceManager()获取到ServiceManager的代理，然后通过ServiceManager代理的成员方法getService获取MediaPlayerService的Bpbinder对象，通过interface_cast将BpBinder封装成BpMediaPlayerService并获取其IMediaPlayerService接口。defaultServiceManager()-&gt;getService的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IServiceManager.cpp</span><br><span class="line"></span><br><span class="line">virtual sp&lt;IBinder&gt; getService(const String16&amp; name) const</span><br><span class="line">&#123;</span><br><span class="line">    unsigned n;</span><br><span class="line">    for (n = 0; n &lt; 5; n++)&#123;</span><br><span class="line">        sp&lt;IBinder&gt; svc = checkService(name);</span><br><span class="line">        if (svc != NULL) return svc;</span><br><span class="line">        ALOGI(&quot;Waiting for service %s...\n&quot;, String8(name).string());</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual sp&lt;IBinder&gt; checkService( const String16&amp; name) const</span><br><span class="line">&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name);</span><br><span class="line">    remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    return reply.readStrongBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getService()中通过checkService获取name为”media.player”的BpBinder对象，获取失败则休眠1s再次循环获取，循环超过5次则获取失败退出。checkService的操作与前篇分析的addService操作类似，将进程间通信数据封装成Parcel对象并调用remote()-&gt;transact()将数据发送给驱动，接下来的数据发送的过程与前篇addService流程一致。<br>下面看一下ServiceManager端的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/cmds/servicemanager/service_manager.c</span><br><span class="line"></span><br><span class="line">int svcmgr_handler(struct binder_state *bs,</span><br><span class="line">                   struct binder_transaction_data *txn,</span><br><span class="line">                   struct binder_io *msg,</span><br><span class="line">                   struct binder_io *reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line">    uint16_t *s;</span><br><span class="line">    size_t len;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    uint32_t strict_policy;</span><br><span class="line">    int allow_isolated;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    switch(txn-&gt;code) &#123;</span><br><span class="line">    case SVC_MGR_GET_SERVICE:</span><br><span class="line">    case SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        if (s == NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        if (!handle)</span><br><span class="line">            break;</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        return 0;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        ALOGE(&quot;unknown code %d\n&quot;, txn-&gt;code);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>svcmgr_handler()中首先获取到需要查找的服务名称media.player然后通过do_find_service()查找对应的服务，并通过bio_put_ref()将handle返回给驱动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/cmds/servicemanager/service_manager.c</span><br><span class="line"></span><br><span class="line">uint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si = find_svc(s, len);</span><br><span class="line"></span><br><span class="line">    if (!si || !si-&gt;handle) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    if (!svc_can_find(s, len, spid, uid)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return si-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>do_find_service()在svclist中找到对应的svcinfo，并返回其句柄值handle。在ServiceManager将MediaPlayerService引用的句柄返回给驱动后，驱动会根据handle查找Client进程是否已经存在MediaPlayerService的binder_ref对象，如果不存在则为其创建该引用对象，并将该引用对象的句柄值返回给Client，根据此handle值就可以封装对应MediaPlayerService的Bpbinder及代理对象。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之Service启动]]></title>
      <url>http://robinheztto.com/2016/04/02/android-binder-5/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Service组件在Server进程启动时会将Service注册到Service Manager中，然后启动Binder线程池等待和处理Client的请求，本篇以MediaPlayerService为例分析Service的启动过程。<br>相关代码在以下文件中：<br>frameworks/av/media/mediaserver/main_mediaserver.cpp<br>frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp<br>frameworks/native/libs/binder/IServiceManager.cpp<br>frameworks/native/libs/binder/BpBinder.cpp<br>frameworks/native/libs/binder/Parcel.cpp<br>frameworks/native/libs/binder/IPCThreadState.cpp<br>kernel/drivers/staging/android/binder.c</p>
</blockquote>
<p>下图是MediaPlayerService服务注册过程中，MediaPlayerService，Binder Driver，Service Manager之间的一次完整的通信交互过程。</p>
<div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/android-binder-addservice.jpg?raw=true" alt=""><br></div>

<p>首先从MediaPlayerService执行入口开始分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/av/media/mediaserver/main_mediaserver.cpp</span><br><span class="line"></span><br><span class="line">int main(int argc __unused, char **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    ......</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ......</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MediaPlayerService进程启动后首先获取其ProcessState对象，然后通过defaultServiceManager()获取到ServiceManager的代理对象，并在创建并初始化MediaPlayerService服务后，通过ServiceManager代理BpServiceManager将MediaPlayerService服务注册到ServiceManager，随后启动线程池并把主线程加入到Binder线程池中等待Client的请求。下面先看MediaPlayerService::instantiate()的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp</span><br><span class="line"></span><br><span class="line">void MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(&quot;media.player&quot;), new MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过defaultServiceManager()获取的是ServiceManager的代理对象BpServiceManager，MediaPlayerService::instantiate()中通过defaultServiceManager()-&gt;addService()将新创建的MediaPlayerService的服务注册到ServiceManager中。defaultServiceManager()-&gt;addService()的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IServiceManager.cpp</span><br><span class="line"></span><br><span class="line">class BpServiceManager : public BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ......</span><br><span class="line">    virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,</span><br><span class="line">            bool allowIsolated)</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        data.writeStrongBinder(service);</span><br><span class="line">        data.writeInt32(allowIsolated ? 1 : 0);</span><br><span class="line">        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        return err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>addService()中将进程间通信数据封装成Parcel对象，首先通过writeInterfaceToken写入RPC头信息(RPC包括二部分，第一部分是为Int32类型，描述StrictModePolicy。第二部分为String16类型，描述请求的服务接口即”android.os.IServiceManager”)，writeString16(name)写入的是服务的名称，name为”media.player”，writeStrongBinder(service)是将MediaPlayerService封装到flat_binder_object结构体中，writeStrongBinder()的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bionic/libc/kernel/uapi/linux/binder.h</span><br><span class="line"></span><br><span class="line">struct flat_binder_object &#123;</span><br><span class="line">  __u32 type;</span><br><span class="line">  __u32 flags;</span><br><span class="line">  union &#123;</span><br><span class="line">    binder_uintptr_t binder;</span><br><span class="line">    __u32 handle;</span><br><span class="line">  &#125;;</span><br><span class="line">  binder_uintptr_t cookie;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/Parcel.cpp</span><br><span class="line"></span><br><span class="line">status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    return flatten_binder(ProcessState::self(), val, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; /*proc*/, const sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    if (binder != NULL) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        if (!local) &#123;</span><br><span class="line">          ......</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flatten_binder中binder-&gt;localBinder()为MediaPlayerService的BBinder对象，flat_binder_object结构被设置为BINDER_TYPE_BINDER类型，obj.binder保存MediaPlayerService的BBinder弱引用，obj.cookie保存MediaPlayerService的BBinder。最后通过finish_flatten_binder将flat_binder_object写入到Parcel对象out中。<br>在将IPC数据封装城Parcel对象后，将调用remote()-&gt;transact()将数据发送给驱动，根据<strong>Android Binder之Service Manager代理对象</strong>中的分析可知道remote()即BpServiceManager对应的BpBinder对象，下面看BpBinder::transact()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/BpBinder.cpp</span><br><span class="line"></span><br><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status == DEAD_OBJECT) mAlive = 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BpBinder::transact()中参数code为ADD_SERVICE_TRANSACTION，data为封装成Parcel对象的IPC数据，reply为通信返回，flags表示是否为同步通信等的标志。mAliveBinder代理对象所对应的Binder本地对象是否还活着即ServiceManager是否还活着，mHandle是BpBinder中的句柄，由于当前BpBinder对应于BpServiceManager，所以mHandle值为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IPCThreadState.cpp</span><br><span class="line"></span><br><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        ......</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) == 0) &#123;</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err = waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IPCThreadState::transact()中的参数，handle为0，code为ADD_SERVICE_TRANSACTION，data为封装MediaPlayerService信息的Parcel对象，reply为接收反馈数据的Parcel对象，flags默认为0。首先检查Parcel对象中的数据的正确性，并设置参数TF_ACCEPT_FDS位，代表是否允许server的返回结果中携带文件描述符。然后通过writeTransactionData()将IPC数据进一步封装成binder_transaction_data结构并写入mOut缓存中，TF_ONE_WAY判断是否是同步的进程间通信请求的标志，最后通过waitForResponse()将数据发送给驱动并等待驱动返回。下面是writeTransactionData()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IPCThreadState.cpp</span><br><span class="line"></span><br><span class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</span><br><span class="line">    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = 0;</span><br><span class="line">    tr.sender_pid = 0;</span><br><span class="line">    tr.sender_euid = 0;</span><br><span class="line"></span><br><span class="line">    const status_t err = data.errorCheck();</span><br><span class="line">    if (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; else if (statusBuffer) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, sizeof(tr));</span><br><span class="line"></span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>writeTransactionData中将传入的参数打包成binder_transaction_data对象，tr.target.handle = 0，tr.code = ADD_SERVICE_TRANSACTION，tr.flags = TF_ACCEPT_FDS。然后将协议命令BC_TRANSACTION与binder_transaction_data结构先后写入到mOut中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IPCThreadState.cpp</span><br><span class="line"></span><br><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((err=talkWithDriver()) &lt; NO_ERROR) break;</span><br><span class="line">        ......</span><br><span class="line">        if (mIn.dataAvail() == 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd = (uint32_t)mIn.readInt32();</span><br><span class="line">        ......</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            ......</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            ......</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_ACQUIRE_RESULT:</span><br><span class="line">            ......</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_REPLY:</span><br><span class="line">            ......</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            ......</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    ......</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>waitForResponse()中循环地调用talkWithDriver与驱动交互，将封装的进程间通信数据发送给驱动并等待驱动返回，下面是talkWithDriver()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IPCThreadState.cpp</span><br><span class="line"></span><br><span class="line">status_t IPCThreadState::talkWithDriver(bool doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    // Is the read buffer empty?</span><br><span class="line">    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (uintptr_t)mOut.data();</span><br><span class="line"></span><br><span class="line">    // This is what we&apos;ll read.</span><br><span class="line">    if (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (uintptr_t)mIn.data();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bwr.read_size = 0;</span><br><span class="line">        bwr.read_buffer = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    // Return immediately if there is nothing to do.</span><br><span class="line">    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = 0;</span><br><span class="line">    bwr.read_consumed = 0;</span><br><span class="line">    status_t err;</span><br><span class="line">    do &#123;</span><br><span class="line">    ......</span><br><span class="line">#if defined(__ANDROID__)</span><br><span class="line">        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        else</span><br><span class="line">            err = -errno;</span><br><span class="line">#else</span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">#endif</span><br><span class="line">        ......</span><br><span class="line">    &#125; while (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    if (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        if (bwr.write_consumed &gt; 0) &#123;</span><br><span class="line">            if (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(0, bwr.write_consumed);</span><br><span class="line">            else</span><br><span class="line">                mOut.setDataSize(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (bwr.read_consumed &gt; 0) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>talkWithDriver()中使用ioctl BINDER_WRITE_READ命令与驱动进行通讯，数据被再次封装成binder_write_read结构(IPC数据先是封装成Parcel对象，然后封装成cmd + binder_transaction_data对象，最后放到binder_write_read中传递给驱动)，其中bwr.write_buffer，bwr.read_consumed分别与mOut，mIn对应。最后通过ioctl与发送binder_write_read数据给驱动，驱动根据bwr.write_size &gt; 0调用binder_thread_write()处理BC_TRANSACTION数据，同时根据bwr.read_size &gt; 0调用binder_thread_read()处理返回数据。下面看在binder_ioctl()中的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	struct binder_thread *thread;</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	if (thread == NULL) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	case BINDER_WRITE_READ:</span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto err;</span><br><span class="line">		break;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line"> 	......</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_ioctl()中根据io命令BINDER_WRITE_READ，直接进入到binder_ioctl_write_read()进行处理，下面看binder_ioctl_write_read的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">static int binder_ioctl_write_read(struct file *filp,</span><br><span class="line">				unsigned int cmd, unsigned long arg,</span><br><span class="line">				struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line">	struct binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			bwr.read_consumed = 0;</span><br><span class="line">			if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		if (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">			wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_ioctl_write_read中将用户空间的binder_write_read结构的数据拷贝到内核空间bwr中，并根据bwr.write_size及bwr.read_size是否大于０，分别调用binder_thread_write与binder_thread_read进行处理。先看binder_thread_write()中的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">			struct binder_thread *thread,</span><br><span class="line">			binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t cmd;</span><br><span class="line">	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">	void __user *ptr = buffer + *consumed;</span><br><span class="line">	void __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">		if (get_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		ptr += sizeof(uint32_t);</span><br><span class="line">		......</span><br><span class="line">		switch (cmd) &#123;</span><br><span class="line">		......</span><br><span class="line">		case BC_TRANSACTION:</span><br><span class="line">		case BC_REPLY: &#123;</span><br><span class="line">			struct binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">			if (copy_from_user(&amp;tr, ptr, sizeof(tr)))</span><br><span class="line">				return -EFAULT;</span><br><span class="line">			ptr += sizeof(tr);</span><br><span class="line">			binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">		&#125;</span><br><span class="line">		*consumed = ptr - buffer;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_thread_write中参数binder_buffer指向binder_write_read中的write_buffer，从上文已知write_buffer中存放的是BC_TRANSACTION + binder_transaction_data数据，首先获取到协议命令BC_TRANSACTION，然后将BC_TRANSACTION后的数据拷贝到内核空间的binder_transaction_data结构中，并调用binder_transaction()进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">static void binder_transaction(struct binder_proc *proc,</span><br><span class="line">			       struct binder_thread *thread,</span><br><span class="line">			       struct binder_transaction_data *tr, int reply)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_transaction *t;</span><br><span class="line">	struct binder_work *tcomplete;</span><br><span class="line">	binder_size_t *offp, *off_end;</span><br><span class="line">	binder_size_t off_min;</span><br><span class="line">	struct binder_proc *target_proc;</span><br><span class="line">	struct binder_thread *target_thread = NULL;</span><br><span class="line">	struct binder_node *target_node = NULL;</span><br><span class="line">	struct list_head *target_list;</span><br><span class="line">	wait_queue_head_t *target_wait;</span><br><span class="line">	struct binder_transaction *in_reply_to = NULL;</span><br><span class="line">	struct binder_transaction_log_entry *e;</span><br><span class="line">	uint32_t return_error;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	// reply表示cmd是否是BC_REPLY，根据上文这里获取的cmd是BC_TRANSACTION</span><br><span class="line">	if (reply) &#123;</span><br><span class="line">	......</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// 根据target的句柄找到目标binder_ref进而找到binder_node及binder_proc，由于是与ServiceManager通信，这里的handle值为0</span><br><span class="line">		if (tr-&gt;target.handle) &#123;</span><br><span class="line">			struct binder_ref *ref;</span><br><span class="line">			// 根据handle句柄值在proc-&gt;refs_by_desc上查找其对应的binder_ref</span><br><span class="line">			ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">			......</span><br><span class="line">			target_node = ref-&gt;node;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// Service Manager的binder实体为binder_context_mgr_node</span><br><span class="line">			target_node = binder_context_mgr_node;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">		// 根据target的binder_node找到处理事务的目标进程</span><br><span class="line">		target_proc = target_node-&gt;proc;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	//如果找到目标线程target_thread处理事务，则target_list，target_wait指向target_thread，否则指向target_proc</span><br><span class="line">	if (target_thread) &#123;</span><br><span class="line">		target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">		target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">		target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">	&#125;</span><br><span class="line">	// 分配一个待处理的事务binder_transaction对象</span><br><span class="line">	t = kzalloc(sizeof(*t), GFP_KERNEL);</span><br><span class="line">	......</span><br><span class="line">	// 分配一个待完成的工作tcomplete binder_work对象</span><br><span class="line">	tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line">	......</span><br><span class="line">	if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">		t-&gt;from = thread;</span><br><span class="line">	else</span><br><span class="line">		t-&gt;from = NULL;</span><br><span class="line">	// 初始化binder_transaction对象各成员</span><br><span class="line">	t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">	t-&gt;to_proc = target_proc;</span><br><span class="line">	t-&gt;to_thread = target_thread;</span><br><span class="line">	t-&gt;code = tr-&gt;code;</span><br><span class="line">	t-&gt;flags = tr-&gt;flags;</span><br><span class="line">	t-&gt;priority = task_nice(current);</span><br><span class="line">	// 为target_proc分配内核缓冲区，以便接受IPC数据</span><br><span class="line">	t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">		tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">	if (t-&gt;buffer == NULL) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		goto err_binder_alloc_buf_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;buffer-&gt;allow_user_free = 0;</span><br><span class="line">	t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">	t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">	t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">	trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">	if (target_node)</span><br><span class="line">		binder_inc_node(target_node, 1, 0, NULL);</span><br><span class="line"></span><br><span class="line">	offp = (binder_size_t *)(t-&gt;buffer-&gt;data +</span><br><span class="line">				 ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line">	// 将IPC数据拷贝到target_proc的内核缓冲区</span><br><span class="line">	if (copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t)</span><br><span class="line">			   tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">		......           </span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	if (copy_from_user(offp, (const void __user *)(uintptr_t)</span><br><span class="line">			   tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">		......    </span><br><span class="line">		goto err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	......    </span><br><span class="line">	off_end = (void *)offp + tr-&gt;offsets_size;</span><br><span class="line">	off_min = 0;</span><br><span class="line">	// 循环处理IPC数据中的Binder对象</span><br><span class="line">	for (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">		struct flat_binder_object *fp;</span><br><span class="line">		......</span><br><span class="line">		fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">		off_min = *offp + sizeof(struct flat_binder_object);</span><br><span class="line">		// 从上文可知类型为BINDER_TYPE_BINDER</span><br><span class="line">		switch (fp-&gt;type) &#123;</span><br><span class="line">		case BINDER_TYPE_BINDER:</span><br><span class="line">		case BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">			struct binder_ref *ref;</span><br><span class="line">			// 根据BBinder的引用从当前的binder_proc中的获取对应的binder_node</span><br><span class="line">			struct binder_node *node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">			// 根据上文可知，这里node == NULL，所以为MediaPlayerService新建binder实体binder_node</span><br><span class="line">			if (node == NULL) &#123;</span><br><span class="line">				node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">				......</span><br><span class="line">				node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">				node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">			&#125;</span><br><span class="line">			......</span><br><span class="line">			// 在ServiceManager的binder_proc中找对应MediaPlayerService的binder_ref，如果没有找到则为其新建binder_ref加入到其红黑树中(同时为binder_ref分配句柄值)</span><br><span class="line">			ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line">			if (ref == NULL) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				goto err_binder_get_ref_for_node_failed;</span><br><span class="line">			&#125;</span><br><span class="line">			if (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">				fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">			else</span><br><span class="line">				fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">			fp-&gt;binder = 0;</span><br><span class="line">			fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">			fp-&gt;cookie = 0;</span><br><span class="line">			binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">				       &amp;thread-&gt;todo);</span><br><span class="line">		&#125; break;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	if (reply) &#123;</span><br><span class="line">	......</span><br><span class="line">	// 根据TF_ONE_WAY判断是否是同步通信</span><br><span class="line">	&#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">		t-&gt;need_reply = 1;</span><br><span class="line">		t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">		thread-&gt;transaction_stack = t;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (target_node-&gt;has_async_transaction) &#123;</span><br><span class="line">			target_list = &amp;target_node-&gt;async_todo;</span><br><span class="line">			target_wait = NULL;</span><br><span class="line">		&#125; else</span><br><span class="line">			target_node-&gt;has_async_transaction = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	// 将t封装成BINDER_WORK_TRANSACTION的工作项，放到ServiceManager的proc或thread的todo列表中</span><br><span class="line">	t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">	list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">	// 将tcomplete置为BINDER_WORK_TRANSACTION_COMPLETE，并放在源线程的todo列表中</span><br><span class="line">	tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">	list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">	// 唤醒目标进程</span><br><span class="line">	if (target_wait) &#123;</span><br><span class="line">		if (reply || !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">			preempt_disable();</span><br><span class="line">			wake_up_interruptible_sync(target_wait);</span><br><span class="line">			preempt_enable_no_resched();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			wake_up_interruptible(target_wait);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_transaction()的主要工作是解析binder_transaction，根据通信目标handle值tr-&gt;target.handle找到其对应的binder_ref，通过binder_ref找到binder_node，进而找到目标进程binder_proc。在MediaPlayerService向ServiceManager注册时，handle值为0，可直接找到ServiceManager的binder实体binder_context_mgr_node，进而找到其binder_proc，同时为MediaPlayerService新建binder_node实体，然后将其引用binder_ref挂到ServiceManager的binder_proc的引用列表上。然后查找ServiceManager的空闲线程，如果找到其空闲的线程，将封装成BINDER_WORK_TRANSACTION类型的binder_transaction事务放到binder_thread的todo列表上，如果没有找到空闲的线程，则放在binder_proc的todo列表上。同时也将封装BINDER_WORK_TRANSACTION_COMPLETE类型的binder_work放到ServiceManager的proc或thread的todo列表中，然后唤醒目标进程执行。<br>此时，源线程与目标线程都会去执行其todo队列中待处理的事物，下面先看源线程MediaPlayerService中的处理，再看目标进程ServiceManager中的处理。源线程从binder_transaction()返回到binder_thread_write()然后返回到binder_ioctl_write_read()，继续执行binder_ioctl_write_read()中的binder_thread_read()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_read(struct binder_proc *proc,</span><br><span class="line">			      struct binder_thread *thread,</span><br><span class="line">			      binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			      binder_size_t *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line">	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">	void __user *ptr = buffer + *consumed;</span><br><span class="line">	void __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	int ret = 0;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	while (1) &#123;</span><br><span class="line">		uint32_t cmd;</span><br><span class="line">		struct binder_transaction_data tr;</span><br><span class="line">		struct binder_work *w;</span><br><span class="line">		struct binder_transaction *t = NULL;</span><br><span class="line"></span><br><span class="line">		if (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">			w = list_first_entry(&amp;thread-&gt;todo, struct binder_work,</span><br><span class="line">					     entry);</span><br><span class="line">		&#125; else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">			w = list_first_entry(&amp;proc-&gt;todo, struct binder_work,</span><br><span class="line">					     entry);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/* no data added */</span><br><span class="line">			if (ptr - buffer == 4 &amp;&amp;</span><br><span class="line">			    !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN))</span><br><span class="line">				goto retry;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">		case BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">			cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">			if (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">				return -EFAULT;</span><br><span class="line">			ptr += sizeof(uint32_t);</span><br><span class="line"></span><br><span class="line">			binder_stat_br(proc, thread, cmd);</span><br><span class="line"></span><br><span class="line">			list_del(&amp;w-&gt;entry);</span><br><span class="line">			kfree(w);</span><br><span class="line">			binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">		&#125; break;　</span><br><span class="line">		......</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line">done:</span><br><span class="line">	*consumed = ptr - buffer;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_ioctl_write_read()中从thread-&gt;todo或proc-&gt;todo读取到BINDER_WORK_TRANSACTION_COMPLETE工作项，写入到用户空间的bwr.read_buffer中并返回到用户空间，接下来便又回到waitForResponse中处理。<br>接下来看ServiceManager端的处理，在<strong>Android Binder之Service Manager</strong>中已经分析到ServiceManager启动后进入到binder_thread_read()，等待其todo队列上的事务。前面已分析到Binder Driver已经将一个BINDER_WORK_TRANSACTION的工作项加入到ServiceManager的todo队列中，那么ServiceManager被唤醒处理该事务，下面从ServiceManager的binder_thread_read()开始分析其过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">static int binder_thread_read(struct binder_proc *proc,</span><br><span class="line">			      struct binder_thread *thread,</span><br><span class="line">			      binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			      binder_size_t *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line">	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">	void __user *ptr = buffer + *consumed;</span><br><span class="line">	void __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	int ret = 0;</span><br><span class="line">	......</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		uint32_t cmd;</span><br><span class="line">		struct binder_transaction_data tr;</span><br><span class="line">		struct binder_work *w;</span><br><span class="line">		struct binder_transaction *t = NULL;</span><br><span class="line"></span><br><span class="line">		// 检查thread-&gt;todo上是否有工作项需要处理</span><br><span class="line">		if (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">			w = list_first_entry(&amp;thread-&gt;todo, struct binder_work,</span><br><span class="line">					     entry);</span><br><span class="line">		// 检查proc-&gt;todo上是否有工作项需要处理</span><br><span class="line">		&#125; else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">			w = list_first_entry(&amp;proc-&gt;todo, struct binder_work,</span><br><span class="line">					     entry);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			/* no data added */</span><br><span class="line">			if (ptr - buffer == 4 &amp;&amp;</span><br><span class="line">			    !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN))</span><br><span class="line">				goto retry;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br><span class="line">		switch (w-&gt;type) &#123;</span><br><span class="line">		// 前文已知，BINDER_WORK_TRANSACTION类型的工作项被加入到ServiceManager的todo队列中</span><br><span class="line">		case BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">			// 根据binder_transaction中的work成员获取binder_transaction</span><br><span class="line">			t = container_of(w, struct binder_transaction, work);</span><br><span class="line">		&#125; break;</span><br><span class="line">		......</span><br><span class="line">		// target_node指向binder_context_mgr_node</span><br><span class="line">		if (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">			struct binder_node *target_node = t-&gt;buffer-&gt;target_node;</span><br><span class="line">			// 构造BR_TRANSACTION类型的binder_transaction_data</span><br><span class="line">			tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">			tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">			t-&gt;saved_priority = task_nice(current);</span><br><span class="line">			if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;</span><br><span class="line">			    !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">				binder_set_nice(t-&gt;priority);</span><br><span class="line">			else if (!(t-&gt;flags &amp; TF_ONE_WAY) ||</span><br><span class="line">				 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">				binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">			cmd = BR_TRANSACTION;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			tr.target.ptr = 0;</span><br><span class="line">			tr.cookie = 0;</span><br><span class="line">			cmd = BR_REPLY;</span><br><span class="line">		&#125;</span><br><span class="line">		tr.code = t-&gt;code;</span><br><span class="line">		tr.flags = t-&gt;flags;</span><br><span class="line">		tr.sender_euid = from_kuid(current_user_ns(), t-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">		if (t-&gt;from) &#123;</span><br><span class="line">			struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;</span><br><span class="line"></span><br><span class="line">			tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">							task_active_pid_ns(current));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">		tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">		tr.data.ptr.buffer = (binder_uintptr_t)(</span><br><span class="line">					(uintptr_t)t-&gt;buffer-&gt;data +</span><br><span class="line">					proc-&gt;user_buffer_offset);</span><br><span class="line">		tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">					ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">					    sizeof(void *));</span><br><span class="line">		// 将tr拷贝到用户空间缓冲区</span><br><span class="line">		if (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		ptr += sizeof(uint32_t);</span><br><span class="line">		if (copy_to_user(ptr, &amp;tr, sizeof(tr)))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		ptr += sizeof(tr);</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">		list_del(&amp;t-&gt;work.entry);</span><br><span class="line">		t-&gt;buffer-&gt;allow_user_free = 1;</span><br><span class="line">		if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">			t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">			t-&gt;to_thread = thread;</span><br><span class="line">			thread-&gt;transaction_stack = t;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			t-&gt;buffer-&gt;transaction = NULL;</span><br><span class="line">			kfree(t);</span><br><span class="line">			binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ServiceManager的主线程在binder_thread_read()中被唤醒后，将回到用户空间处理收到的IPC数据，调用binder_parse()进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/cmds/servicemanager/binder.c</span><br><span class="line"></span><br><span class="line">int binder_parse(struct binder_state *bs, struct binder_io *bio,</span><br><span class="line">                 uintptr_t ptr, size_t size, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int r = 1;</span><br><span class="line">    uintptr_t end = ptr + (uintptr_t) size;</span><br><span class="line"></span><br><span class="line">    while (ptr &lt; end) &#123;</span><br><span class="line">        uint32_t cmd = *(uint32_t *) ptr;</span><br><span class="line">        ptr += sizeof(uint32_t);</span><br><span class="line">        ......</span><br><span class="line">        switch(cmd) &#123;</span><br><span class="line">        ......</span><br><span class="line">        case BR_TRANSACTION: &#123;</span><br><span class="line">            struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: txn too small!\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (func) &#123;</span><br><span class="line">                unsigned rdata[256/4];</span><br><span class="line">                struct binder_io msg;</span><br><span class="line">                struct binder_io reply;</span><br><span class="line">                int res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, sizeof(rdata), 4);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                // 消息处理</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                if (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += sizeof(*txn);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_parse()中读取cmd与binder_transaction_data数据，并调用svcmgr_handler()进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int svcmgr_handler(struct binder_state *bs,</span><br><span class="line">                   struct binder_transaction_data *txn,</span><br><span class="line">                   struct binder_io *msg,</span><br><span class="line">                   struct binder_io *reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line">    uint16_t *s;</span><br><span class="line">    size_t len;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    uint32_t strict_policy;</span><br><span class="line">    int allow_isolated;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // Equivalent to Parcel::enforceInterface(), reading the RPC</span><br><span class="line">    // header with the strict mode policy mask and the interface name.</span><br><span class="line">    // Note that we ignore the strict_policy and don&apos;t propagate it</span><br><span class="line">    // further (since we do no outbound RPCs anyway).</span><br><span class="line">    strict_policy = bio_get_uint32(msg);</span><br><span class="line">    s = bio_get_string16(msg, &amp;len);</span><br><span class="line">    if (s == NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((len != (sizeof(svcmgr_id) / 2)) ||</span><br><span class="line">        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) &#123;</span><br><span class="line">        fprintf(stderr,&quot;invalid id %s\n&quot;, str8(s, len));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    switch(txn-&gt;code) &#123;</span><br><span class="line">    ......</span><br><span class="line">    case SVC_MGR_ADD_SERVICE:</span><br><span class="line">        // 获取注册服务的名称</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        if (s == NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取注册服务的句柄</span><br><span class="line">        handle = bio_get_ref(msg);</span><br><span class="line">        allow_isolated = bio_get_uint32(msg) ? 1 : 0;</span><br><span class="line">        // 注册服务</span><br><span class="line">        if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            return -1;</span><br><span class="line">        break;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终，服务将被注册到svclist链表中。前面说到Service组件在Server进程启动时会将Service注册到Service Manager，然后启动Binder线程池等待并处理Client的请求，下面分析Binder线程池的启动过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/av/media/mediaserver/main_mediaserver.cpp</span><br><span class="line"></span><br><span class="line">int main(int argc __unused, char **argv __unused)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    ......</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ......</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到MediaPlayerService进程的main()函数，通过ProcessState::self()-&gt;startThreadPool()启动线程池，并通过IPCThreadState::self()-&gt;joinThreadPool()将当前线程加入到线程池中等待并处理客户端的请求。先看startThreadPool()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/ProcessState.cpp</span><br><span class="line"></span><br><span class="line">void ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    if (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = true;</span><br><span class="line">        spawnPooledThread(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>startThreadPool()中通过mThreadPoolStarted判断是否已经启动线程池，调用spawnPooledThread()启动线程池。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/ProcessState.cpp</span><br><span class="line"></span><br><span class="line">void ProcessState::spawnPooledThread(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    if (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(&quot;Spawning new pooled thread, name=%s\n&quot;, name.string());</span><br><span class="line">        sp&lt;Thread&gt; t = new PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>spawnPooledThread()中创建一个PoolThread对象(PoolThread继承与Thread)，并通过其run函数来启动一个新线程。接下来继续看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IPCThreadState.cpp</span><br><span class="line"></span><br><span class="line">void IPCThreadState::joinThreadPool(bool isMain)</span><br><span class="line">&#123;</span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    status_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        // now get the next command to be processed, waiting if necessary</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) &#123;</span><br><span class="line">            ALOGE(&quot;getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting&quot;,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Let this thread exit the thread pool if it is no longer</span><br><span class="line">        // needed and it is not the main process thread.</span><br><span class="line">        if(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终，MediaPlayerService通过向驱动发送BC_ENTER_LOOPER完成Binder线程注册的过程。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之进程间通信库]]></title>
      <url>http://robinheztto.com/2016/03/28/android-binder-3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>为了方便对Binder驱动的操作及上层调用，Binder通信的细节及与驱动交互的过程都被封装到了libbinder库中。libbinder相关的源码位于frameworks/native/libs/binder下，本篇分析libbinder库中的基础类。</p>
</blockquote>
<h1 id="RefBase"><a href="#RefBase" class="headerlink" title="RefBase"></a>RefBase</h1><p>RefBase在system/core/include/utils/RefBase.h中定义，它是一个公共父类，声明了引用计数操作相关的接口，继承RefBase的子类能通过强指针与弱指针维护它们的生命周期。</p>
<h1 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h1><p>每个使用Binder进程间通信的进程内部都有一个ProcessState对象，它负责与binder驱动建立联系。ProcessState对象通过静态成员函数self()来获取，其成员mDriverFD保存了打开设备文件/dev/binder的句柄值，mVMStart保存映射的内核缓冲区对应用户空间的起始地址。其中mHandleToObject是一个Vector矢量数组，保存着驱动中Binder引用的句柄值及其对应的BpBinder对象(Binder引用即Binder驱动中的binder_ref，BpBinder即binder的代理类)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/ProcessState.h</span><br><span class="line"></span><br><span class="line">class ProcessState : public virtual RefBase</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static  sp&lt;ProcessState&gt;    self();</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;IBinder&gt;         getContextObject(const sp&lt;IBinder&gt;&amp; caller);</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;IBinder&gt;         getContextObject(const String16&amp; name,</span><br><span class="line">                                                 const sp&lt;IBinder&gt;&amp; caller);</span><br><span class="line">            void                startThreadPool();</span><br><span class="line">            ......</span><br><span class="line">private:</span><br><span class="line">            ......</span><br><span class="line">            struct handle_entry &#123;</span><br><span class="line">                IBinder* binder;</span><br><span class="line">                RefBase::weakref_type* refs;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            handle_entry*       lookupHandleLocked(int32_t handle);</span><br><span class="line"></span><br><span class="line">            int                 mDriverFD;</span><br><span class="line">            void*               mVMStart;</span><br><span class="line">            ......</span><br><span class="line">            size_t              mMaxThreads;</span><br><span class="line">            ......</span><br><span class="line">            Vector&lt;handle_entry&gt;mHandleToObject;</span><br><span class="line">            ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="IPCThreadState"><a href="#IPCThreadState" class="headerlink" title="IPCThreadState"></a>IPCThreadState</h1><p>每个使用Binder进程间通信的进程都有一个binder线程池，每个线程都对应一个IPCThreadState对象，它负责与驱动的具体交互，收发进程间通信数据等。IPCThreadState对象通过静态成员函数self()获取，mProcess指向ProcessState对象(每个进程中只存在一个ProcessState对象)。transact()函数负责向驱动发送进程间通信数据，talkWithDriver()负责与驱动的具体交互。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IPCThreadState.h</span><br><span class="line"></span><br><span class="line">class IPCThreadState</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static  IPCThreadState*     self();</span><br><span class="line">            ......</span><br><span class="line">            status_t            transact(int32_t handle,</span><br><span class="line">                                         uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                         Parcel* reply, uint32_t flags);</span><br><span class="line">            ......</span><br><span class="line">private:</span><br><span class="line">            ......</span><br><span class="line">            status_t            talkWithDriver(bool doReceive=true);</span><br><span class="line">            ......</span><br><span class="line">            const   sp&lt;ProcessState&gt;    mProcess;</span><br><span class="line">            const   pid_t               mMyThreadId;</span><br><span class="line">            Parcel              mIn;</span><br><span class="line">            Parcel              mOut;</span><br><span class="line">            const   sp&lt;ProcessState&gt;    mProcess;</span><br><span class="line">            const   pid_t               mMyThreadId;</span><br><span class="line">            ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="IBinder"><a href="#IBinder" class="headerlink" title="IBinder"></a>IBinder</h1><p>IBinder是一个基础类，BpBinder与BBinder都继承于它，其中成员函数remoteBinder()用于获取远程Binder BpBinder，localBinder()用于获取本地Binder BBinder。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IBinder.h</span><br><span class="line"></span><br><span class="line">class IBinder : public virtual RefBase</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual sp&lt;IInterface&gt;  queryLocalInterface(const String16&amp; descriptor);</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">    virtual status_t        transact(   uint32_t code,</span><br><span class="line">                                        const Parcel&amp; data,</span><br><span class="line">                                        Parcel* reply,</span><br><span class="line">                                        uint32_t flags = 0) = 0;</span><br><span class="line">    ......</span><br><span class="line">    virtual BBinder*        localBinder();</span><br><span class="line">    virtual BpBinder*       remoteBinder();</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="BBinder"><a href="#BBinder" class="headerlink" title="BBinder"></a>BBinder</h1><p>BBinder即Binder本地对象，继承于IBinder，它有一个非常重要的成员函数onTransact()，Server收到进程间通信请求后，会调用onTransact()进行分发处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/Binder.h</span><br><span class="line"></span><br><span class="line">class BBinder : public IBinder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ......</span><br><span class="line">    virtual BBinder*    localBinder();</span><br><span class="line">protected:</span><br><span class="line">    virtual status_t    onTransact( uint32_t code,</span><br><span class="line">                                    const Parcel&amp; data,</span><br><span class="line">                                    Parcel* reply,</span><br><span class="line">                                    uint32_t flags = 0);</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="BpBinder"><a href="#BpBinder" class="headerlink" title="BpBinder"></a>BpBinder</h1><p>BpBinder即Binder远程对象，继承于IBinder，它也有一个非常重要的成员函数transact()，BpBinder的transact()会调用IPCThreadState的transact()进行处理。BpBinder中有一成员mHandle，用于保存驱动中Binder引用的句柄，通过这个句柄就可以与驱动中的binder引用关联，其中0代表ServiceManager的binder引用的句柄。当BpBinder通过transact()向驱动发送进程间通信请求时，会将句柄值mHandle发送给驱动，这样驱动就能找到其对应的Binder引用对象，进而找到Binder实体对象，最后就可以找到通信的Service组件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/BpBinder.h</span><br><span class="line"></span><br><span class="line">class BpBinder : public IBinder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">                        BpBinder(int32_t handle);</span><br><span class="line">    inline  int32_t     handle() const &#123; return mHandle; &#125;</span><br><span class="line">    ......</span><br><span class="line">    virtual status_t    transact(   uint32_t code,</span><br><span class="line">                                    const Parcel&amp; data,</span><br><span class="line">                                    Parcel* reply,</span><br><span class="line">                                    uint32_t flags = 0);</span><br><span class="line">    ......</span><br><span class="line">private:</span><br><span class="line">    const   int32_t             mHandle;</span><br><span class="line">    .....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="BpRefBase"><a href="#BpRefBase" class="headerlink" title="BpRefBase"></a>BpRefBase</h1><p>BpRefBase中有一重要的成员mRemote，它指向BpBinder对象，并可通过成员函数remote()获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/Binder.h</span><br><span class="line"></span><br><span class="line">class BpRefBase : public virtual RefBase</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">                            BpRefBase(const sp&lt;IBinder&gt;&amp; o);</span><br><span class="line">    ......</span><br><span class="line">    inline  IBinder*        remote()                &#123; return mRemote; &#125;</span><br><span class="line">    inline  IBinder*        remote() const          &#123; return mRemote; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    ......</span><br><span class="line">    IBinder* const          mRemote;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="IInterface"><a href="#IInterface" class="headerlink" title="IInterface"></a>IInterface</h1><p>IInterface在frameworks/native/include/binder/IInterface.h中定义，它也是一个公共父类。</p>
<h1 id="BnInterface"><a href="#BnInterface" class="headerlink" title="BnInterface"></a>BnInterface</h1><p>BnInterface是一个模板类，同时继承了BBinder和INTERFACE，本地服务通过继承BpInterface来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IInterface.h</span><br><span class="line"></span><br><span class="line">template&lt;typename INTERFACE&gt;</span><br><span class="line">class BnInterface : public INTERFACE, public BBinder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual sp&lt;IInterface&gt;      queryLocalInterface(const String16&amp; _descriptor);</span><br><span class="line">    virtual const String16&amp;     getInterfaceDescriptor() const;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    virtual IBinder*            onAsBinder();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="BpInterface"><a href="#BpInterface" class="headerlink" title="BpInterface"></a>BpInterface</h1><p>BpInterface也是一个模板类，同时继承了BpRefBase和INTERFACE，服务代理通过继承BpInterface来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IInterface.h</span><br><span class="line"></span><br><span class="line">template&lt;typename INTERFACE&gt;</span><br><span class="line">class BpInterface : public INTERFACE, public BpRefBase</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">                                BpInterface(const sp&lt;IBinder&gt;&amp; remote);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    virtual IBinder*            onAsBinder();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之Service Manager代理对象]]></title>
      <url>http://robinheztto.com/2016/03/28/android-binder-4/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Service组件在启动时需要将自己注册到Server Manager，Client组件在使用Service的服务前也需要从Service Manager获取到Service的代理对象，但由于Service Manager运行在一个独立的进程当中，Client组件或Service组件在请求Service Manager服务前，首先得获取到Service Manager的代理对象，本篇主要分析Service Manager代理对象获取的流程。</p>
<p>相关的源码在以下文件中：<br>frameworks/native/include/binder/IServiceManager.h<br>frameworks/native/libs/binder/IServiceManager.cpp<br>frameworks/native/libs/binder/Static.cpp<br>frameworks/native/libs/binder/ProcessState.cpp<br>frameworks/native/libs/binder/BpBinder.cpp<br>frameworks/native/libs/binder/IPCThreadState.cpp<br>frameworks/native/include/binder/IInterface.h</p>
</blockquote>
<p>Service Manager代理对象类型为BpServiceManager，它继承于BpInterface并实现了IServiceManager接口，Frameworks层libbinder提供defaultServiceManager接口用来获取BpServiceManager对象。下图是defaultServiceManager()的执行流程。<br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/android-defaultServiceManager.jpg?raw=true" alt="defaultServiceManager执行流程"><br>接下来按照上图的流程进行分析，首先看一下IServiceManager的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IServiceManager.h</span><br><span class="line"></span><br><span class="line">class IServiceManager : public IInterface</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    DECLARE_META_INTERFACE(ServiceManager);</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IBinder&gt;         getService( const String16&amp; name) const = 0;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IBinder&gt;         checkService( const String16&amp; name) const = 0;</span><br><span class="line"></span><br><span class="line">    virtual status_t            addService( const String16&amp; name,</span><br><span class="line">                                            const sp&lt;IBinder&gt;&amp; service,</span><br><span class="line">                                            bool allowIsolated = false) = 0;</span><br><span class="line"></span><br><span class="line">    virtual Vector&lt;String16&gt;    listServices() = 0;</span><br><span class="line"></span><br><span class="line">    enum &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>IServiceManager中定义了getService，checkService，addService，listServices四个成员函数，即Service Manager提供给client用来获取/注册服务的的接口，client获取到Service Manager代理对象后，就能通过这些接口获取注册到Service Manager中服务的信息。下面开始分析如何通过defaultServiceManager()获取Service Manager代理对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; defaultServiceManager()在frameworks/native/libs/binder/IServiceManager.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        while (gDefaultServiceManager == NULL) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(NULL));</span><br><span class="line">            if (gDefaultServiceManager == NULL)</span><br><span class="line">                sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gDefaultServiceManager是指向Service Manager代理对象BpServiceManager的强指针，一个进程只存在一个BpServiceManager代理对象，defaultServiceManager()中通过gDefaultServiceManager判断是否已经创建过Service Manager代理对象，如果已经创建过，则直接返回其指针gDefaultServiceManager，否则为获取当前进程的Service Manager代理对象并保存在gDefaultServiceManager中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/Static.cpp</span><br><span class="line"></span><br><span class="line">Mutex gDefaultServiceManagerLock;</span><br><span class="line">sp&lt;IServiceManager&gt; gDefaultServiceManager;</span><br></pre></td></tr></table></figure></p>
<p>defaultServiceManager()中的gDefaultServiceManager的获取即：<br><code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL));</code><br>首先看ProcessState::self()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/ProcessState.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    if (gProcess != NULL) &#123;</span><br><span class="line">        return gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = new ProcessState;</span><br><span class="line">    return gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProcessState::self()即返回ProcessState的对象，每个进程只存在一个ProcessState对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/Static.cpp</span><br><span class="line"></span><br><span class="line">Mutex gProcessMutex;</span><br><span class="line">sp&lt;ProcessState&gt; gProcess;</span><br></pre></td></tr></table></figure></p>
<p>继续看new ProcessState的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/ProcessState.cpp</span><br><span class="line"></span><br><span class="line">#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span><br><span class="line">#define DEFAULT_MAX_BINDER_THREADS 15</span><br><span class="line"></span><br><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(0)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(0)</span><br><span class="line">    , mManagesContexts(false)</span><br><span class="line">    , mBinderContextCheckFunc(NULL)</span><br><span class="line">    , mBinderContextUserData(NULL)</span><br><span class="line">    , mThreadPoolStarted(false)</span><br><span class="line">    , mThreadPoolSeq(1)</span><br><span class="line">&#123;</span><br><span class="line">    if (mDriverFD &gt;= 0) &#123;</span><br><span class="line">        // mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class="line">        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class="line">        if (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            // *sigh*</span><br><span class="line">            ALOGE(&quot;Using /dev/binder failed: unable to mmap transaction memory.\n&quot;);</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int open_driver()</span><br><span class="line">&#123;</span><br><span class="line">    int fd = open(&quot;/dev/binder&quot;, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (fd &gt;= 0) &#123;</span><br><span class="line">        int vers = 0;</span><br><span class="line">        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">            ALOGE(&quot;Binder driver protocol does not match user space protocol!&quot;);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        if (result == -1) &#123;</span><br><span class="line">            ALOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGW(&quot;Opening &apos;/dev/binder&apos; failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProcessState()的构造函数中主要执行的是对/dev/binder的操作，打开/dev/binder并将fd保存在mDriverFD中，通过ioctl设置binder通信线程池最大线程数为BINDER_SET_MAX_THREADS 15个，mmap映射BINDER_VM_SIZE 1016kb大小缓冲区。open()，mmap()在驱动章节已分析过，下面分析ioctl() BINDER_SET_MAX_THREADS的流程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	struct binder_thread *thread;</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line">	......</span><br><span class="line">	binder_lock(__func__);</span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	if (thread == NULL) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	......</span><br><span class="line">	case BINDER_SET_MAX_THREADS:</span><br><span class="line">		if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		.....</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_ioctl BINDER_SET_MAX_THREADS即设置proc-&gt;max_threads。继续看ProcessState::self()-&gt;getContextObject(NULL)的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/ProcessState.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)</span><br><span class="line">&#123;</span><br><span class="line">    return getStrongProxyForHandle(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getContextObject返回的是sp<ibinder>对象，即返回的是Service Manager的BpBinder对象，直接通过getStrongProxyForHandle(0)实现，Service Manager作为一个特殊的Service组件，它对应的句柄值是０。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/ProcessState.cpp</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e != NULL) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle == 0) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status == DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            b = new BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            if (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></ibinder></p>
<p>每个ProcessState中都维护一个了handle_entry类型的BpBinder代理对象列表，以句柄值为索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class ProcessState : public virtual RefBase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            struct handle_entry &#123;</span><br><span class="line">                IBinder* binder;</span><br><span class="line">                RefBase::weakref_type* refs;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            handle_entry*       lookupHandleLocked(int32_t handle);</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>getStrongProxyForHandle()通过lookupHandleLocked()根据句柄值在mHandleToObject中查找对应的handle_entry，如果不存在，则新建handle_entry并保存在mHandleToObject中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    const size_t N=mHandleToObject.size();</span><br><span class="line">    if (N &lt;= (size_t)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = NULL;</span><br><span class="line">        e.refs = NULL;</span><br><span class="line">        status_t err = mHandleToObject.insertAt(e, N, handle+1-N);</span><br><span class="line">        if (err &lt; NO_ERROR) return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>找到handle_entry后判断handle_entry-&gt;binder是否存在，如果不存在，则根据句柄值handle创建新的BpBinder对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/BpBinder.cpp</span><br><span class="line"></span><br><span class="line">BpBinder::BpBinder(int32_t handle)</span><br><span class="line">    : mHandle(handle)</span><br><span class="line">    , mAlive(1)</span><br><span class="line">    , mObitsSent(0)</span><br><span class="line">    , mObituaries(NULL)</span><br><span class="line">&#123;</span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    IPCThreadState::self()-&gt;incWeakHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将句柄handle保存到私有成员mHandle中，并通过IPCThreadState增加Service Manager实体的引用计数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IPCThreadState.cpp</span><br><span class="line"></span><br><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        return new IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        int key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value != 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = true;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IPCThreadState::self中获取IPCThreadState对象。若该对象已经存在，则直接返回，否则新建IPCThreadState对象。<br>至此，<code>ProcessState::self()-&gt;getContextObject(NULL))</code>执行完成，它返回的是Service Manager的Bpbinder对象，即<code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(Bpbinder(0))</code>，继续看interface_cast<iservicemanager>()的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IInterface.h</span><br><span class="line"></span><br><span class="line">template&lt;typename INTERFACE&gt;</span><br><span class="line">inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    return INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></iservicemanager></p>
<p>即IServiceManager::asInterface(Bpbinder(0))，但asInterface并未直接在IServiceManager中定义，而是通过宏 <strong>DECLARE_META_INTERFACE(ServiceManager)</strong>, <strong>IMPLEMENT_META_INTERFACE(ServiceManager, “android.os.IServiceManager”)</strong> 来实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IInterface.h</span><br><span class="line"></span><br><span class="line">#define DECLARE_META_INTERFACE(INTERFACE)                               \</span><br><span class="line">    static const android::String16 descriptor;                          \</span><br><span class="line">    static android::sp&lt;I##INTERFACE&gt; asInterface(                       \</span><br><span class="line">            const android::sp&lt;android::IBinder&gt;&amp; obj);                  \</span><br><span class="line">    virtual const android::String16&amp; getInterfaceDescriptor() const;    \</span><br><span class="line">    I##INTERFACE();                                                     \</span><br><span class="line">    virtual ~I##INTERFACE();                                            \</span><br><span class="line"></span><br><span class="line">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span><br><span class="line">    const android::String16 I##INTERFACE::descriptor(NAME);             \</span><br><span class="line">    const android::String16&amp;                                            \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return I##INTERFACE::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \</span><br><span class="line">            const android::sp&lt;android::IBinder&gt;&amp; obj)                   \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        android::sp&lt;I##INTERFACE&gt; intr;                                 \</span><br><span class="line">        if (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I##INTERFACE::descriptor).get());               \</span><br><span class="line">            if (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new Bp##INTERFACE(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure></p>
<p>将INTERFACE以ServiceManager替换展开如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define DECLARE_META_INTERFACE(ServiceManager)                               \</span><br><span class="line">    static const android::String16 descriptor;                          \</span><br><span class="line">    static android::sp&lt;IServiceManager&gt; asInterface(                       \</span><br><span class="line">            const android::sp&lt;android::IBinder&gt;&amp; obj);                  \</span><br><span class="line">    virtual const android::String16&amp; getInterfaceDescriptor() const;    \</span><br><span class="line">    IServiceManager;                                                     \</span><br><span class="line">    virtual ~IServiceManager();                                            \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define IMPLEMENT_META_INTERFACE(ServiceManager, &quot;android.os.IServiceManager&quot;)                       \</span><br><span class="line">    const android::String16 IServiceManager::descriptor(&quot;android.os.IServiceManager&quot;);             \</span><br><span class="line">    const android::String16&amp;                                            \</span><br><span class="line">            IServiceManager::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        return IServiceManager::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(                \</span><br><span class="line">            const android::sp&lt;android::IBinder&gt;&amp; obj)                   \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        android::sp&lt;IServiceManager&gt; intr;                                 \</span><br><span class="line">        if (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;IServiceManager*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        IServiceManager::descriptor).get());               \</span><br><span class="line">            if (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = new BpServiceManager(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        return intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    IServiceManager::IServiceManager() &#123; &#125;                                    \</span><br><span class="line">    IServiceManager::~IServiceManager() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure></p>
<p>IServiceManager::asInterface()的实现如下，asInterface()即根据Bpbinder对象获取IServiceManager。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj)              </span><br><span class="line">&#123;                                                                </span><br><span class="line">    android::sp&lt;IServiceManager&gt; intr;                                </span><br><span class="line">    if (obj != NULL) &#123;                                              </span><br><span class="line">        intr = static_cast&lt;IServiceManager*&gt;(                          </span><br><span class="line">            obj-&gt;queryLocalInterface(                               </span><br><span class="line">                    IServiceManager::descriptor).get());               </span><br><span class="line">        if (intr == NULL) &#123;                                         </span><br><span class="line">            intr = new BpServiceManager(obj);                          </span><br><span class="line">        &#125;                                                           </span><br><span class="line">    &#125;                                                               </span><br><span class="line">    return intr;                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 参数obj即BpBinder(0)，obj-&gt;queryLocalInterface(“android.os.IServiceManager”)查找名称为”android.os.IServiceManager”的本地接口，queryLocalInterface()的实现在BpBinder的父类IBinder中，现在IServiceManager接口还没创建，intr=NULL，根据BpBinder创建一个BpServiceManager，即gDefaultServiceManager = new BpServiceManager(new BpBinder(0))。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/libs/binder/IServiceManager.cpp</span><br><span class="line"></span><br><span class="line"> BpServiceManager(const sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">    : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/IInterface.h</span><br><span class="line"></span><br><span class="line">template&lt;typename INTERFACE&gt;</span><br><span class="line">inline BpInterface&lt;INTERFACE&gt;::BpInterface(const sp&lt;IBinder&gt;&amp; remote)</span><br><span class="line">    : BpRefBase(remote)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; frameworks/native/include/binder/Binder.h</span><br><span class="line"></span><br><span class="line">class BpRefBase : public virtual RefBase</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">private:</span><br><span class="line">    ......</span><br><span class="line">    IBinder* const          mRemote;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> 由上可知BpServiceManager继承于BpInterface，而BpInterface又继承于BpRefBase，最后BpBinder(0)即mRemote对象。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之Service Manager]]></title>
      <url>http://robinheztto.com/2016/03/25/android-binder-2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>ServiceManager是Binder进程间通信的核心组件，负责管理Service组件并向Client提供Service代理对象。ServiceManager运行在独立的进程中，Service或Client组件也需要与ServiceManager进行进程间通信，所以ServiceManager除了是Binder通信的上下文管理者外，也是一个特殊的Service组件。</p>
<p>ServiceManager源码位于以下文件中：<br>frameworks/native/cmds/servicemanager/service_manager.c<br>frameworks/native/cmds/servicemanager/binder.c<br>frameworks/native/cmds/servicemanager/binder.h<br>kernel/drivers/staging/android/binder.c</p>
</blockquote>
<h1 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h1><p>ServiceManager是由Init进程通过解析Initrc启动的，它的启动脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line">    .......</span><br><span class="line">    class_start core</span><br></pre></td></tr></table></figure></p>
<p>servicemanager服务定义在<code>class core</code>中，Init进程解析执行Initrc的<code>on boot</code>阶段时会通过<code>class_start core</code>启动包括servicemanager在内的系统核心服务。其中<code>user system</code>与<code>group system</code>指定servicemanager以system的身份运行。critical表明servicemanager是系统的关键服务，关键服务如果退出4次以上，系统将重启至recovery模式。最后的<code>onrestart</code>表示servicemanager退出后需要重新启动healthd，zygote，media，surfaceflinger，drm服务。</p>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>servicemanager的源码位于frameworks/native/cmds/servicemanager下,启动入口是service_manager.c的main()函数,下图是servicemanager的大致启动流程.</p>
<p><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/binder_service_manager.png?raw=true" alt="service_manager"><br></div><br>下面从main()开始分析servicemanager的启动过程.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/cmds/servicemanager/service_manager.c</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(128*1024);</span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">        ALOGE(&quot;failed to open binder driver\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(&quot;cannot become context manager (%s)\n&quot;, strerror(errno));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个启动过程分成三步，首先binder_open打开/dev/binder并mmap映射到本进程地址空间，然后调用binder_become_context_manager注册成为整个binder通信系统的管理者，最后在binder_loop中循环等待并处理client的请求。下面逐步进行分析。</p>
<h2 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h2><p>首先看一下binder_state结构体，它在binder.c中定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/cmds/servicemanager/binder.c</span><br><span class="line"></span><br><span class="line">struct binder_state</span><br><span class="line">&#123;</span><br><span class="line">    int fd;  // 打开/dev/binder的文件描述符</span><br><span class="line">    void *mapped; // mmap的起始地址</span><br><span class="line">    size_t mapsize; // mmap的大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>binder_state主要用来保存binder open及ioctl操作的信息。下面看binder_open的实现，binder_open也在binder.c中实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/cmds/servicemanager/binder.c</span><br><span class="line"></span><br><span class="line">struct binder_state *binder_open(size_t mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line">    struct binder_version vers;</span><br><span class="line"></span><br><span class="line">    bs = malloc(sizeof(*bs));</span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (bs-&gt;fd &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot open device (%s)\n&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        goto fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == -1) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        fprintf(stderr,</span><br><span class="line">                &quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        goto fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);</span><br><span class="line">    if (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot map device (%s)\n&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        goto fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    free(bs);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_open主要完成的是打开/dev/binder并映射到本进程的地址空间，对应的信息保存在binder_state中，（open　mmap分别会调到driver层的binder_open与binder_mmap，binder_open与binder_mmap的具体实现可参考上篇）。其中mmap，第一个参数是映射内存的起始地址，NULL表示系统指定地址，mapsize大小是128*1024B，即为servicemanager分配了128K内核缓冲区。PROT_READ表示映射区域是可读的，MAP_PRIVATE表示建立一个写入时拷贝的私有映射，即当进程中对该内存区域进行写入时，是写入到映射的拷贝中。</p>
<h2 id="binder-become-context-manager"><a href="#binder-become-context-manager" class="headerlink" title="binder_become_context_manager"></a>binder_become_context_manager</h2><p>binder_become_context_manager同样在binder.c中实现，通过调用该函数使servicemanager注册成为Binder的上下文管理者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; frameworks/native/cmds/servicemanager/binder.c</span><br><span class="line"></span><br><span class="line">int binder_become_context_manager(struct binder_state *bs)</span><br><span class="line">&#123;</span><br><span class="line">    return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; drivers/staging/android/uapi/binder.h</span><br><span class="line">#define BINDER_SET_CONTEXT_MGR      _IOW(&apos;b&apos;, 7, __s32)</span><br></pre></td></tr></table></figure></p>
<p>binder_become_context_manager通过ioctl设置BINDER_SET_CONTEXT_MGR，servicemanager作为一个特殊的service，BINDER_SET_CONTEXT_MGR的参数设置为０。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	struct binder_thread *thread;</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line">	// 从proc获取对应当前线程的binder_thread，没有则创建并关联到proc</span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	if (thread == NULL) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	......</span><br><span class="line">	case BINDER_SET_CONTEXT_MGR:</span><br><span class="line">		// 已经存在binder上下文管理者的binder实体，说明已经注册，出错返回</span><br><span class="line">		if (binder_context_mgr_node != NULL) &#123;</span><br><span class="line">			pr_err(&quot;BINDER_SET_CONTEXT_MGR already set\n&quot;);</span><br><span class="line">			ret = -EBUSY;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			goto err;</span><br><span class="line">		if (uid_valid(binder_context_mgr_uid)) &#123;</span><br><span class="line">			if (!uid_eq(binder_context_mgr_uid, current-&gt;cred-&gt;euid)) &#123;</span><br><span class="line">				pr_err(&quot;BINDER_SET_CONTEXT_MGR bad uid %d != %d\n&quot;,</span><br><span class="line">				       from_kuid(&amp;init_user_ns, current-&gt;cred-&gt;euid),</span><br><span class="line">				       from_kuid(&amp;init_user_ns, binder_context_mgr_uid));</span><br><span class="line">				ret = -EPERM;</span><br><span class="line">				goto err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else</span><br><span class="line">			// binder_context_mgr_uid设置为当前进程的有效euid</span><br><span class="line">			binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">			// 创建binder上下文管理者的binder实体，并设置binder_context_mgr_node</span><br><span class="line">			binder_context_mgr_node = binder_new_node(proc, 0, 0);</span><br><span class="line">		if (binder_context_mgr_node == NULL) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			goto err;</span><br><span class="line">		&#125;</span><br><span class="line">		// 增加引用计数，防止驱动将其释放</span><br><span class="line">		binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">		binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">		binder_context_mgr_node-&gt;has_strong_ref = 1;</span><br><span class="line">		binder_context_mgr_node-&gt;has_weak_ref = 1;</span><br><span class="line">		break;</span><br><span class="line">    ......</span><br><span class="line">	&#125;</span><br><span class="line">	ret = 0;</span><br><span class="line">err:</span><br><span class="line">	if (thread)</span><br><span class="line">		// 清除thread-&gt;looper上的BINDER_LOOPER_STATE_NEED_RETURN状态</span><br><span class="line">		thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line">	wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">err_unlocked:</span><br><span class="line">	trace_binder_ioctl_done(ret);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>首先通过binder_get_thread获取当前线程对应的binder_thread，即在红黑树proc-&gt;threads中以pid为关键字遍历，如果没有则创建一个。</li>
<li>检查binder_context_mgr_node是否为NULL，防止重复注册。</li>
<li>然后设置binder_context_mgr_uid为当前uid，并通过binder_new_node新建binder实体并赋值给binder_context_mgr_node，新建Binder实体后并增加其引用计数防止驱动将其释放。最后清除thread BINDER_LOOPER_STATE_NEED_RETURN状态返回。下面是binder_new_node的实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static struct binder_node *binder_new_node(struct binder_proc *proc,</span><br><span class="line">					   binder_uintptr_t ptr,</span><br><span class="line">					   binder_uintptr_t cookie)</span><br><span class="line">&#123;</span><br><span class="line">	struct rb_node **p = &amp;proc-&gt;nodes.rb_node;</span><br><span class="line">	struct rb_node *parent = NULL;</span><br><span class="line">	struct binder_node *node;</span><br><span class="line"></span><br><span class="line">	while (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		node = rb_entry(parent, struct binder_node, rb_node);</span><br><span class="line"></span><br><span class="line">		if (ptr &lt; node-&gt;ptr)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		else if (ptr &gt; node-&gt;ptr)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		else</span><br><span class="line">			return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node = kzalloc_preempt_disabled(sizeof(*node));</span><br><span class="line">	if (node == NULL)</span><br><span class="line">		return NULL;</span><br><span class="line">	binder_stats_created(BINDER_STAT_NODE);</span><br><span class="line">	rb_link_node(&amp;node-&gt;rb_node, parent, p);</span><br><span class="line">	rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line">	node-&gt;debug_id = ++binder_last_id;</span><br><span class="line">	node-&gt;proc = proc;</span><br><span class="line">	node-&gt;ptr = ptr;</span><br><span class="line">	node-&gt;cookie = cookie;</span><br><span class="line">	node-&gt;work.type = BINDER_WORK_NODE;</span><br><span class="line">	INIT_LIST_HEAD(&amp;node-&gt;work.entry);</span><br><span class="line">	INIT_LIST_HEAD(&amp;node-&gt;async_todo);</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>binder_new_node()有三个参数，proc即当前进程在kernel中的上下文描述binder_proc，ptr与cookie用来描述binder本地对象，由于是service manager，对应的binder本地对象地址值为0。binder_new_node根据ptr在proc的node红黑书中索引，如果找到已经创建的binder_node实体返回NULL，没有找到则创建binder_node实体对象。</p>
<h2 id="biner-loop"><a href="#biner-loop" class="headerlink" title="biner_loop"></a>biner_loop</h2><p>打开Binder设备，映射到进程地址空间并成为进程间通信上下文管理者后，servicemanager将进入到无限循环中等待client的请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kernel/drivers/staging/android/binder.c</span><br><span class="line"></span><br><span class="line">void binder_loop(struct binder_state *bs, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int res;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[32];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = 0;</span><br><span class="line">    bwr.write_consumed = 0;</span><br><span class="line">    bwr.write_buffer = 0;</span><br><span class="line"></span><br><span class="line">    // 通过ioctl BC_ENTER_LOOPER将自己注册为binder线程，以便binder驱动分发请求</span><br><span class="line">    readbuf[0] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        bwr.read_size = sizeof(readbuf);</span><br><span class="line">        bwr.read_consumed = 0;</span><br><span class="line">        bwr.read_buffer = (uintptr_t) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: ioctl failed (%s)\n&quot;, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func);</span><br><span class="line">        if (res == 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: unexpected reply?!\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: io error %d %s\n&quot;, res, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_loop中先通过ioctl BC_ENTER_LOOPER注册binder线程，然后在无限循环中ioctl BINDER_WRITE_READ等待请求数据，并通过binder_parse处理client请求。binder_loop中的处理在后面分析业务时具体分析，下面具体看binder_loop中二次ioctl的实现，分别是写BC_ENTER_LOOPER，等待读取客户端数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	struct binder_thread *thread;</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	if (thread == NULL) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	case BINDER_WRITE_READ:</span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		if (ret)</span><br><span class="line">			goto err;</span><br><span class="line">		break;</span><br><span class="line">	case BINDER_SET_MAX_THREADS:</span><br><span class="line">    ......</span><br><span class="line">		break;</span><br><span class="line">	case BINDER_SET_CONTEXT_MGR:</span><br><span class="line">    ......</span><br><span class="line">		break;</span><br><span class="line">	case BINDER_THREAD_EXIT:</span><br><span class="line">    ......</span><br><span class="line">		break;</span><br><span class="line">	case BINDER_VERSION:</span><br><span class="line">    ......</span><br><span class="line">	default:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = 0;</span><br><span class="line">err:</span><br><span class="line">	if (thread)</span><br><span class="line">		thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line">	wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">err_unlocked:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_ioctl根据cmd BINDER_WRITE_READ进入到binder_ioctl_write_read执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static int binder_ioctl_write_read(struct file *filp,</span><br><span class="line">				unsigned int cmd, unsigned long arg,</span><br><span class="line">				struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	unsigned int size = _IOC_SIZE(cmd);</span><br><span class="line">	void __user *ubuf = (void __user *)arg;</span><br><span class="line">	struct binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">	if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			bwr.read_consumed = 0;</span><br><span class="line">			if (copy_to_user_preempt_disabled(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		if (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">			wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			if (copy_to_user_preempt_disabled(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  ......</span><br><span class="line">out:</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据bwr.write_size与bwr.read_size判断，当bwr.write_size大于０时，执行binder_thread_write发送数据，当binder_thread_read大与０时，执行binder_thread_read等待读取数据。先看binder_thread_write的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">			struct binder_thread *thread,</span><br><span class="line">			binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t cmd;</span><br><span class="line">	struct binder_context *context = proc-&gt;context;</span><br><span class="line">	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">	void __user *ptr = buffer + *consumed;</span><br><span class="line">	void __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">		if (get_user_preempt_disabled(cmd, (uint32_t __user *)ptr))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		ptr += sizeof(uint32_t);</span><br><span class="line">    ......</span><br><span class="line">		switch (cmd) &#123;</span><br><span class="line">		case BC_INCREFS:</span><br><span class="line">		case BC_ACQUIRE:</span><br><span class="line">		case BC_RELEASE:</span><br><span class="line">		case BC_DECREFS:</span><br><span class="line">      ......</span><br><span class="line">		case BC_INCREFS_DONE:</span><br><span class="line">		case BC_ACQUIRE_DONE:</span><br><span class="line">      ......</span><br><span class="line">		case BC_ATTEMPT_ACQUIRE:</span><br><span class="line">      ......</span><br><span class="line">		case BC_ACQUIRE_RESULT:</span><br><span class="line">      ......</span><br><span class="line">		case BC_FREE_BUFFER:      </span><br><span class="line">      ......</span><br><span class="line">		case BC_TRANSACTION_SG:</span><br><span class="line">		case BC_REPLY_SG:</span><br><span class="line">      ......</span><br><span class="line">		case BC_TRANSACTION:</span><br><span class="line">		case BC_REPLY:</span><br><span class="line">      ......</span><br><span class="line">		case BC_REGISTER_LOOPER:</span><br><span class="line">      ......</span><br><span class="line">		case BC_ENTER_LOOPER:</span><br><span class="line">			if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</span><br><span class="line">				thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">				binder_user_error(&quot;%d:%d ERROR: BC_ENTER_LOOPER called after BC_REGISTER_LOOPER\n&quot;,</span><br><span class="line">					proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			&#125;</span><br><span class="line">			thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">			break;</span><br><span class="line">		case BC_EXIT_LOOPER:</span><br><span class="line">      ......</span><br><span class="line">		case BC_REQUEST_DEATH_NOTIFICATION:</span><br><span class="line">		case BC_CLEAR_DEATH_NOTIFICATION:</span><br><span class="line">      ......</span><br><span class="line">      break;</span><br><span class="line">		case BC_DEAD_BINDER_DONE:</span><br><span class="line">      ......</span><br><span class="line">		default:</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		*consumed = ptr - buffer;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_thread_write中对BC_ENTER_LOOPER的处理即把thread-&gt;looper的状态置为BINDER_LOOPER_STATE_ENTERED，标志ServiceManager主线程已经准备好可以处理Client的请求了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">static int binder_thread_read(struct binder_proc *proc,</span><br><span class="line">			      struct binder_thread *thread,</span><br><span class="line">			      binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">			      binder_size_t *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line">	void __user *buffer = (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">	void __user *ptr = buffer + *consumed;</span><br><span class="line">	void __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	int ret = 0;</span><br><span class="line">	int wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">	if (*consumed == 0) &#123;</span><br><span class="line">		if (put_user_preempt_disabled(BR_NOOP, (uint32_t __user *)ptr))</span><br><span class="line">			return -EFAULT;</span><br><span class="line">		ptr += sizeof(uint32_t);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">  // 线程的事物堆栈为NULL，且todo队列为空时，表示当前线程空闲</span><br><span class="line">	wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;</span><br><span class="line">				list_empty(&amp;thread-&gt;todo);</span><br><span class="line">  ......</span><br><span class="line">  // 设置线程的状态为BINDER_LOOPER_STATE_WAITING</span><br><span class="line">	thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">	if (wait_for_proc_work)</span><br><span class="line">		proc-&gt;ready_threads++;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">	if (wait_for_proc_work) &#123;</span><br><span class="line">    ......</span><br><span class="line">		binder_set_nice(proc-&gt;default_priority);</span><br><span class="line">		if (non_block) &#123;</span><br><span class="line">			// 非阻塞式的读取，则通过binder_has_proc_work()读取proc的事务；</span><br><span class="line">			// 若没有，则直接返回</span><br><span class="line">			if (!binder_has_proc_work(proc, thread))</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">		&#125; else</span><br><span class="line">			// 阻塞式的读取，则阻塞等待事务的发生。</span><br><span class="line">			ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (non_block) &#123;</span><br><span class="line">			if (!binder_has_thread_work(thread))</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">		&#125; else</span><br><span class="line">			ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	if (wait_for_proc_work)</span><br><span class="line">		proc-&gt;ready_threads--;</span><br><span class="line">	thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	// 处理工作项中的数据    </span><br><span class="line">	while (1) &#123;</span><br><span class="line">    ......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">	*consumed = ptr - buffer;</span><br><span class="line">  ......</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之Binder Driver]]></title>
      <url>http://robinheztto.com/2016/03/20/android-binder-1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Binder驱动源码位于kernel/drivers/staging/android/目录下，包括binder.c与uapi/binder.h，主要负责通信数据传递等底层实现。</p>
</blockquote>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>在分析驱动代码之前，首先需要熟悉Binder驱动相关的数据结构。</p>
<h2 id="binder-node"><a href="#binder-node" class="headerlink" title="binder_node"></a>binder_node</h2><p>binder_node在binder.c中定义，它是binder实体对象，代表着Service组件或ServiceManager在内核中的描述，可以通过binder_node找到用户空间的Service对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct binder_node &#123;</span><br><span class="line">	int debug_id;</span><br><span class="line">	struct binder_work work;</span><br><span class="line">	union &#123;</span><br><span class="line">		struct rb_node rb_node;</span><br><span class="line">		struct hlist_node dead_node;</span><br><span class="line">	&#125;;</span><br><span class="line">	struct binder_proc *proc;</span><br><span class="line">	struct hlist_head refs;　</span><br><span class="line">	int internal_strong_refs;</span><br><span class="line">	int local_weak_refs;</span><br><span class="line">	int local_strong_refs;</span><br><span class="line">	binder_uintptr_t ptr;</span><br><span class="line">	binder_uintptr_t cookie;</span><br><span class="line">	unsigned has_strong_ref:1;</span><br><span class="line">	unsigned pending_strong_ref:1;</span><br><span class="line">	unsigned has_weak_ref:1;</span><br><span class="line">	unsigned pending_weak_ref:1;</span><br><span class="line">	unsigned has_async_transaction:1;</span><br><span class="line">	unsigned accept_fds:1;</span><br><span class="line">	unsigned min_priority:8;</span><br><span class="line">	struct list_head async_todo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>binder_node是描述Binder实体的数据结构，Binder驱动会为每个Service创建一个Binder实体。</p>
<ol>
<li><strong>union {<br>struct rb_node rb_node;<br>struct hlist_node dead_node;<br>};</strong><br>binder_node未销毁时，rb_node链接到proc-&gt;nodes红黑树上.<br>binder_node销毁后，dead_node加入到全局的死亡hash链表中.</li>
<li><strong>struct binder_proc *proc;</strong>　Binder实体(服务)所在的宿主进程（进程上下文信息）.</li>
<li><strong>struct hlist_head refs;</strong> Binder实体引用的链表，所有该binder实体的引用都保存在该hash list中.</li>
<li><strong>binder_uintptr_t ptr;</strong> 描述用户空间的Service組件，对应Binder实体对应的Service在用户空间的本地Binder(BBinder)的引用</li>
<li><strong>binder_uintptr_t cookie;</strong> 描述用户空间的Service組件，Binder实体对应的Service在用户空间的本地Binder(BBinder)地址</li>
</ol>
<h2 id="binder-ref"><a href="#binder-ref" class="headerlink" title="binder_ref"></a>binder_ref</h2><p>binder_ref在binder.c中定义，它是Client组件在内核中的描述，通过binder引用可以找到其在内核中的binder实体，进而找到用户空间的Service对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct binder_ref &#123;</span><br><span class="line">	int debug_id;</span><br><span class="line">	struct rb_node rb_node_desc;　</span><br><span class="line">	struct rb_node rb_node_node;　</span><br><span class="line">	struct hlist_node node_entry;　</span><br><span class="line">	struct binder_proc *proc;　</span><br><span class="line">	struct binder_node *node;</span><br><span class="line">	uint32_t desc;</span><br><span class="line">	int strong;</span><br><span class="line">	int weak;</span><br><span class="line">	struct binder_ref_death *death;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>binder_ref是描述Binder引用的数据结构，Binder驱动会为每个Client创建一个Binder引用。</p>
<ol>
<li><strong>struct rb_node rb_node_desc;</strong>    以句柄值作为关键字关联到binder_proc-&gt;refs_by_desc红黑树</li>
<li><strong>struct rb_node rb_node_node;</strong> 以Binder实体对象地址作为关键字关联到binder_proc-&gt;refs_by_node红黑树</li>
<li><strong>struct hlist_node node_entry;</strong> binder_node的引用节点，关联到binder_node-&gt;refs</li>
<li><strong>struct binder_proc *proc;</strong> 引用所在的宿主进程</li>
<li><strong>struct binder_node *node;</strong>    引用所对应的binder_node实体</li>
<li><strong>uint32_t desc;</strong>    Binder引用的句柄值，Binder驱动为binder引用分配的一个唯一的int型整数（进程范围内唯一），通过该值可以在binder_proc-&gt;refs_by_desc中找到Binder引用，进而可以找到该Binder引用对应的Binder实体。</li>
</ol>
<h2 id="binder-proc"><a href="#binder-proc" class="headerlink" title="binder_proc"></a>binder_proc</h2><p>binder_proc在binder.c中定义，它是Binder通信的进程在内核中的描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct binder_proc &#123;</span><br><span class="line">	struct hlist_node proc_node;</span><br><span class="line">	struct rb_root threads;</span><br><span class="line">	struct rb_root nodes;　</span><br><span class="line">	struct rb_root refs_by_desc;　</span><br><span class="line">	struct rb_root refs_by_node;</span><br><span class="line">	int pid;</span><br><span class="line">	struct vm_area_struct *vma;</span><br><span class="line">	struct mm_struct *vma_vm_mm;</span><br><span class="line">	struct task_struct *tsk;</span><br><span class="line">	struct files_struct *files;</span><br><span class="line">	struct hlist_node deferred_work_node;</span><br><span class="line">	int deferred_work;</span><br><span class="line">	void *buffer;</span><br><span class="line">	ptrdiff_t user_buffer_offset;</span><br><span class="line"></span><br><span class="line">	struct list_head buffers;</span><br><span class="line">	struct rb_root free_buffers;</span><br><span class="line">	struct rb_root allocated_buffers;</span><br><span class="line">	size_t free_async_space;</span><br><span class="line"></span><br><span class="line">	struct page **pages;　</span><br><span class="line">	size_t buffer_size;</span><br><span class="line">	uint32_t buffer_free;</span><br><span class="line">	struct list_head todo;　</span><br><span class="line">	wait_queue_head_t wait;</span><br><span class="line">	struct binder_stats stats;</span><br><span class="line">	struct list_head delivered_death;</span><br><span class="line">	int max_threads;　</span><br><span class="line">	int requested_threads;</span><br><span class="line">	int requested_threads_started;</span><br><span class="line">	int ready_threads;</span><br><span class="line">	long default_priority;</span><br><span class="line">	struct dentry *debugfs_entry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>struct hlist_node proc_node;</strong> 全局哈希链表binder_procs的节点，所有创建的binder_proc都被加入到该链表</li>
<li><strong>struct rb_root threads;</strong>    binder_thread红黑树，关联binder_thread-&gt;rb_node</li>
<li><strong>struct rb_root nodes;</strong>    binder_node红黑树，关联binder_node-&gt;rb_node</li>
<li><strong>struct rb_root refs_by_desc;</strong>　以binder_ref描述句柄为关键字的红黑树，关联binder_ref-&gt;rb_node_desc</li>
<li><strong>struct rb_root refs_by_node;</strong>    以binder_ref关联的实体地址为关键字的红黑树，关联binder_ref-&gt;rb_node</li>
<li><strong>int pid;</strong>　进程id</li>
<li><strong>struct vm_area_struct *vma;</strong> 进程用户空间虚拟地址</li>
<li><strong>struct task_struct *tsk;</strong>　进程控制块</li>
<li><strong>void *buffer;</strong>　进程内核空间虚拟地址</li>
<li><strong>ptrdiff_t user_buffer_offset;</strong>　内核虚拟地址和用户虚拟地址之间的偏移，通过该偏移可计算另一个虚拟空间地址</li>
<li><strong>struct list_head todo;</strong>　进程的待处理事务队列</li>
<li><strong>wait_queue_head_t wait;</strong>　线程等待队列</li>
<li><strong>max_threads;</strong>　最大线程数</li>
</ol>
<h2 id="binder-thread"><a href="#binder-thread" class="headerlink" title="binder_thread"></a>binder_thread</h2><p>binder_thread在binder.c中定义，它是使用Binder通信的线程在内核中的描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct binder_thread &#123;</span><br><span class="line">	struct binder_proc *proc;</span><br><span class="line">	struct rb_node rb_node;　</span><br><span class="line">	int pid;　</span><br><span class="line">	int looper;　</span><br><span class="line">	struct binder_transaction *transaction_stack;　</span><br><span class="line">	struct list_head todo;　</span><br><span class="line">	uint32_t return_error; /* Write failed, return error code in read buf */</span><br><span class="line">	uint32_t return_error2; /* Write failed, return error code in read */</span><br><span class="line">	wait_queue_head_t wait;</span><br><span class="line">	struct binder_stats stats;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">	BINDER_LOOPER_STATE_REGISTERED  = 0x01,</span><br><span class="line">	BINDER_LOOPER_STATE_ENTERED     = 0x02,</span><br><span class="line">	BINDER_LOOPER_STATE_EXITED      = 0x04,</span><br><span class="line">	BINDER_LOOPER_STATE_INVALID     = 0x08,</span><br><span class="line">	BINDER_LOOPER_STATE_WAITING     = 0x10,</span><br><span class="line">	BINDER_LOOPER_STATE_NEED_RETURN = 0x20</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>struct binder_proc *proc;</strong>　指向所在进程的binder_proc</li>
<li><strong>struct rb_node rb_node;</strong>    关联到红黑树binder_proc-&gt;threads</li>
<li><strong>int pid;</strong>    进程id</li>
<li><strong>int looper;</strong> 线程状态，可取的状态如上枚举所定义</li>
<li><strong>struct binder_transaction *transaction_stack;</strong> 正在处理的事务栈</li>
<li><strong>struct list_head todo;</strong> 待处理的事务链表</li>
<li><strong>wait_queue_head_t wait;</strong> 等待队列</li>
</ol>
<h2 id="binder-buffer"><a href="#binder-buffer" class="headerlink" title="binder_buffer"></a>binder_buffer</h2><p>binder_buffer在binder.c中定义，它用来描述Binder进程在内核中分配的内核缓冲区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct binder_buffer &#123;</span><br><span class="line">	struct list_head entry;</span><br><span class="line">	struct rb_node rb_node;</span><br><span class="line">	unsigned free:1;</span><br><span class="line">	unsigned allow_user_free:1;</span><br><span class="line">	unsigned async_transaction:1;</span><br><span class="line">	unsigned debug_id:29;</span><br><span class="line"></span><br><span class="line">	struct binder_transaction *transaction;</span><br><span class="line"></span><br><span class="line">	struct binder_node *target_node;</span><br><span class="line">	size_t data_size;</span><br><span class="line">	size_t offsets_size;</span><br><span class="line">	uint8_t data[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>struct list_head entry;</strong>　关联到binder_proc-&gt;buffers链表，从而对内存进行管理</li>
<li><strong>struct rb_node rb_node;</strong>    关联到binder_proc-&gt;free_buffers或binder_proc-&gt;allocated_buffers红黑树，从而对已有内存和空闲内存进行管理</li>
<li><strong>unsigned free:1;</strong>　是否空闲</li>
<li><strong>struct binder_transaction *transaction;</strong> 正在处理的事务</li>
<li><strong>struct binder_node *target_node;</strong> 正在使用该块内存的binder实体对象</li>
</ol>
<h2 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a>binder_transaction</h2><p>binder_transaction用来描述Binder进程中通信过程，即通信中请求的事务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct binder_transaction &#123;</span><br><span class="line">	int debug_id;</span><br><span class="line">	struct binder_work work;</span><br><span class="line">	struct binder_thread *from;</span><br><span class="line">	struct binder_transaction *from_parent;</span><br><span class="line">	struct binder_proc *to_proc;</span><br><span class="line">	struct binder_thread *to_thread;</span><br><span class="line">	struct binder_transaction *to_parent;</span><br><span class="line">	unsigned need_reply:1;</span><br><span class="line">	/* unsigned is_dead:1; */	/* not used at the moment */</span><br><span class="line"></span><br><span class="line">	struct binder_buffer *buffer;</span><br><span class="line">	unsigned int	code;</span><br><span class="line">	unsigned int	flags;</span><br><span class="line">	long	priority;</span><br><span class="line">	long	saved_priority;</span><br><span class="line">	kuid_t	sender_euid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>struct binder_thread *from;</strong>　发起事务的源线程</li>
<li><strong>struct binder_proc *to_proc;</strong>    事务的目标进程</li>
<li><strong>struct binder_thread *to_thread;</strong>　事务的目标线程</li>
<li><strong>unsigned need_reply:1;</strong> 是否是同步事务，需对方回复</li>
<li><strong>struct binder_buffer *buffer;</strong> 进程间通信的数据</li>
<li><strong>long    priority;</strong> 源线程优先级</li>
<li><strong>kuid_t    sender_euid;</strong> 源线程用户ID</li>
</ol>
<h2 id="binder-transaction-data"><a href="#binder-transaction-data" class="headerlink" title="binder_transaction_data"></a>binder_transaction_data</h2><p>binder_transaction_data用来描述Binder事务交互的数据格式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct binder_transaction_data &#123;</span><br><span class="line">	union &#123;</span><br><span class="line">		__u32	handle;　</span><br><span class="line">		binder_uintptr_t ptr;</span><br><span class="line">	&#125; target;</span><br><span class="line">	binder_uintptr_t	cookie;</span><br><span class="line">	__u32		code;</span><br><span class="line"></span><br><span class="line">	/* General information about the transaction. */</span><br><span class="line">	__u32	        flags;</span><br><span class="line">	pid_t		sender_pid;</span><br><span class="line">	uid_t		sender_euid;</span><br><span class="line">	binder_size_t	data_size;	/* number of bytes of data */</span><br><span class="line">	binder_size_t	offsets_size;	/* number of bytes of offsets */</span><br><span class="line"></span><br><span class="line">	/* If this transaction is inline, the data immediately</span><br><span class="line">	 * follows here; otherwise, it ends with a pointer to</span><br><span class="line">	 * the data buffer.</span><br><span class="line">	 */</span><br><span class="line">	union &#123;</span><br><span class="line">		struct &#123;</span><br><span class="line">			/* transaction data */</span><br><span class="line">			binder_uintptr_t	buffer;</span><br><span class="line">			/* offsets from buffer to flat_binder_object structs */</span><br><span class="line">			binder_uintptr_t	offsets;</span><br><span class="line">		&#125; ptr;</span><br><span class="line">		__u8	buf[8];</span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>target</strong>　当binder_transaction_data是由用户空间的进程发送给Binder驱动时，handle是该事务的发送目标在Binder驱动中的信息，即该事务会交给handle来处理，handle的值是目标在Binder驱动中的Binder引用。当binder_transaction_data是有Binder驱动反馈给用户空间进程时，ptr是该事务的发送目标在用户空间中的信息，即该事务会交给ptr对应的服务来处理，ptr是处理该事务的服务的服务在用户空间的本地Binder对象</li>
<li><strong>binder_uintptr_t    cookie;</strong>    只有当事务是由Binder驱动传递给用户空间时，cookie才有意思，它的值是处理该事务的Server位于C++层的本地Binder对象</li>
<li><strong>__u32　flags;</strong>　事务编码。如果是请求，则以BC<em>开头；如果是回复，则以BR</em>开头。</li>
<li><strong>binder_size_t    data_size;</strong> 数据大小</li>
<li><strong>binder_size_t    offsets_size;</strong> 数据中包含的对象的个数</li>
<li><strong>data</strong> 源线程优先级</li>
</ol>
<h2 id="flat-binder-object"><a href="#flat-binder-object" class="headerlink" title="flat_binder_object"></a>flat_binder_object</h2><p>flat_binder_object描述进程中通信过程中传递的Binder实体/引用对象或文件描述符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct flat_binder_object &#123;</span><br><span class="line">	/* 8 bytes for large_flat_header. */</span><br><span class="line">	__u32		type;</span><br><span class="line">	__u32		flags;</span><br><span class="line"></span><br><span class="line">	/* 8 bytes of data. */</span><br><span class="line">	union &#123;</span><br><span class="line">		binder_uintptr_t	binder;	/* local object */</span><br><span class="line">		__u32			handle;	/* remote object */</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	/* extra data associated with local object */</span><br><span class="line">	binder_uintptr_t	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>flat_binder_object通过type来区分描述类型，可选的描述类型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">  BINDER_TYPE_BINDER = B_PACK_CHARS(&apos;s&apos;, &apos;b&apos;, &apos;*&apos;, B_TYPE_LARGE),</span><br><span class="line">  BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS(&apos;w&apos;, &apos;b&apos;, &apos;*&apos;, B_TYPE_LARGE),</span><br><span class="line">  BINDER_TYPE_HANDLE = B_PACK_CHARS(&apos;s&apos;, &apos;h&apos;, &apos;*&apos;, B_TYPE_LARGE),</span><br><span class="line">  BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS(&apos;w&apos;, &apos;h&apos;, &apos;*&apos;, B_TYPE_LARGE),</span><br><span class="line">  BINDER_TYPE_FD = B_PACK_CHARS(&apos;f&apos;, &apos;d&apos;, &apos;*&apos;, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>type为BINDER_TYPE_BINDER，BINDER_TYPE_WEAK_BINDER时，分别描述强类型实体对象与弱类型实体对象。type为BINDER_TYPE_HANDLE，BINDER_TYPE_WEAK_HANDLE时，分别描述强类型引用对象与弱类型引用对象。type为BINDER_TYPE_FD时，描述文件描述符。<br>当描述实体对象时，cookie表示Binder实体对应的Service在用户空间的本地Binder(BBinder)地址，binder表示Binder实体对应的Service在用户空间的本地Binder(BBinder)的弱引用。<br>当描述引用对象时，handle表示该引用对象的句柄值。</p>
<h1 id="驱动代码分析"><a href="#驱动代码分析" class="headerlink" title="驱动代码分析"></a>驱动代码分析</h1><h2 id="binder-init"><a href="#binder-init" class="headerlink" title="binder_init"></a>binder_init</h2><p>binder_init是binder驱动的初始化入口，在分析binder_init之前，先看一下kernel include/linux/init.h中device_initcall的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define device_initcall(fn)		__define_initcall(fn, 6)</span><br><span class="line"></span><br><span class="line">//宏定义##表示字符串连接</span><br><span class="line">#define __define_initcall(fn, id) \</span><br><span class="line">	static initcall_t __initcall_##fn##id __used \</span><br><span class="line">	__attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) = fn</span><br><span class="line"></span><br><span class="line">typedef int (*initcall_t)(void);</span><br><span class="line"></span><br><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure></p>
<p>device_initcall(binder_init)即把binder_init的函数指针__initcall_binder_init6存放在initcall6.init section中，在kernel分级初始化时会调到该section的函数进行binder device初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations binder_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct miscdevice binder_miscdev = &#123;</span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	.name = &quot;binder&quot;,</span><br><span class="line">	.fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init binder_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	binder_deferred_workqueue = create_singlethread_workqueue(&quot;binder&quot;);</span><br><span class="line">	if (!binder_deferred_workqueue)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line">	ret = misc_register(&amp;binder_miscdev);</span><br><span class="line">	......</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_init主要是注册并创建misc设备节点/dev/binder，并关联binder_fops到binder的file_operations。</p>
<h2 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h2><p>用户空间系统调用open最终会调到binder驱动中的binder_open。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static int binder_open(struct inode *nodp, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">	struct binder_proc *proc;</span><br><span class="line">	.......</span><br><span class="line">	proc = kzalloc(sizeof(*proc), GFP_KERNEL);</span><br><span class="line">	if (proc == NULL)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	get_task_struct(current);　// 获取当前进程控制快current</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);　</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line">	.......</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_open创建了binder_proc并加入到binder_procs全局哈希链表binder_procs。其中binder_proc的task成员被初始化为当前进程的task_struct current，并根据current初始化default_priority，pid，初始化wait及todo队列。最后将创建的binder_proc保存到filp-&gt;private_data中，执行其他的file　operations的操作时就可以根据filp指针获取binder_proc。</p>
<h2 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h2><p>binder_mmap主要完成binder进程用户虚拟地址空间与内核虚拟地址空间的映射与分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">static int binder_mmap(struct file *filp, struct vm_area_struct *vma)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	struct vm_struct *area;</span><br><span class="line">	struct binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	const char *failure_string;</span><br><span class="line">	struct binder_buffer *buffer;</span><br><span class="line"></span><br><span class="line">	if (proc-&gt;tsk != current)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	// 最多分配４M缓存区</span><br><span class="line">	if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">	// 分配的缓存区只可读，不可写也不能拷贝</span><br><span class="line">	if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		failure_string = &quot;bad vm_flags&quot;;</span><br><span class="line">		goto err_bad_arg;</span><br><span class="line">	&#125;</span><br><span class="line">	vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_mmap_lock);</span><br><span class="line">	if (proc-&gt;buffer) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		failure_string = &quot;already mapped&quot;;</span><br><span class="line">		goto err_already_mapped;</span><br><span class="line">	&#125;</span><br><span class="line">	// 在内核地址空间分配一块vma-&gt;vm_end - vma-&gt;vm_start大小的空间</span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">	if (area == NULL) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = &quot;get_vm_area&quot;;</span><br><span class="line">		goto err_get_vm_area_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	// 内核空间缓存地址proc-&gt;buffer，用户空间地址vma-&gt;vm_start，proc-&gt;user_buffer_offset是二个地址间的偏移</span><br><span class="line">	proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">	proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer;</span><br><span class="line">	mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line"></span><br><span class="line">	proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">	if (proc-&gt;pages == NULL) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = &quot;alloc page array&quot;;</span><br><span class="line">		goto err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">	vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">	/* binder_update_page_range assumes preemption is disabled */</span><br><span class="line">	preempt_disable();</span><br><span class="line">	// 为用户/内核虚拟地址空间分配物理页面并映射</span><br><span class="line">	ret = binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma);</span><br><span class="line">	preempt_enable_no_resched();</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = &quot;alloc small buf&quot;;</span><br><span class="line">		goto err_alloc_small_buf_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	buffer = proc-&gt;buffer;</span><br><span class="line">	// 分配的binder_buffer加入到proc-&gt;buffers进行管理</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;buffers);</span><br><span class="line">	list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers);</span><br><span class="line">	buffer-&gt;free = 1;</span><br><span class="line">	binder_insert_free_buffer(proc, buffer);</span><br><span class="line">	proc-&gt;free_async_space = proc-&gt;buffer_size / 2;</span><br><span class="line">	barrier();</span><br><span class="line">	proc-&gt;files = get_files_struct(current);</span><br><span class="line">	proc-&gt;vma = vma;</span><br><span class="line">	proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>首先判断proc-&gt;tsk是否对应当前进程，不是则退出．然后限制mmap的用户空间vm_area_struct最大为４M,即biner驱动最多分配４M内核空间来进行进程间通信</li>
<li>设置vma-&gt;vm_flags标志为只读，即分配的空间不可写</li>
<li>根据proc-&gt;buffer是否为null判断是否重复mmap,然后调用get_vm_area根据vma来分配内核空间地址，并设置起始地址proc-&gt;buffer，与用户空间地址偏移proc-&gt;user_buffer_offset</li>
<li>调用binder_update_page_rang为用户/内核虚拟地址空间分配对应的物理页面，同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间</li>
<li>分配内存后，初始化binder_buffer相关数据结构</li>
</ol>
<h2 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h2><p>binder_ioctl支持的命令在binder.h中定义，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define BINDER_WRITE_READ		_IOWR(&apos;b&apos;, 1, struct binder_write_read)　//收发Binder IPC数据</span><br><span class="line">#define	BINDER_SET_IDLE_TIMEOUT		_IOW(&apos;b&apos;, 3, __s64)	//Not Used</span><br><span class="line">#define	BINDER_SET_MAX_THREADS		_IOW(&apos;b&apos;, 5, __u32)	//设置Binder线程最大个数</span><br><span class="line">#define	BINDER_SET_IDLE_PRIORITY	_IOW(&apos;b&apos;, 6, __s32) //Not Used</span><br><span class="line">#define	BINDER_SET_CONTEXT_MGR		_IOW(&apos;b&apos;, 7, __s32)	//设置Service Manager</span><br><span class="line">#define	BINDER_THREAD_EXIT		_IOW(&apos;b&apos;, 8, __s32) //Not Used</span><br><span class="line">#define BINDER_VERSION			_IOWR(&apos;b&apos;, 9, struct binder_version)	//获取Binder版本信息</span><br></pre></td></tr></table></figure></p>
<p>binder_ioctl的实现在后面根据具体的业务逻辑具体分析。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Binder之概述]]></title>
      <url>http://robinheztto.com/2016/03/19/android-binder-0/</url>
      <content type="html"><![CDATA[<h1 id="Binder简介"><a href="#Binder简介" class="headerlink" title="Binder简介"></a>Binder简介</h1><p>在Android系统中，应用程序是由组件(Acyiviy/Service/Broadcast Receiver/Content Provider)组成的，组件可以运行在一个进程中，也可以分别运行在不同进程中。同样，在Android系统中的各类系统服务也可以运行在一个或多个进程中，运行在不同进程的应用程序组件或系统服务之间的通信都是通过Binder来进行的。</p>
<p>由于Android是基于Linux内核开发的，在Linux系统中传统的IPC机制有Pipe，ShareMemory，Singal，Message，Socket等，但Android并未完全采用这些传统的进程间通信机制，而是引入了Binder作为其主要的IPC机制。Binder是在<a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">OpenBinder</a>的基础上实现的，OpenBinder是一套开源的系统IPC机制，最初是由Be Inc开发，后来由Palm, Inc公司负责开发，Google对其改造后应用到了Android系统上。</p>
<p>Binder相比其他的IPC机制有什么优势?</p>
<ol>
<li>基于Client-Server的通信方式。APP通过调用Service接口就可以非常方便的完成很多功能。</li>
<li>高效率。Binder中数据传输只需要一次拷贝(只需将数据通过驱动发送到目标进程的内核虚拟缓存区，而使用Binder通信用户空间缓存区与内核空间的缓存区映射到同一物理内存的，所以只需要一次拷贝)，节省时间的同时也节省了空间。</li>
<li>面向对象的RPC调用，模糊了进程边界，淡化进程间通信过程。在Android的C++/java面向对象语言环境中，Binder更加符合面向对象思想，Binder的实体位于一个进程中，而引用却可以分布在各个进程中，通过Binder引用调用就像本地调用一样，这种通信方式更加适合Android组件化的思想。</li>
<li>安全性。Android为每个安装的应用程序分配了UID，Binder能依据调用进程的UID/PID来进行权限控制，而传统IPC需要上层协议来验证权限保证安全性。</li>
</ol>
<h1 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h1><p>Binder采用的是CS通信方式，对于提供服务的进程即Server进程，请求服务的进程即Client进程。同一个Server进程可能存在多个Service组件，同时同一个Clent进程可以请求多个Service组件。<br>如下图所示，Binder的通信涉及到4个角色，分别是Client，Service，Service Mananger与Binder Driver。</p>
<p><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/Binder-model.jpg?raw=true" alt="Binder进程间通信机制"><br></div><br>Client，Service，Service Mananger都运行在用户空间独立的进程中，由于用户进程地址空间是独立且不能相互访问，而内核空间却是是全局共享，所以可以通过内核空间的缓冲区进行数据的中转。如下图示Client，Service，Service Mananger通过SystemCall(open，mmap，ioctl)访问/dev/binder，通过Binder driver间接建立与用户空间其他进程的通信通道。</p>
<h1 id="Binder分析"><a href="#Binder分析" class="headerlink" title="Binder分析"></a>Binder分析</h1><ul>
<li><a href="http://www.robinheztto.com/2016/03/19/android-binder-0/" target="_blank" rel="external">Android Binder之概述</a></li>
<li><a href="http://www.robinheztto.com/2016/03/20/android-binder-1/" target="_blank" rel="external">Android Binder之Binder Driver</a></li>
<li><a href="http://www.robinheztto.com/2016/03/25/android-binder-2/" target="_blank" rel="external">Android Binder之Service Manager</a></li>
<li><a href="http://www.robinheztto.com/2016/03/28/android-binder-3/" target="_blank" rel="external">Android Binder之进程间通信库</a></li>
<li><a href="http://www.robinheztto.com/2016/03/28/android-binder-4/" target="_blank" rel="external">Android Binder之Service Manager代理对象</a></li>
<li><a href="http://www.robinheztto.com/2016/04/02/android-binder-5/" target="_blank" rel="external">Android Binder之Service启动</a></li>
<li><a href="http://www.robinheztto.com/2016/04/18/android-binder-6/" target="_blank" rel="external">Android Binder之Service代理获取</a></li>
<li><a href="http://www.robinheztto.com/2016/04/23/android-binder-7/" target="_blank" rel="external">Android Binder之Java接口</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder设计与实现 - 设计篇</a></li>
<li><a href="http://0xcc0xcd.com/p/index.php" target="_blank" rel="external">Android系统源代码情景分析</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之Init]]></title>
      <url>http://robinheztto.com/2016/02/02/android-init/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Init进程是Kernel启动后在用户空间创建的第一个用户级进程，它的pid为1。其他所有的用户进程都是由其直接或间接fork产生的.</p>
<div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/boot-flow.jpg?raw=true" alt="Android系统启动"><br></div><br>Init调用流程如下图示,从汇编代码kernel/arch/arm/kernel/head-common.S <code>b    start_kernel</code>进入到C环境kernel/init/main.c <code>start_kernel</code>执行.最后在run_init_process()中通过do_execve创建Init进程.<br><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/android_init_flow.jpg?raw=true" alt="Kernel init flow"><br></div>

<p>kernel_init()中的execute_command即/init，run_init_process通过execve()系统调用来启动init进程。如果没有定义execute_command，则在/sbin，/etc，/bin查找，否则Kernel Panic.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int __ref kernel_init(void *unused)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  if (execute_command) &#123;</span><br><span class="line">    ret = run_init_process(execute_command);</span><br><span class="line">    if (!ret)</span><br><span class="line">      return 0;</span><br><span class="line">    pr_err(&quot;Failed to execute %s (error %d).  Attempting defaults...\n&quot;,</span><br><span class="line">      execute_command, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||</span><br><span class="line">	    !try_to_run_init_process(&quot;/etc/init&quot;) ||</span><br><span class="line">	    !try_to_run_init_process(&quot;/bin/init&quot;) ||</span><br><span class="line">	    !try_to_run_init_process(&quot;/bin/sh&quot;))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	panic(&quot;No working init found.  Try passing init= option to kernel. &quot;</span><br><span class="line">	      &quot;See Linux Documentation/init.txt for guidance.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Android中的Init进程与Linux中有所不同,它主要实现以下的四大功能：</p>
<ul>
<li>解析执行init.rc文件</li>
<li>创建设备节点</li>
<li>创建关键的daemon进程并处理子进程的终止</li>
<li>属性服务</li>
</ul>
<h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><blockquote>
<p>Init的源码主要集中在system/core/init/</p>
</blockquote>
<p>下面从init.cpp的main()开始逐段来分析init进程的执行流程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//根据执行的文件名argv[0]判断是否是执行ueventd</span><br><span class="line">if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123;</span><br><span class="line">    return ueventd_main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line">//根据执行的文件名argv[0]判断是否是执行watchdogd</span><br><span class="line">if (!strcmp(basename(argv[0]), &quot;watchdogd&quot;)) &#123;</span><br><span class="line">    return watchdogd_main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Clear the umask.</span><br><span class="line">umask(0);</span><br><span class="line"></span><br><span class="line">// 初始化PATH环境变量 PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin</span><br><span class="line">add_environment(&quot;PATH&quot;, _PATH_DEFPATH);　</span><br><span class="line"></span><br><span class="line">// 根据argc，argv[1]判断是否是first_stage（first_stage运行在kernel domain）.</span><br><span class="line">bool is_first_stage = (argc == 1) || (strcmp(argv[1], &quot;--second-stage&quot;) != 0);</span><br><span class="line"></span><br><span class="line">// mount并创建相关内存文件系统及目录</span><br><span class="line">if (is_first_stage) &#123;</span><br><span class="line">    mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);</span><br><span class="line">    mkdir(&quot;/dev/pts&quot;, 0755);</span><br><span class="line">    mkdir(&quot;/dev/socket&quot;, 0755);</span><br><span class="line">    mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);</span><br><span class="line">    #define MAKE_STR(x) __STRING(x)</span><br><span class="line">    mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC));</span><br><span class="line">    mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>首先根据执行参数basename(argv[0])判断是否是执行ueventd或watchdogd(ueventd与watchdogd功能代码在init中实现),通过system/core/init/Android.mk可以知道,/sbin/ueventd与/sbin/watchdogd实际上都链接到init.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Create symlinks</span><br><span class="line">LOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT)/sbin; \</span><br><span class="line">    ln -sf ../init $(TARGET_ROOT_OUT)/sbin/ueventd; \</span><br><span class="line">    ln -sf ../init $(TARGET_ROOT_OUT)/sbin/watchdogd</span><br></pre></td></tr></table></figure>
</li>
<li><p>umask(0) 即设置创建文件的属性默认为0777.</p>
</li>
<li>is_first_stage是用来判断init是在内核空间还是在用户空间启动,is_first_stage为true意味着init是运行在kernel domain，因为selinux的相关设置需要在内核空间下.</li>
<li>如果是在内核启动,创建/dev，/proc，/sys目录并mount相应的虚拟内存文件系统</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open_devnull_stdio();</span><br><span class="line">klog_init();</span><br><span class="line">klog_set_level(KLOG_NOTICE_LEVEL);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>open_devnull_stdio();屏蔽标准输入/输出/错误,即无法通过stdin/stdout/stderr输出，如下代码所示,通过dup2()复制文件描述符，重定向stdin,stdout,stderr到/sys/fs/selinux/null或/dev/__null__上.(一般daemon进程都会有类似的屏蔽操作)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># ls /proc/1/fd -al</span><br><span class="line">lrwx------ 1 root root 64 1970-01-04 07:34 0 -&gt; /sys/fs/selinux/null</span><br><span class="line">lrwx------ 1 root root 64 1970-01-04 07:34 1 -&gt; /sys/fs/selinux/null</span><br><span class="line">lrwx------ 1 root root 64 1970-01-04 07:34 2 -&gt; /sys/fs/selinux/null</span><br><span class="line"></span><br><span class="line">void open_devnull_stdio(void)</span><br><span class="line">&#123;</span><br><span class="line">    // Try to avoid the mknod() call if we can. Since SELinux makes</span><br><span class="line">    // a /dev/null replacement available for free, let&apos;s use it.</span><br><span class="line">    int fd = open(&quot;/sys/fs/selinux/null&quot;, O_RDWR);</span><br><span class="line">    if (fd == -1) &#123;</span><br><span class="line">        // OOPS, /sys/fs/selinux/null isn&apos;t available, likely because</span><br><span class="line">        // /sys/fs/selinux isn&apos;t mounted. Fall back to mknod.</span><br><span class="line">        static const char *name = &quot;/dev/__null__&quot;;</span><br><span class="line">        if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 3) == 0) &#123;</span><br><span class="line">            fd = open(name, O_RDWR);</span><br><span class="line">            unlink(name);</span><br><span class="line">        &#125;</span><br><span class="line">        if (fd == -1) &#123;</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dup2(fd, 0);</span><br><span class="line">    dup2(fd, 1);</span><br><span class="line">    dup2(fd, 2);</span><br><span class="line">    if (fd &gt; 2) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>klog_init,创建kmsg设备节点,printk打印的log可以通过cat /proc/kmsg或者dmesg输出.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void klog_init(void) &#123;</span><br><span class="line">    if (klog_fd &gt;= 0) return; /* Already initialized */</span><br><span class="line"></span><br><span class="line">    klog_fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    if (klog_fd &gt;= 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static const char* name = &quot;/dev/__kmsg__&quot;;</span><br><span class="line">    if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 11) == 0) &#123;</span><br><span class="line">        klog_fd = open(name, O_WRONLY | O_CLOEXEC);</span><br><span class="line">        unlink(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>klog_set_level设置log等级</p>
</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (!is_first_stage) &#123;</span><br><span class="line">    // Indicate that booting is in progress to background fw loaders, etc.</span><br><span class="line">    close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000));</span><br><span class="line"></span><br><span class="line">    property_init();</span><br><span class="line"></span><br><span class="line">    // If arguments are passed both on the command line and in DT,</span><br><span class="line">    // properties set in DT always have priority over the command-line ones.</span><br><span class="line">    process_kernel_dt();</span><br><span class="line">    process_kernel_cmdline();</span><br><span class="line"></span><br><span class="line">    // Propagate the kernel variables to internal variables</span><br><span class="line">    // used by init as well as the current required properties.</span><br><span class="line">    export_kernel_boot_props();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建/dev/.booting，用来标志是否处于初始化过程中。如下init.rc代码片段所示，在late-init阶段，将触发firmware_mounts_complete，删除掉/dev/.booting</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Indicate to fw loaders that the relevant mounts are up.</span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">    rm /dev/.booting</span><br><span class="line"></span><br><span class="line"># Mount filesystems and start core system services.</span><br><span class="line">on late-init</span><br><span class="line">    ......</span><br><span class="line">    # Remove a file to wake up anything waiting for firmware.</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用property_init()初始化属性系统，在后面属性服务中详细描述.</p>
</li>
<li><p>调用process_kernel_dt()处理设置ro.boot.android,ro.boot.firmware二个属性.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static void process_kernel_dt() &#123;</span><br><span class="line">    static const char android_dir[] = &quot;/proc/device-tree/firmware/android&quot;;</span><br><span class="line"></span><br><span class="line">    std::string file_name = android::base::StringPrintf(&quot;%s/compatible&quot;, android_dir);</span><br><span class="line"></span><br><span class="line">    std::string dt_file;</span><br><span class="line">    android::base::ReadFileToString(file_name, &amp;dt_file);</span><br><span class="line">    if (!dt_file.compare(&quot;android,firmware&quot;)) &#123;</span><br><span class="line">        ERROR(&quot;firmware/android is not compatible with &apos;android,firmware&apos;\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;DIR, int(*)(DIR*)&gt;dir(opendir(android_dir), closedir);</span><br><span class="line">    if (!dir) return;</span><br><span class="line"></span><br><span class="line">    struct dirent *dp;</span><br><span class="line">    while ((dp = readdir(dir.get())) != NULL) &#123;</span><br><span class="line">        if (dp-&gt;d_type != DT_REG || !strcmp(dp-&gt;d_name, &quot;compatible&quot;) || !strcmp(dp-&gt;d_name, &quot;name&quot;)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file_name = android::base::StringPrintf(&quot;%s/%s&quot;, android_dir, dp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">        android::base::ReadFileToString(file_name, &amp;dt_file);</span><br><span class="line">        std::replace(dt_file.begin(), dt_file.end(), &apos;,&apos;, &apos;.&apos;);</span><br><span class="line"></span><br><span class="line">        std::string property_name = android::base::StringPrintf(&quot;ro.boot.%s&quot;, dp-&gt;d_name);</span><br><span class="line">        property_set(property_name.c_str(), dt_file.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用process_kernel_cmdline()读取/proc/cmdline文件,并设置cmdline文件中以androidboot.开头对应ro.boot.的属性值.例如<code>androidboot.hardware=qcom -&gt; [ro.boot.hardware]: [qcom]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void process_kernel_cmdline() &#123;</span><br><span class="line">    // Don&apos;t expose the raw commandline to unprivileged processes.</span><br><span class="line">    chmod(&quot;/proc/cmdline&quot;, 0440);</span><br><span class="line"></span><br><span class="line">    // The first pass does the common stuff, and finds if we are in qemu.</span><br><span class="line">    // The second pass is only necessary for qemu to export all kernel params</span><br><span class="line">    // as properties.</span><br><span class="line">    import_kernel_cmdline(false, import_kernel_nv);</span><br><span class="line">    if (qemu[0]) import_kernel_cmdline(true, import_kernel_nv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void import_kernel_nv(const std::string&amp; key, const std::string&amp; value, bool for_emulator) &#123;</span><br><span class="line">    if (key.empty()) return;</span><br><span class="line"></span><br><span class="line">    if (for_emulator) &#123;</span><br><span class="line">        // In the emulator, export any kernel option with the &quot;ro.kernel.&quot; prefix.</span><br><span class="line">        property_set(android::base::StringPrintf(&quot;ro.kernel.%s&quot;, key.c_str()).c_str(), value.c_str());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key == &quot;qemu&quot;) &#123;</span><br><span class="line">        strlcpy(qemu, value.c_str(), sizeof(qemu));</span><br><span class="line">    &#125; else if (android::base::StartsWith(key, &quot;androidboot.&quot;)) &#123;</span><br><span class="line">        property_set(android::base::StringPrintf(&quot;ro.boot.%s&quot;, key.c_str() + 12).c_str(),</span><br><span class="line">                     value.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用export_kernel_boot_props设置boot相关的属性.即根据设置prop_map中src_prop设置dst_prop的值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void export_kernel_boot_props() &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        const char *src_prop;</span><br><span class="line">        const char *dst_prop;</span><br><span class="line">        const char *default_value;</span><br><span class="line">    &#125; prop_map[] = &#123;</span><br><span class="line">        &#123; &quot;ro.boot.serialno&quot;,   &quot;ro.serialno&quot;,   &quot;&quot;, &#125;,</span><br><span class="line">        &#123; &quot;ro.boot.mode&quot;,       &quot;ro.bootmode&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">        &#123; &quot;ro.boot.baseband&quot;,   &quot;ro.baseband&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">        &#123; &quot;ro.boot.bootloader&quot;, &quot;ro.bootloader&quot;, &quot;unknown&quot;, &#125;,</span><br><span class="line">        &#123; &quot;ro.boot.hardware&quot;,   &quot;ro.hardware&quot;,   &quot;unknown&quot;, &#125;,</span><br><span class="line">        &#123; &quot;ro.boot.revision&quot;,   &quot;ro.revision&quot;,   &quot;0&quot;, &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    for (size_t i = 0; i &lt; ARRAY_SIZE(prop_map); i++) &#123;</span><br><span class="line">        std::string value = property_get(prop_map[i].src_prop);</span><br><span class="line">        property_set(prop_map[i].dst_prop, (!value.empty()) ? value.c_str() : prop_map[i].default_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">selinux_initialize(is_first_stage);</span><br><span class="line"></span><br><span class="line">// If we&apos;re in the kernel domain, re-exec init to transition to the init domain now</span><br><span class="line">// that the SELinux policy has been loaded.</span><br><span class="line">if (is_first_stage) &#123;</span><br><span class="line">    if (restorecon(&quot;/init&quot;) == -1) &#123;</span><br><span class="line">        ERROR(&quot;restorecon failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">    char* path = argv[0];</span><br><span class="line">    char* args[] = &#123; path, const_cast&lt;char*&gt;(&quot;--second-stage&quot;), nullptr &#125;;</span><br><span class="line">    // 初始化selinux后，在user domain执行init --second-stage</span><br><span class="line">    if (execv(path, args) == -1) &#123;</span><br><span class="line">        ERROR(&quot;execv(\&quot;%s\&quot;) failed: %s\n&quot;, path, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NOTICE(&quot;Running restorecon...\n&quot;);</span><br><span class="line">restorecon(&quot;/dev&quot;);</span><br><span class="line">restorecon(&quot;/dev/socket&quot;);</span><br><span class="line">restorecon(&quot;/dev/__properties__&quot;);</span><br><span class="line">restorecon(&quot;/property_contexts&quot;);</span><br><span class="line">restorecon_recursive(&quot;/sys&quot;);</span><br></pre></td></tr></table></figure>
<p>在kernel domaind调用selinux_initialize对selinux进行初始化,然后通过execv重新执行init –second-stage。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">if (epoll_fd == -1) &#123;</span><br><span class="line">    ERROR(&quot;epoll_create1 failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal_handler_init();</span><br><span class="line"></span><br><span class="line">property_load_boot_defaults();</span><br><span class="line">export_oem_lock_status();</span><br><span class="line">start_property_service();</span><br></pre></td></tr></table></figure>
<ol>
<li>epoll_create1创建epoll实例处理子进程退出及属性服务事件（EPOLL_CLOEXEC标志与open的O_CLOEXEC标志类似，即进程被替换时会关闭文件描述符），epoll_fd对应关联/proc/1/fd/下<code>eventpoll</code>的fd。</li>
<li>signal_handler_init()子进程信号处理,后面单独分析</li>
<li>初始化default属性并启动服务系统,后面单独分析</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">const BuiltinFunctionMap function_map;</span><br><span class="line">Action::set_function_map(&amp;function_map);</span><br><span class="line"></span><br><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">//ServiceParser解析`service section`</span><br><span class="line">parser.AddSectionParser(&quot;service&quot;,std::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">//ActionParser解析`action section`</span><br><span class="line">parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;());</span><br><span class="line">//ImportParser解析`import rc`</span><br><span class="line">parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;());</span><br><span class="line">//开始解析init.rc</span><br><span class="line">parser.ParseConfig(&quot;/init.rc&quot;);</span><br><span class="line"></span><br><span class="line">ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line"></span><br><span class="line">am.QueueEventTrigger(&quot;early-init&quot;);</span><br><span class="line"></span><br><span class="line">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span><br><span class="line">am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);</span><br><span class="line">// ... so that we can start queuing up actions that require stuff from /dev.</span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line">am.QueueBuiltinAction(set_mmap_rnd_bits_action, &quot;set_mmap_rnd_bits&quot;);</span><br><span class="line">am.QueueBuiltinAction(keychord_init_action, &quot;keychord_init&quot;);</span><br><span class="line">am.QueueBuiltinAction(console_init_action, &quot;console_init&quot;);</span><br><span class="line"></span><br><span class="line">// Trigger all the boot actions to get us started.</span><br><span class="line">am.QueueEventTrigger(&quot;init&quot;);</span><br><span class="line"></span><br><span class="line">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span><br><span class="line">// wasn&apos;t ready immediately after wait_for_coldboot_done</span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);</span><br><span class="line"></span><br><span class="line">// Don&apos;t mount filesystems or start core system services in charger mode.</span><br><span class="line">std::string bootmode = property_get(&quot;ro.bootmode&quot;);</span><br><span class="line">if (bootmode == &quot;charger&quot;) &#123;　 // 是否是关机充电模式</span><br><span class="line">    am.QueueEventTrigger(&quot;charger&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    am.QueueEventTrigger(&quot;late-init&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Run all property triggers based on current state of the properties.</span><br><span class="line">am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;);</span><br></pre></td></tr></table></figure>
<ol>
<li>根据action,service,import解析/init.rc,其中ServiceParser，ActionParser，ImportParser都继承自SectionParse，根据不同的keryword解析initrc文件，将service与action项分别加入到service<em>与action</em>表中。</li>
<li>通过QueueEventTrigger，QueueBuiltinAction把对应的action放到trigger<em>queue</em>表中。</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    //判断是否有事件需要处理</span><br><span class="line">    if (!waiting_for_exec) &#123;</span><br><span class="line">        //依次执行每个action中command</span><br><span class="line">        am.ExecuteOneCommand();</span><br><span class="line">        //重启退出的进程</span><br><span class="line">        restart_processes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int timeout = -1;</span><br><span class="line">    //有进程需要重启则等待该进程重启</span><br><span class="line">    if (process_needs_restart) &#123;</span><br><span class="line">        timeout = (process_needs_restart - gettime()) * 1000;</span><br><span class="line">        if (timeout &lt; 0)</span><br><span class="line">            timeout = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //还有action要处理则不等待</span><br><span class="line">    if (am.HasMoreCommands()) &#123;</span><br><span class="line">        timeout = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bootchart_sample(&amp;timeout);</span><br><span class="line"></span><br><span class="line">    epoll_event ev;</span><br><span class="line">    //等待epoll_event事件到来，等待timeout时间</span><br><span class="line">    int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout));</span><br><span class="line">    if (nr == -1) &#123;</span><br><span class="line">        ERROR(&quot;epoll_wait failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    &#125; else if (nr == 1) &#123;</span><br><span class="line">        //epoll_event事件到来，执行对应处理函数</span><br><span class="line">        ((void (*)()) ev.data.ptr)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while循环不断调用ExecuteOneCommand函数时，将按照trigger表的顺序，依次取出action链表中与trigger匹配的action。每次均执行一个action中的一个command对应函数（一个action可能携带多个command）。当一个action所有的command均执行完毕后，再执行下一个action。当一个trigger对应的action均执行完毕后，再执行下一个trigger对应action。</p>
<h1 id="子进程信号处理"><a href="#子进程信号处理" class="headerlink" title="子进程信号处理"></a>子进程信号处理</h1><p>由于Init进程是系统的1号进程，其他用户进程都是由其直接或间接生成，所以init进程的作用之一就是处理子进程的退出。进程在退出时内核会发出SIGCHLD信号，父进程收到该信号就可以处理子进程的退出从而防止子进程变成僵尸进程。另外，当进程退出时，该进程下所有的子进程都将变成init的子进程，由init负责对他们退出的处理。下面从signal_handler_init()分析Init对子进程退出的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void signal_handler_init() &#123;</span><br><span class="line">    int s[2];</span><br><span class="line">    // 创建一对连接的socket</span><br><span class="line">    if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, s) == -1) &#123;</span><br><span class="line">        ERROR(&quot;socketpair failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal_write_fd = s[0];</span><br><span class="line">    signal_read_fd = s[1];</span><br><span class="line"></span><br><span class="line">    // 注册SIGCHLD的处理函数</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    memset(&amp;act, 0, sizeof(act));</span><br><span class="line">    act.sa_handler = SIGCHLD_handler;</span><br><span class="line">    act.sa_flags = SA_NOCLDSTOP;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, 0);</span><br><span class="line"></span><br><span class="line">    // 处理函数，处理子进程的退出</span><br><span class="line">    ServiceManager::GetInstance().ReapAnyOutstandingChildren();</span><br><span class="line"></span><br><span class="line">    // 将signal_read_fd注册到epoll_fd上的的epoll可读事件</span><br><span class="line">    register_epoll_handler(signal_read_fd, handle_signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>为了同时处理多个信号，通过socket来通信，socketpair创建一对已连接的本地socket，signal_write_fd端写，signal_read_fd端读。</li>
<li><p>sigaction注册SIGCHLD信号的处理函数SIGCHLD_handler(SA_NOCLDSTOP标志只有当子进程结束才接收SIGCHLD信号)，即收到SIGCHLD信号后往signal_write_fd中写入”1”，触发signal_read_fd上的epoll处理事件handle_signal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void SIGCHLD_handler(int) &#123;</span><br><span class="line">    if (TEMP_FAILURE_RETRY(write(signal_write_fd, &quot;1&quot;, 1)) == -1) &#123;</span><br><span class="line">        ERROR(&quot;write(signal_write_fd) failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReapAnyOutstandingChildren()处理子进程的退出，下面具体分析</p>
</li>
<li>register_epoll_handler注册signal_read_fd到epoll_fd上，并关联EPOLLIN读事件，epoll_fd上的事件在main()中循环处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void register_epoll_handler(int fd, void (*fn)()) &#123;</span><br><span class="line">    epoll_event ev;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.ptr = reinterpret_cast&lt;void*&gt;(fn);</span><br><span class="line">    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) == -1) &#123;</span><br><span class="line">        ERROR(&quot;epoll_ctl failed: %s\n&quot;, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void handle_signal() &#123;</span><br><span class="line">    // Clear outstanding requests.</span><br><span class="line">    char buf[32];</span><br><span class="line">    read(signal_read_fd, buf, sizeof(buf));</span><br><span class="line"></span><br><span class="line">    ServiceManager::GetInstance().ReapAnyOutstandingChildren();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终，在ServiceManager的ReapAnyOutstandingChildren()来处理子进程的退出.下面具体分析ReapAnyOutstandingChildren</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void ServiceManager::ReapAnyOutstandingChildren() &#123;</span><br><span class="line">    while (ReapOneProcess()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool ServiceManager::ReapOneProcess() &#123;</span><br><span class="line">    int status;</span><br><span class="line">    // 等待子进程结束避免成为僵尸进程(第一个参数-1表示等待任意子进程结束，最后一个参数WNOHANG表示非阻塞)</span><br><span class="line">    pid_t pid = TEMP_FAILURE_RETRY(waitpid(-1, &amp;status, WNOHANG));</span><br><span class="line">    // 无子进程退出，返回false结束循环</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">        //执行失败，返回false结束循环</span><br><span class="line">    &#125; else if (pid == -1) &#123;</span><br><span class="line">        ERROR(&quot;waitpid failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据pid在services_中查找对应的service</span><br><span class="line">    Service* svc = FindServiceByPid(pid);</span><br><span class="line"></span><br><span class="line">    std::string name;</span><br><span class="line">    if (svc) &#123;</span><br><span class="line">        name = android::base::StringPrintf(&quot;Service &apos;%s&apos; (pid %d)&quot;,</span><br><span class="line">                                           svc-&gt;name().c_str(), pid);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        name = android::base::StringPrintf(&quot;Untracked pid %d&quot;, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出相关信息</span><br><span class="line">    if (WIFEXITED(status)) &#123;</span><br><span class="line">        NOTICE(&quot;%s exited with status %d\n&quot;, name.c_str(), WEXITSTATUS(status));</span><br><span class="line">    &#125; else if (WIFSIGNALED(status)) &#123;</span><br><span class="line">        NOTICE(&quot;%s killed by signal %d\n&quot;, name.c_str(), WTERMSIG(status));</span><br><span class="line">    &#125; else if (WIFSTOPPED(status)) &#123;</span><br><span class="line">        NOTICE(&quot;%s stopped by signal %d\n&quot;, name.c_str(), WSTOPSIG(status));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NOTICE(&quot;%s state changed&quot;, name.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不是服务进程，处理到此结束，直接退出</span><br><span class="line">    if (!svc) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 服务进程，svc-&gt;Reap()进一步处理</span><br><span class="line">    if (svc-&gt;Reap()) &#123;</span><br><span class="line">        waiting_for_exec = false;</span><br><span class="line">        RemoveService(*svc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>while循环中调用ReapOneProcess处理</li>
<li>waitpid()等待子进程退出结束(WNOHANG标志没有子进程死亡立即返回)，以获取子进程结束信息清除zombie</li>
<li>对于一般子进程,waitpid后处理结束.但如果退出的是服务进程的话,那么会通过svc-&gt;Reap()对其进一步处理</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">bool Service::Reap() &#123;</span><br><span class="line">   //kill未定义SVC_ONESHOT或定义了SVC_RESTART标志的service的子进程</span><br><span class="line">   if (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">       NOTICE(&quot;Service &apos;%s&apos; (pid %d) killing any children in process group\n&quot;,</span><br><span class="line">              name_.c_str(), pid_);</span><br><span class="line">        kill(-pid_, SIGKILL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除创建的socket</span><br><span class="line">    for (const auto&amp; si : sockets_) &#123;</span><br><span class="line">        std::string tmp = StringPrintf(ANDROID_SOCKET_DIR &quot;/%s&quot;, si.name.c_str());</span><br><span class="line">        unlink(tmp.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (flags_ &amp; SVC_EXEC) &#123;</span><br><span class="line">        INFO(&quot;SVC_EXEC pid %d finished...\n&quot;, pid_);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid_ = 0;</span><br><span class="line">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class="line"></span><br><span class="line">    // Oneshot processes go into the disabled state on exit,</span><br><span class="line">    //未定义SVC_ONESHOT与SVC_RESTART的service，标志置为SVC_DISABLED，不再启动</span><br><span class="line">    if ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Disabled and reset processes do not get restarted automatically.</span><br><span class="line">    if (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">        NotifyStateChange(&quot;stopped&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time_t now = gettime();</span><br><span class="line">    // 定义SVC_CRITICAL且没有定义SVC_RESTART的service重启超过４次进入recovery</span><br><span class="line">    if ((flags_ &amp; SVC_CRITICAL) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        if (time_crashed_ + CRITICAL_CRASH_WINDOW &gt;= now) &#123;</span><br><span class="line">            if (++nr_crashed_ &gt; CRITICAL_CRASH_THRESHOLD) &#123;</span><br><span class="line">                ERROR(&quot;critical process &apos;%s&apos; exited %d times in %d minutes; &quot;</span><br><span class="line">                      &quot;rebooting into recovery mode\n&quot;, name_.c_str(),</span><br><span class="line">                      CRITICAL_CRASH_THRESHOLD, CRITICAL_CRASH_WINDOW / 60);</span><br><span class="line">                android_reboot(ANDROID_RB_RESTART2, 0, &quot;recovery&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            time_crashed_ = now;</span><br><span class="line">            nr_crashed_ = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags_ &amp;= (~SVC_RESTART);</span><br><span class="line">    flags_ |= SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line">    //执行当前service中所有onrestart命令</span><br><span class="line">    onrestart_.ExecuteAllCommands();</span><br><span class="line"></span><br><span class="line">    NotifyStateChange(&quot;restarting&quot;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reap()中主要是对service进程的flag进行分析,来判断是否需要重启该service进程,定义了SVC_ONESHOT的服务进程不会重启,状态改为stopped.定义了SVC_CRITICAL与SVC_RESTART的关键服务如果重启超过4次,系统将reboot到recovery.服务进程在重启前将移除其创建的socket(/dev/socket/),杀死其所有子进程,并通过NotifyStateChange改变其状态为restarting(即设置init.svc.属性状态),并执行initrc中该服务定义的onrestart命令.</p>
<h1 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h1><p>Android的属性是以字符串键值形式保存的系统的关键值(可通过adb shell getprop打印所有的prop),在Android系统中，很多系统模块/应用的功能都是通过属性来控制的,属性设置也是通过Init进行管理管理理.<br>下面从void property_init开始分析属性服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">// system/core/init/property_service.cpp</span><br><span class="line">// property_init创建一块用于存储属性的共享内存</span><br><span class="line">void property_init() &#123;</span><br><span class="line">    if (__system_property_area_init()) &#123;</span><br><span class="line">        ERROR(&quot;Failed to initialize property area\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bionic/libc/include/sys/_system_properties.h</span><br><span class="line"></span><br><span class="line">#define PROP_FILENAME &quot;/dev/__properties__&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">** Initialize the area to be used to store properties.  Can</span><br><span class="line">** only be done by a single process that has write access to</span><br><span class="line">** the property area.</span><br><span class="line">*/</span><br><span class="line">int __system_property_area_init();</span><br><span class="line"></span><br><span class="line">// bionic/libc/bionic/system_properties.cpp</span><br><span class="line"></span><br><span class="line">static char property_filename[PROP_FILENAME_MAX] = PROP_FILENAME;</span><br><span class="line"></span><br><span class="line">int __system_property_area_init()</span><br><span class="line">&#123;</span><br><span class="line">    free_and_unmap_contexts();</span><br><span class="line">    mkdir(property_filename, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);</span><br><span class="line">    if (!initialize_properties()) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool open_failed = false;</span><br><span class="line">    bool fsetxattr_failed = false;</span><br><span class="line">    list_foreach(contexts, [&amp;fsetxattr_failed, &amp;open_failed](context_node* l) &#123;</span><br><span class="line">        if (!l-&gt;open(true, &amp;fsetxattr_failed)) &#123;</span><br><span class="line">            open_failed = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (open_failed || !map_system_property_area(true, &amp;fsetxattr_failed)) &#123;</span><br><span class="line">        free_and_unmap_contexts();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    initialized = true;</span><br><span class="line">    return fsetxattr_failed ? -2 : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __system_property_area_init()</span><br><span class="line">&#123;</span><br><span class="line">    return map_prop_area_rw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int map_prop_area_rw()</span><br><span class="line">&#123;</span><br><span class="line">    /* dev is a tmpfs that we can use to carve a shared workspace</span><br><span class="line">     * out of, so let&apos;s do that...</span><br><span class="line">     */</span><br><span class="line">    const int fd = open(property_filename,</span><br><span class="line">                        O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC | O_EXCL, 0444);</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        if (errno == EACCES) &#123;</span><br><span class="line">            /* for consistency with the case where the process has already</span><br><span class="line">             * mapped the page in and segfaults when trying to write to it</span><br><span class="line">             */</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ftruncate(fd, PA_SIZE) &lt; 0) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pa_size = PA_SIZE;</span><br><span class="line">    pa_data_size = pa_size - sizeof(prop_area);</span><br><span class="line">    compat_mode = false;</span><br><span class="line"></span><br><span class="line">    void *const memory_area = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</span><br><span class="line">    if (memory_area == MAP_FAILED) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prop_area *pa = new(memory_area) prop_area(PROP_AREA_MAGIC, PROP_AREA_VERSION);</span><br><span class="line"></span><br><span class="line">    /* plug into the lib property services */</span><br><span class="line">    __system_property_area__ = pa;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>property_init主要是分配一块共享的内存区域(/dev/<strong>properties</strong>)存储属性值 //TODO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bionic/libc/include/sys/_system_properties.h:90:#define PROP_PATH_RAMDISK_DEFAULT  &quot;/default.prop&quot;</span><br><span class="line"></span><br><span class="line">property_load_boot_defaults();</span><br></pre></td></tr></table></figure>
<p>property_load_boot_defaults中读取并初始化/default.prop文件中的属性值,接着调用start_property_service()启动属性服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void start_property_service() &#123;</span><br><span class="line">    property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class="line">                                    0666, 0, 0, NULL);</span><br><span class="line">    if (property_set_fd == -1) &#123;</span><br><span class="line">        ERROR(&quot;start_property_service socket creation failed: %s\n&quot;, strerror(errno));</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen(property_set_fd, 8);</span><br><span class="line"></span><br><span class="line">    register_epoll_handler(property_set_fd, handle_property_set_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>start_property_service中创建并监听属性服务的socket，并加入到property_set_fd上的epoll事件监听中,其他进程属性设置的请求都将通过handle_property_set_fd来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">static void handle_property_set_fd()</span><br><span class="line">&#123;</span><br><span class="line">    prop_msg msg;</span><br><span class="line">    int s;</span><br><span class="line">    int r;</span><br><span class="line">    struct ucred cr;</span><br><span class="line">    struct sockaddr_un addr;</span><br><span class="line">    socklen_t addr_size = sizeof(addr);</span><br><span class="line">    socklen_t cr_size = sizeof(cr);</span><br><span class="line">    char * source_ctx = NULL;</span><br><span class="line">    struct pollfd ufds[1];</span><br><span class="line">    const int timeout_ms = 2 * 1000;  /* Default 2 sec timeout for caller to send property. */</span><br><span class="line">    int nr;</span><br><span class="line"></span><br><span class="line">    if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check socket options here */</span><br><span class="line">    if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) &#123;</span><br><span class="line">        close(s);</span><br><span class="line">        ERROR(&quot;Unable to receive socket options\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ufds[0].fd = s;</span><br><span class="line">    ufds[0].events = POLLIN;</span><br><span class="line">    ufds[0].revents = 0;</span><br><span class="line">    nr = TEMP_FAILURE_RETRY(poll(ufds, 1, timeout_ms));</span><br><span class="line">    if (nr == 0) &#123;</span><br><span class="line">        ERROR(&quot;sys_prop: timeout waiting for uid=%d to send property message.\n&quot;, cr.uid);</span><br><span class="line">        close(s);</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (nr &lt; 0) &#123;</span><br><span class="line">        ERROR(&quot;sys_prop: error waiting for uid=%d to send property message: %s\n&quot;, cr.uid, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), MSG_DONTWAIT));</span><br><span class="line">    if(r != sizeof(prop_msg)) &#123;</span><br><span class="line">        ERROR(&quot;sys_prop: mis-match msg size received: %d expected: %zu: %s\n&quot;,</span><br><span class="line">              r, sizeof(prop_msg), strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(msg.cmd) &#123;</span><br><span class="line">    case PROP_MSG_SETPROP:</span><br><span class="line">        msg.name[PROP_NAME_MAX-1] = 0;</span><br><span class="line">        msg.value[PROP_VALUE_MAX-1] = 0;</span><br><span class="line"></span><br><span class="line">        if (!is_legal_property_name(msg.name, strlen(msg.name))) &#123;</span><br><span class="line">            ERROR(&quot;sys_prop: illegal property name. Got: \&quot;%s\&quot;\n&quot;, msg.name);</span><br><span class="line">            close(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getpeercon(s, &amp;source_ctx);</span><br><span class="line"></span><br><span class="line">        if(memcmp(msg.name,&quot;ctl.&quot;,4) == 0) &#123;</span><br><span class="line">            // Keep the old close-socket-early behavior when handling</span><br><span class="line">            // ctl.* properties.</span><br><span class="line">            close(s);</span><br><span class="line">            if (check_control_mac_perms(msg.value, source_ctx, &amp;cr)) &#123;</span><br><span class="line">                handle_control_message((char*) msg.name + 4, (char*) msg.value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ERROR(&quot;sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n&quot;,</span><br><span class="line">                        msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (check_mac_perms(msg.name, source_ctx, &amp;cr)) &#123;</span><br><span class="line">                property_set((char*) msg.name, (char*) msg.value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ERROR(&quot;sys_prop: permission denied uid:%d  name:%s\n&quot;,</span><br><span class="line">                      cr.uid, msg.name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Note: bionic&apos;s property client code assumes that the</span><br><span class="line">            // property server will not close the socket until *AFTER*</span><br><span class="line">            // the property is written to memory.</span><br><span class="line">            close(s);</span><br><span class="line">        &#125;</span><br><span class="line">        freecon(source_ctx);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        close(s);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handle_property_set_fd()接收子进程请求并设置相关的属性值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之Init.rc语法]]></title>
      <url>http://robinheztto.com/2016/02/01/android-init-language/</url>
      <content type="html"><![CDATA[<blockquote>
<p>译自system/core/init/readme.txt</p>
</blockquote>
<h1 id="Android-init-rc语法"><a href="#Android-init-rc语法" class="headerlink" title="Android init.rc语法"></a>Android init.rc语法</h1><p>Android init.rc包含四种类型的声明，分别是 <strong>Actions</strong>，<strong>Commands</strong>，<strong>Services</strong>，和 <strong>Options</strong>。<br>其语法规则如下：</p>
<ul>
<li><p>init.rc所有的语句都是以行为单位，行间使用空格分隔符号，类似C语言，使用”\”续行，类似shell脚本以”#”进行行注释。</p>
</li>
<li><p>Actions和Services默认声明一个新的section，所有该section下的command与options都属于它，在section前申明的command和options将会被其忽略。</p>
</li>
<li><p>Actions与Services的命名是唯一的,重复的定义被视为无效。</p>
</li>
</ul>
<h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><p>Action是由一系列命令组成并由”on”开头的语句,通过trigger来决定什么时候执行(“on”后面跟的字符串即为ation的trigger).当trigger事件发生时，如果action不在to-be-executed中，将被加入到to-be-executed的队尾等待执行。</p>
<p>在to-be-executed队列中的每个action按FIFO顺序执行，同样action中的command也是按定义的先后顺序依次执行。init除了执行action的command，还负责设备节点的创建及销毁，属性设置，进程重启等工作。</p>
<p>Actions的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>services,以“service”字符串开头，由init进程启动并且可以在退出时重启(可选)，services的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p>
<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>options是services的可选项，它决定service的执行行为.</p>
<ul>
<li>critical<br>表示关键的service，如果service 4分钟内异常退出4次将会重启进入recovery模式。</li>
<li>disabled<br>指定disable的service，不能通过class service(class_start)启动，只有通过<code>start service_name</code>启动时才能启动</li>
<li>setenv &lt;&lt;name&gt; &lt;value&gt;<br>service启动时设置环境变量值</li>
<li>socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ]<br>为要启动的进程创建名为/dev/socket/&lt;name&gt;的socket,&lt;type&gt;可选”dgram”或”stream”,&lt;user&gt; [ &lt;group&gt;默认为0.</li>
<li>user &lt;username&gt;<br>在service启动时为其设置user，默认为root</li>
<li>group &lt;groupname&gt; [ &lt;groupname&gt; ]*<br>在service启动时为其设置group，默认为root</li>
<li>seclabel &lt;seclabel&gt;<br>SELinux security context</li>
<li>oneshot<br>定义oneshot的service，退出后不再重启</li>
<li>class &lt;name&gt;<br>指服务所属的class，同一class的服务可以同时启动或停止.默认为default</li>
<li>onrestart<br>服务重启时执行命令</li>
</ul>
<h2 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h2><p>Triggers是on后面的字符串，匹配某类事件的发生来执行action。</p>
<ul>
<li><p>boot<br>init执行后触发的第一个trigger.</p>
</li>
<li><p>&lt;name&gt;=&lt;value&gt;<br>设置属性值时触发Trigger</p>
</li>
</ul>
<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p>Commands即Action或Services onrestart中所执行的命令,下面是常用的命令。</p>
<ul>
<li><p>bootchart_init<br> 启动bootcharting</p>
</li>
<li><p>chmod &lt;octal-mode&gt; &lt;path&gt;<br>chmod权限</p>
</li>
<li><p>chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;<br> chown用户/组</p>
</li>
<li><p>class_start &lt;serviceclass&gt;<br>启动serviceclass下所有未启动的服务服务,disable的除外</p>
</li>
<li><p>class_stop &lt;serviceclass&gt;<br>停止serviceclass下所有已启动的服务服务,disable的除外</p>
</li>
<li><p>class_reset &lt;serviceclass&gt;<br> Stop all services of the specified class if they are<br> currently running, without disabling them. They can be restarted<br> later using class_start.</p>
</li>
<li><p>copy &lt;src&gt; &lt;dst&gt;<br> copy操作</p>
</li>
<li><p>domainname &lt;name&gt;<br> 设置domain name.</p>
</li>
<li><p>enable &lt;servicename&gt;<br>enable服务，该服务可以随class service启动或停止</p>
</li>
<li><p>exec [ &lt;seclabel&gt; [&lt;user&gt; [ &lt;group&gt; ]<em> ] ] – &lt;command&gt; [ &lt;argument&gt; ]</em><br>fork并执行command，将阻塞init直到执行完毕</p>
</li>
<li><p>export &lt;name&gt; &lt;value&gt;<br>export环境变量值</p>
</li>
<li><p>hostname &lt;name&gt;<br> 设置hostname.</p>
</li>
<li><p>ifup &lt;interface&gt;<br>启用网络接口</p>
</li>
<li><p>import &lt;filename&gt;<br>import其他initrc文件</p>
</li>
<li><p>insmod &lt;path&gt;<br>加载指定驱动模块</p>
</li>
<li><p>load_all_props<br> Loads properties from /system, /vendor, et cetera.<br> This is included in the default init.rc.</p>
</li>
<li><p>load_persist_props<br> Loads persistent properties when /data has been decrypted.<br> This is included in the default init.rc.</p>
</li>
<li><p>loglevel &lt;level&gt;<br>设置log级别</p>
</li>
<li><p>mkdir &lt;path&gt; [mode] [owner] [group]<br>创建dir</p>
</li>
<li><p>mount_all &lt;fstab&gt;<br>mount所有fstab.</p>
</li>
<li><p>mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt; ]* [&lt;options&gt;]<br>mount文件系统到执行目录</p>
</li>
<li><p>powerctl<br> Internal implementation detail used to respond to changes to the<br> “sys.powerctl” system property, used to implement rebooting.</p>
</li>
<li><p>restart &lt;service&gt;<br>restart服务</p>
</li>
<li><p>restorecon &lt;path&gt; [ &lt;path&gt; ]*<br>重新存储&lt;path&gt;到由file_contexts配置的安全上下文.</p>
</li>
<li><p>restorecon_recursive &lt;path&gt; [ &lt;path&gt; ]*<br> Recursively restore the directory tree named by &lt;path&gt; to the<br> security contexts specified in the file_contexts configuration.</p>
</li>
<li><p>rm &lt;path&gt;<br>rm文件</p>
</li>
<li><p>rmdir &lt;path&gt;<br>rmdir</p>
</li>
<li><p>setprop &lt;name&gt; &lt;value&gt;<br>设置属性</p>
</li>
<li><p>setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;<br>设置进程占用的资源大小，包括可打开文件数目，大小</p>
</li>
<li><p>start &lt;service&gt;<br> 启动服务</p>
</li>
<li><p>stop &lt;service&gt;<br>停止服务</p>
</li>
<li><p>swapon_all &lt;fstab&gt;<br> Calls fs_mgr_swapon_all on the given fstab file.</p>
</li>
<li><p>symlink &lt;target&gt; &lt;path&gt;<br>创建连接到target的path符号链接</p>
</li>
<li><p>sysclktz &lt;mins_west_of_gmt&gt;<br> Set the system clock base (0 if system clock ticks in GMT)</p>
</li>
<li><p>trigger &lt;event&gt;<br>trigger的事件</p>
</li>
<li><p>verity_load_state<br> Internal implementation detail used to load dm-verity state.</p>
</li>
<li><p>verity_update_state &lt;mount_point&gt;<br> Internal implementation detail used to update dm-verity state and<br> set the partition.&lt;mount_point&gt;.verified properties used by adb remount<br> because fs_mgr can’t set them directly itself.</p>
</li>
<li><p>wait &lt;path&gt; [ &lt;timeout&gt; ]<br> Poll文件，默认timeout为5s</p>
</li>
<li><p>write &lt;path&gt; &lt;content&gt;<br>打开指定文件并写入字符串</p>
</li>
</ul>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>Init进程运行过程中,以下的属性值会随时更新(可通过adb shell getprop查看)：</p>
<ul>
<li><p>init.action<br>当前执行的action</p>
</li>
<li><p>init.command<br>将被执行的命令</p>
</li>
<li><p>init.svc.&lt;name&gt;<br>服务的运行状态(“stopped”, “running”, “restarting”)</p>
</li>
</ul>
<hr>
<h1 id="Android-Init-Language"><a href="#Android-Init-Language" class="headerlink" title="Android Init Language"></a>Android Init Language</h1><p>The Android Init Language consists of four broad classes of statements,<br>which are Actions, Commands, Services, and Options.</p>
<p>All of these are line-oriented, consisting of tokens separated by<br>whitespace.  The c-style backslash escapes may be used to insert<br>whitespace into a token.  Double quotes may also be used to prevent<br>whitespace from breaking text into multiple tokens.  The backslash,<br>when it is the last character on a line, may be used for line-folding.</p>
<p>Lines which start with a # (leading whitespace allowed) are comments.</p>
<p>Actions and Services implicitly declare a new section.  All commands<br>or options belong to the section most recently declared.  Commands<br>or options before the first section are ignored.</p>
<p>Actions and Services have unique names.  If a second Action or Service<br>is declared with the same name as an existing one, it is ignored as<br>an error.  (??? should we override instead)</p>
<h2 id="Actions-1"><a href="#Actions-1" class="headerlink" title="Actions"></a>Actions</h2><p>Actions are named sequences of commands.  Actions have a trigger which<br>is used to determine when the action should occur.  When an event<br>occurs which matches an action’s trigger, that action is added to<br>the tail of a to-be-executed queue (unless it is already on the<br>queue).</p>
<p>Each action in the queue is dequeued in sequence and each command in<br>that action is executed in sequence.  Init handles other activities<br>(device creation/destruction, property setting, process restarting)<br>“between” the execution of the commands in activities.</p>
<p>Actions take the form of:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Services-1"><a href="#Services-1" class="headerlink" title="Services"></a>Services</h2><p>Services are programs which init launches and (optionally) restarts<br>when they exit.  Services take the form of:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p>
<h2 id="Options-1"><a href="#Options-1" class="headerlink" title="Options"></a>Options</h2><p>Options are modifiers to services.  They affect how and when init<br>runs the service.</p>
<p>critical<br>  This is a device-critical service. If it exits more than four times in<br>  four minutes, the device will reboot into recovery mode.</p>
<p>disabled<br>  This service will not automatically start with its class.<br>  It must be explicitly started by name.</p>
<p>setenv &lt;name&gt; &lt;value&gt;<br>  Set the environment variable &lt;name&gt; to &lt;value&gt; in the launched process.</p>
<p>socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;seclabel&gt; ] ] ]<br>  Create a unix domain socket named /dev/socket/&lt;name&gt; and pass<br>  its fd to the launched process.  &lt;type&gt; must be “dgram”, “stream” or “seqpacket”.<br>  User and group default to 0.<br>  ‘seclabel’ is the SELinux security context for the socket.<br>  It defaults to the service security context, as specified by seclabel or<br>  computed based on the service executable file security context.</p>
<p>user &lt;username&gt;<br>  Change to username before exec’ing this service.<br>  Currently defaults to root.  (??? probably should default to nobody)<br>  Currently, if your process requires linux capabilities then you cannot use<br>  this command. You must instead request the capabilities in-process while<br>  still root, and then drop to your desired uid.</p>
<p>group &lt;groupname&gt; [ &lt;groupname&gt; ]*<br>  Change to groupname before exec’ing this service.  Additional<br>  groupnames beyond the (required) first one are used to set the<br>  supplemental groups of the process (via setgroups()).<br>  Currently defaults to root.  (??? probably should default to nobody)</p>
<p>seclabel &lt;seclabel&gt;<br>  Change to ‘seclabel’ before exec’ing this service.<br>  Primarily for use by services run from the rootfs, e.g. ueventd, adbd.<br>  Services on the system partition can instead use policy-defined transitions<br>  based on their file security context.<br>  If not specified and no transition is defined in policy, defaults to the init context.</p>
<p>oneshot<br>  Do not restart the service when it exits.</p>
<p>class &lt;name&gt;<br>  Specify a class name for the service.  All services in a<br>  named class may be started or stopped together.  A service<br>  is in the class “default” if one is not specified via the<br>  class option.</p>
<p>onrestart<br>  Execute a Command (see below) when service restarts.</p>
<p>writepid &lt;file…&gt;<br>  Write the child’s pid to the given files when it forks. Meant for<br>  cgroup/cpuset usage.</p>
<h2 id="Triggers-1"><a href="#Triggers-1" class="headerlink" title="Triggers"></a>Triggers</h2><p>Triggers are strings which can be used to match certain kinds<br>of events and used to cause an action to occur.</p>
<p>boot<br>   This is the first trigger that will occur when init starts<br>   (after /init.conf is loaded)</p>
<p>&lt;name&gt;=&lt;value&gt;<br>   Triggers of this form occur when the property &lt;name&gt; is set<br>   to the specific value &lt;value&gt;.</p>
<p>   One can also test multiple properties to execute a group<br>   of commands. For example:</p>
<p>   on property:test.a=1 &amp;&amp; property:test.b=1<br>       setprop test.c 1</p>
<p>   The above stub sets test.c to 1 only when<br>   both test.a=1 and test.b=1</p>
<h2 id="Commands-1"><a href="#Commands-1" class="headerlink" title="Commands"></a>Commands</h2><p>bootchart_init<br>   Start bootcharting if configured (see below).<br>   This is included in the default init.rc.</p>
<p>chmod &lt;octal-mode&gt; &lt;path&gt;<br>   Change file access permissions.</p>
<p>chown &lt;owner&gt; &lt;group&gt; &lt;path&gt;<br>   Change file owner and group.</p>
<p>class_start &lt;serviceclass&gt;<br>   Start all services of the specified class if they are<br>   not already running.</p>
<p>class_stop &lt;serviceclass&gt;<br>   Stop and disable all services of the specified class if they are<br>   currently running.</p>
<p>class_reset &lt;serviceclass&gt;<br>   Stop all services of the specified class if they are<br>   currently running, without disabling them. They can be restarted<br>   later using class_start.</p>
<p>copy &lt;src&gt; &lt;dst&gt;<br>   Copies a file. Similar to write, but useful for binary/large<br>   amounts of data.</p>
<p>domainname &lt;name&gt;<br>   Set the domain name.</p>
<p>enable &lt;servicename&gt;<br>   Turns a disabled service into an enabled one as if the service did not<br>   specify disabled.<br>   If the service is supposed to be running, it will be started now.<br>   Typically used when the bootloader sets a variable that indicates a specific<br>   service should be started when needed. E.g.<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on property:ro.boot.myfancyhardware=1</span><br><span class="line">  enable my_fancy_service_for_my_fancy_hardware</span><br></pre></td></tr></table></figure></p>
<p>exec [ &lt;seclabel&gt; [ &lt;user&gt; [ &lt;group&gt; ]<em> ] ] – &lt;command&gt; [ &lt;argument&gt; ]</em><br>   Fork and execute command with the given arguments. The command starts<br>   after “–” so that an optional security context, user, and supplementary<br>   groups can be provided. No other commands will be run until this one<br>   finishes. &lt;seclabel&gt; can be a - to denote default.</p>
<p>export &lt;name&gt; &lt;value&gt;<br>   Set the environment variable &lt;name&gt; equal to &lt;value&gt; in the<br>   global environment (which will be inherited by all processes<br>   started after this command is executed)</p>
<p>hostname &lt;name&gt;<br>   Set the host name.</p>
<p>ifup &lt;interface&gt;<br>   Bring the network interface &lt;interface&gt; online.</p>
<p>import &lt;filename&gt;<br>   Parse an init config file, extending the current configuration.</p>
<p>insmod &lt;path&gt;<br>   Install the module at &lt;path&gt;</p>
<p>load_all_props<br>   Loads properties from /system, /vendor, et cetera.<br>   This is included in the default init.rc.</p>
<p>load_persist_props<br>   Loads persistent properties when /data has been decrypted.<br>   This is included in the default init.rc.</p>
<p>loglevel &lt;level&gt;<br>   Sets the kernel log level to level. Properties are expanded within &lt;level&gt;.</p>
<p>mkdir &lt;path&gt; [mode] [owner] [group]<br>   Create a directory at &lt;path&gt;, optionally with the given mode, owner, and<br>   group. If not provided, the directory is created with permissions 755 and<br>   owned by the root user and root group. If provided, the mode, owner and group<br>   will be updated if the directory exists already.</p>
<p>mount_all &lt;fstab&gt;<br>   Calls fs_mgr_mount_all on the given fs_mgr-format fstab.</p>
<p>mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt; ]* [&lt;options&gt;]<br>   Attempt to mount the named device at the directory &lt;dir&gt;<br>   &lt;device&gt; may be of the form mtd@name to specify a mtd block<br>   device by name.<br>   &lt;flag&gt;s include “ro”, “rw”, “remount”, “noatime”, …<br>   &lt;options&gt; include “barrier=1”, “noauto_da_alloc”, “discard”, … as<br>   a comma separated string, eg: barrier=1,noauto_da_alloc</p>
<p>powerctl<br>   Internal implementation detail used to respond to changes to the<br>   “sys.powerctl” system property, used to implement rebooting.</p>
<p>restart &lt;service&gt;<br>   Like stop, but doesn’t disable the service.</p>
<p>restorecon &lt;path&gt; [ &lt;path&gt; ]*<br>   Restore the file named by &lt;path&gt; to the security context specified<br>   in the file_contexts configuration.<br>   Not required for directories created by the init.rc as these are<br>   automatically labeled correctly by init.</p>
<p>restorecon_recursive &lt;path&gt; [ &lt;path&gt; ]*<br>   Recursively restore the directory tree named by &lt;path&gt; to the<br>   security contexts specified in the file_contexts configuration.</p>
<p>rm &lt;path&gt;<br>   Calls unlink(2) on the given path. You might want to<br>   use “exec – rm …” instead (provided the system partition is<br>   already mounted).</p>
<p>rmdir &lt;path&gt;<br>   Calls rmdir(2) on the given path.</p>
<p>setprop &lt;name&gt; &lt;value&gt;<br>   Set system property &lt;name&gt; to &lt;value&gt;. Properties are expanded<br>   within &lt;value&gt;.</p>
<p>setrlimit &lt;resource&gt; &lt;cur&gt; &lt;max&gt;<br>   Set the rlimit for a resource.</p>
<p>start &lt;service&gt;<br>   Start a service running if it is not already running.</p>
<p>stop &lt;service&gt;<br>   Stop a service from running if it is currently running.</p>
<p>swapon_all &lt;fstab&gt;<br>   Calls fs_mgr_swapon_all on the given fstab file.</p>
<p>symlink &lt;target&gt; &lt;path&gt;<br>   Create a symbolic link at &lt;path&gt; with the value &lt;target&gt;</p>
<p>sysclktz &lt;mins_west_of_gmt&gt;<br>   Set the system clock base (0 if system clock ticks in GMT)</p>
<p>trigger &lt;event&gt;<br>   Trigger an event.  Used to queue an action from another<br>   action.</p>
<p>verity_load_state<br>   Internal implementation detail used to load dm-verity state.</p>
<p>verity_update_state &lt;mount_point&gt;<br>   Internal implementation detail used to update dm-verity state and<br>   set the partition.&lt;mount_point&gt;.verified properties used by adb remount<br>   because fs_mgr can’t set them directly itself.</p>
<p>wait &lt;path&gt; [ &lt;timeout&gt; ]<br>   Poll for the existence of the given file and return when found,<br>   or the timeout has been reached. If timeout is not specified it<br>   currently defaults to five seconds.</p>
<p>write &lt;path&gt; &lt;content&gt;<br>   Open the file at &lt;path&gt; and write a string to it with write(2).<br>   If the file does not exist, it will be created. If it does exist,<br>   it will be truncated. Properties are expanded within &lt;content&gt;.</p>
<h2 id="Properties-1"><a href="#Properties-1" class="headerlink" title="Properties"></a>Properties</h2><p>Init updates some system properties to provide some insight into<br>what it’s doing:</p>
<p>init.action<br>   Equal to the name of the action currently being executed or “” if none</p>
<p>init.command<br>   Equal to the command being executed or “” if none.</p>
<p>init.svc.&lt;name&gt;<br>   State of a named service (“stopped”, “running”, “restarting”)</p>
<h2 id="Bootcharting"><a href="#Bootcharting" class="headerlink" title="Bootcharting"></a>Bootcharting</h2><p>This version of init contains code to perform “bootcharting”: generating log<br>files that can be later processed by the tools provided by www.bootchart.org.</p>
<p>On the emulator, use the -bootchart &lt;timeout&gt; option to boot with bootcharting<br>activated for &lt;timeout&gt; seconds.</p>
<p>On a device, create /data/bootchart/start with a command like the following:</p>
<p>  adb shell ‘echo $TIMEOUT &gt; /data/bootchart/start’</p>
<p>Where the value of $TIMEOUT corresponds to the desired bootcharted period in<br>seconds. Bootcharting will stop after that many seconds have elapsed.<br>You can also stop the bootcharting at any moment by doing the following:</p>
<p>  adb shell ‘echo 1 &gt; /data/bootchart/stop’</p>
<p>Note that /data/bootchart/stop is deleted automatically by init at the end of<br>the bootcharting. This is not the case with /data/bootchart/start, so don’t<br>forget to delete it when you’re done collecting data.</p>
<p>The log files are written to /data/bootchart/. A script is provided to<br>retrieve them and create a bootchart.tgz file that can be used with the<br>bootchart command-line utility:</p>
<p>  sudo apt-get install pybootchartgui<br>  <code># grab-bootchart.sh uses $ANDROID_SERIAL.</code><br>  $ANDROID_BUILD_TOP/system/core/init/grab-bootchart.sh</p>
<p>One thing to watch for is that the bootchart will show init as if it started<br>running at 0s. You’ll have to look at dmesg to work out when the kernel<br>actually started init.</p>
<h2 id="Debugging-init"><a href="#Debugging-init" class="headerlink" title="Debugging init"></a>Debugging init</h2><p>By default, programs executed by init will drop stdout and stderr into<br>/dev/null. To help with debugging, you can execute your program via the<br>Android program logwrapper. This will redirect stdout/stderr into the<br>Android logging system (accessed via logcat).</p>
<p>For example<br>service akmd /system/bin/logwrapper /sbin/akmd</p>
<p>For quicker turnaround when working on init itself, use:</p>
<p>  mm -j<br>  m ramdisk-nodeps<br>  m bootimage-nodeps<br>  adb reboot bootloader<br>  fastboot boot $ANDROID_PRODUCT_OUT/boot.img</p>
<p>Alternatively, use the emulator:</p>
<p>  emulator -partition-size 1024 -verbose -show-kernel -no-window</p>
<p>You might want to call klog_set_level(6) after the klog_init() call<br>so you see the kernel logging in dmesg (or the emulator output).</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之Recovery]]></title>
      <url>http://robinheztto.com/2016/01/25/android-recovery/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android Recovery模式主要用于系统升级，恢复出厂设置等操作。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之LK]]></title>
      <url>http://robinheztto.com/2016/01/15/android-lk/</url>
      <content type="html"><![CDATA[<blockquote>
<p>LK是Little Kernel的简称，它是一款bootloader程序，类似的bootloader还有以前的U-Boot，vivi。现Qualcomm、MTK都使用LK来作为系统引导程序。</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Bootloader是移动平台/嵌入式系统在开机上电后执行的一段或几段程序。开机上电后，在芯片内部的SRAM控制器作用下默认跳转到某一固定地址执行，该位置所在即BootROM，BootROM在完成CPU Core初始化后将加载bootloader程序执行。一般bootloader都分成几个文件，分阶段引导。BootROM加载bootloader第一阶段BL1到On-chip SRAM执行，BL1在完成SOC初步的初始化后将引导BL2到SDRAM执行。以MTK平台为例，启动加载顺序依次为BootROM-&gt;preloader-&gt;LK。</p>
<p>LK的代码一般在源码bootable/bootloader/lk目录下，目录结构如下：<br>├── app 　　　　LK上的应用，aboot，shell等<br>├── arch　　　　体系/架构相关，arm，x86<br>├── dev 　　　　设备相关，key，usb，pmic等<br>├── include　　　头文件<br>├── kernel　　　LK核心，thread，timer等<br>├── lib　　　　　C库<br>├── LICENSE<br>├── make　　　　编译mk文件<br>├── makefile<br>├── platform　　驱动相关<br>├── project　　　makefile文件<br>├── scripts　　　Jtag脚本<br>└── target　　　具体板子相关</p>
<p>LK的工作是引导系统启动，它主要完成以下工作：</p>
<ul>
<li>硬件初始化，设置中断向量表(vector table)，初始化MMU，cache，peripherals，storage，USB，crypto等</li>
<li>加载boot.img(inux Kernel与ramdisk)，引导系统启动</li>
<li>支持fastboot/recovery模式</li>
</ul>
<h1 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h1><blockquote>
<p>在64-bit体系结构下，LK也时运行在32-bit模式，通过TrustZone安全模式跳转到64-bit kernel执行。</p>
</blockquote>
<p>链接脚本arch/arm/system-onesegment.ld中定义了入口地址<code>ENTRY(_start)</code><br>LK将从_start开始执行，_start在/arch/arm/crt0.S中定义。<br>1.crt0.S CPU相关初始化<br>首先初始化异常向量表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">	b	reset</span><br><span class="line">	b	arm_undefined</span><br><span class="line">	b	arm_syscall</span><br><span class="line">	b	arm_prefetch_abort</span><br><span class="line">	b	arm_data_abort</span><br><span class="line">	b	arm_reserved</span><br><span class="line">	b	arm_irq</span><br><span class="line">	b	arm_fiq</span><br></pre></td></tr></table></figure></p>
<p>接下来执行Set Up CPU操作，调用__cpu_early_init()进行CPU相关初始化。<br>初始化各模式stack<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.Lstack_setup:</span><br><span class="line">	/* set up the stack for irq, fiq, abort, undefined, system/user, and lastly supervisor mode */</span><br><span class="line">	mrs     r0, cpsr</span><br><span class="line">	bic     r0, r0, #0x1f</span><br><span class="line"></span><br><span class="line">	ldr		r2, =abort_stack_top</span><br><span class="line">	orr     r1, r0, #0x12 // irq</span><br><span class="line">	msr     cpsr_c, r1</span><br><span class="line">	ldr		r13, =irq_save_spot		/* save a pointer to a temporary dumping spot used during irq delivery */</span><br><span class="line"></span><br><span class="line">	orr     r1, r0, #0x11 // fiq</span><br><span class="line">	msr     cpsr_c, r1</span><br><span class="line">	mov		sp, r2</span><br><span class="line"></span><br><span class="line">	orr     r1, r0, #0x17 // abort</span><br><span class="line">	msr     cpsr_c, r1</span><br><span class="line">	mov		sp, r2</span><br><span class="line"></span><br><span class="line">	orr     r1, r0, #0x1b // undefined</span><br><span class="line">	msr     cpsr_c, r1</span><br><span class="line">	mov		sp, r2</span><br><span class="line"></span><br><span class="line">	orr     r1, r0, #0x1f // system</span><br><span class="line">	msr     cpsr_c, r1</span><br><span class="line">	mov		sp, r2</span><br><span class="line"></span><br><span class="line">	orr		r1, r0, #0x13 // supervisor</span><br><span class="line">	msr		cpsr_c, r1</span><br><span class="line">	mov		sp, r2</span><br></pre></td></tr></table></figure></p>
<p>最后跳入C函数kmain()中执行<br><code>bl        kmain</code></p>
<p>2.kmain()初始化流程<br>kmain()在kernel/main.c的中定义，执行流程如下：</p>
<p><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/lk_call_flow.png?raw=true" alt="LK Call Flow"><br></div></p>
<ul>
<li>thread_init_early();初始化线程相关结构</li>
<li>arch_early_init();disable cache，设置中断向量表基址，初始化MMU，enable cache</li>
<li>platform_early_init();interrupt contr，timer block初始化</li>
<li>target_early_init();Uart等初始化</li>
</ul>
<p>完成上述初始化操作后，新建线程并在新线程中执行bootstrap2<br><code>thread_resume(thread_create(&quot;bootstrap2&quot;, &amp;bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE));</code><br>bootstrap2()分别调用arch_init();platform_init();target_init();进一步对硬件平台初始化。最后将调用apps_init()启动LK上的app。</p>
<p>3.apps_init()<br>apps_init的实现如下，首先遍历<strong>__apps_start</strong>到<strong>__apps_end</strong>位置的app_descriptor，并调用其init函数，然后在新线程中start app。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct</span> app_descriptor __apps_start;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">struct</span> app_descriptor __apps_end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_app</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> app_descriptor *app)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* one time setup */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apps_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> app_descriptor *app;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call all the init routines */</span></span><br><span class="line">	<span class="keyword">for</span> (app = &amp;__apps_start; app != &amp;__apps_end; app++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (app-&gt;init)</span><br><span class="line">			app-&gt;init(app);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start any that want to start on boot */</span></span><br><span class="line">	<span class="keyword">for</span> (app = &amp;__apps_start; app != &amp;__apps_end; app++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (app-&gt;entry &amp;&amp; (app-&gt;flags &amp; APP_FLAG_DONT_START_ON_BOOT) == <span class="number">0</span>) &#123;</span><br><span class="line">			start_app(app);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">app_thread_entry</span><span class="params">(<span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> app_descriptor *app = (<span class="keyword">const</span> <span class="keyword">struct</span> app_descriptor *)arg;</span><br><span class="line"></span><br><span class="line">	app-&gt;entry(app, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_app</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> app_descriptor *app)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">thread_t</span> *thr;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"starting app %s\n"</span>, app-&gt;name);</span><br><span class="line"></span><br><span class="line">	thr = thread_create(app-&gt;name, &amp;app_thread_entry, (<span class="keyword">void</span> *)app, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);</span><br><span class="line">	<span class="keyword">if</span>(!thr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	thread_resume(thr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>__apps_start</strong>与<strong>__apps_end</strong>在链接脚本arch/arm/system-onesegment.ld中定义，<strong>__apps_start</strong>与<strong>__apps_end</strong>与中间存放的是apps section。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.rodata : &#123;</span><br><span class="line">	*(.rodata .rodata.* .gnu.linkonce.r.*)</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	__commands_start = .;</span><br><span class="line">	KEEP (*(.commands))</span><br><span class="line">	__commands_end = .;</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	__apps_start = .;</span><br><span class="line">	KEEP (*(.apps))</span><br><span class="line">	__apps_end = .;</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	__rodata_end = . ;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的LK app都需定义app_descriptor结构体存放到apps段，app_descriptor在include/app.h中定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* each app needs to define one of these to define its startup conditions */</span><br><span class="line">struct app_descriptor &#123;</span><br><span class="line">	const char *name;</span><br><span class="line">	app_init  init;</span><br><span class="line">	app_entry entry;</span><br><span class="line">	unsigned int flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define APP_START(appname) struct app_descriptor _app_##appname __SECTION(&quot;.apps&quot;) = &#123; .name = #appname,</span><br><span class="line">#define APP_END &#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过宏<strong>APP_START</strong>与<strong>APP_END</strong>定义app_descriptor结构体并放到apps sections中，例如在aboot.c的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">APP_START(aboot)</span><br><span class="line">	.init = aboot_init,</span><br><span class="line">APP_END</span><br></pre></td></tr></table></figure></p>
<p>即定义了aboot的app_descriptor结构体并存放在apps section中，在apps_init中将调用到aboot_init()<br>至此，初始化流程结束。</p>
<h1 id="系统引导流程"><a href="#系统引导流程" class="headerlink" title="系统引导流程"></a>系统引导流程</h1><p>aboot的主要目的是进行系统引导，根据reboot_mode来决定进入Main System或Recovery或fastboot模式等。</p>
<p><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/lk_modes.jpg?raw=true" alt="lk mode"><br></div><br>下面从aboot_init()来分析整个流程：<br>1.首先设置EMMC/NAND读取page大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (target_is_emmc_boot())</span><br><span class="line">&#123;</span><br><span class="line">	page_size = mmc_page_size();</span><br><span class="line">	page_mask = page_size - 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	page_size = flash_page_size();</span><br><span class="line">	page_mask = page_size - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.选择开机模式<br>通过keys_get_state()与check_reboot_mode()确定开机模式。<br>keys_get_state()会检测按键，并根据按键的定义确定进入对应的模式。<br>check_reboot_mode()会读取指定memory位置信息，该位置信息由kernel shutdown时写入，例如执行<code>adb reboot recovery</code>，<code>adb reboot bootloader</code>，check_reboot_mode()获取的分别是<code>RECOVERY_MODE</code>，<code>FASTBOOT_MODE</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">reboot_mode = check_reboot_mode();</span><br><span class="line"><span class="keyword">if</span> (reboot_mode == RECOVERY_MODE)</span><br><span class="line">&#123;</span><br><span class="line">	boot_into_recovery = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(reboot_mode == FASTBOOT_MODE)</span><br><span class="line">&#123;</span><br><span class="line">	boot_into_fastboot = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(reboot_mode == ALARM_BOOT)</span><br><span class="line">&#123;</span><br><span class="line">	boot_reason_alarm = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果reboot_mode不是<code>FASTBOOT_MODE</code>，将调用boot_linux_from_mmc()进入系统引导流程<br>如果reboot_mode等于<code>FASTBOOT_MODE</code>，将执行fastboot_init()进入fastboot模式<br>3.boot_linux_from_mmc()<br>boot_linux_from_mmc()解析boot.img/recovery.img的头部boot_img_hdr结构来获取启动加载信息(如果是recovery模式,将从recovery分区加载recovery.img),其中cmdline对应传递给内核的参数,tags_addr对应device tree table,boot_img_hdr结构体在app/aboot/bootimg.h中定义,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#define BOOT_MAGIC &quot;ANDROID!&quot;</span><br><span class="line">#define BOOT_MAGIC_SIZE 8</span><br><span class="line">#define BOOT_NAME_SIZE  16</span><br><span class="line">#define BOOT_ARGS_SIZE  512</span><br><span class="line">#define BOOT_IMG_MAX_PAGE_SIZE 4096</span><br><span class="line"></span><br><span class="line">struct boot_img_hdr</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char magic[BOOT_MAGIC_SIZE];</span><br><span class="line"></span><br><span class="line">    unsigned kernel_size;  /* size in bytes */</span><br><span class="line">    unsigned kernel_addr;  /* physical load addr */</span><br><span class="line"></span><br><span class="line">    unsigned ramdisk_size; /* size in bytes */</span><br><span class="line">    unsigned ramdisk_addr; /* physical load addr */</span><br><span class="line"></span><br><span class="line">    unsigned second_size;  /* size in bytes */</span><br><span class="line">    unsigned second_addr;  /* physical load addr */</span><br><span class="line"></span><br><span class="line">    unsigned tags_addr;    /* physical addr for kernel tags */</span><br><span class="line">    unsigned page_size;    /* flash page size we assume */</span><br><span class="line">    unsigned dt_size;      /* device_tree in bytes */</span><br><span class="line">    unsigned unused;    /* future expansion: should be 0 */</span><br><span class="line"></span><br><span class="line">    unsigned char name[BOOT_NAME_SIZE]; /* asciiz product name */</span><br><span class="line"></span><br><span class="line">    unsigned char cmdline[BOOT_ARGS_SIZE];</span><br><span class="line"></span><br><span class="line">    unsigned id[8]; /* timestamp / checksum / sha1 / etc */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下图是本机编译生成的boot.img示例：</p>
<p><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/bootimg.png?raw=true" alt="boot_img_hdr"><br></div><br>根据boot_img_hdr结构的定义可以从上图获取到以下信息：<br><strong>kernel_size:</strong> 0x009fc707<br><strong>kernel_addr:</strong> 0x80008000<br><strong>ramdisk_size:</strong> 0x001ddfb9<br><strong>ramdisk_addr:</strong> 0x81000000<br><strong>second_size:</strong> 0x00000000<br><strong>second_addr:</strong> 0x80f00000<br><strong>tags_addr:</strong> 0x80000100<br><strong>page_size:</strong> 0x00000100<br><strong>cmdline:</strong><br>console=ttyHSL0,115200,n8 androidboot.console=ttyHSL0 androidboot.hardware=qcom user_debug=31 msm_rtb.filter=0x237 ehci-hcd.park=3 lpm_levels.sleep_disabled=1 cma=32M@0-0xffffffff androidboot.selinux=permissive</p>
<p>在解析完boot_img_hdr后，boot_img_hdr的信息被传递给boot_linux执行具体的加载启动工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">boot_linux((void *)hdr-&gt;kernel_addr, (void *)hdr-&gt;tags_addr,</span><br><span class="line">		 (const char *)hdr-&gt;cmdline, board_machtype(),</span><br><span class="line">		 (void *)hdr-&gt;ramdisk_addr, hdr-&gt;ramdisk_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> typedef void entry_func_ptr(unsigned, unsigned, unsigned*);</span><br><span class="line"> void boot_linux(void *kernel, unsigned *tags,</span><br><span class="line"> 		const char *cmdline, unsigned machtype,</span><br><span class="line"> 		void *ramdisk, unsigned ramdisk_size)</span><br><span class="line"> &#123;</span><br><span class="line"> 	unsigned char *final_cmdline;</span><br><span class="line"> #if DEVICE_TREE</span><br><span class="line"> 	int ret = 0;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> 	void (*entry)(unsigned, unsigned, unsigned*) = (entry_func_ptr*)(PA((addr_t)kernel));</span><br><span class="line"> 	uint32_t tags_phys = PA((addr_t)tags);</span><br><span class="line"> 	struct kernel64_hdr *kptr = (struct kernel64_hdr*)kernel;</span><br><span class="line"></span><br><span class="line"> 	ramdisk = (void *)PA((addr_t)ramdisk);</span><br><span class="line"></span><br><span class="line"> 	final_cmdline = update_cmdline((const char*)cmdline);</span><br><span class="line"></span><br><span class="line"> #if DEVICE_TREE</span><br><span class="line"> 	dprintf(INFO, &quot;Updating device tree: start\n&quot;);</span><br><span class="line"></span><br><span class="line"> 	/* Update the Device Tree */</span><br><span class="line"> 	ret = update_device_tree((void *)tags,(const char *)final_cmdline, ramdisk, ramdisk_size);</span><br><span class="line"> 	if(ret)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		dprintf(CRITICAL, &quot;ERROR: Updating Device Tree Failed \n&quot;);</span><br><span class="line"> 		ASSERT(0);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	dprintf(INFO, &quot;Updating device tree: done\n&quot;);</span><br><span class="line"> #else</span><br><span class="line"> 	/* Generating the Atags */</span><br><span class="line"> 	generate_atags(tags, final_cmdline, ramdisk, ramdisk_size);</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> 	free(final_cmdline);</span><br><span class="line"></span><br><span class="line"> #if VERIFIED_BOOT</span><br><span class="line"> 	/* Write protect the device info */</span><br><span class="line"> 	if (!boot_into_recovery &amp;&amp; target_build_variant_user() &amp;&amp; devinfo_present &amp;&amp; mmc_write_protect(&quot;devinfo&quot;, 1))</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		dprintf(INFO, &quot;Failed to write protect dev info\n&quot;);</span><br><span class="line"> 		ASSERT(0);</span><br><span class="line"> 	&#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> 	/* Turn off splash screen if enabled */</span><br><span class="line"> #if DISPLAY_SPLASH_SCREEN</span><br><span class="line"> 	target_display_shutdown();</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> 	/* Perform target specific cleanup */</span><br><span class="line"> 	target_uninit();</span><br><span class="line"></span><br><span class="line"> 	dprintf(INFO, &quot;booting linux @ %p, ramdisk @ %p (%d), tags/device tree @ %p\n&quot;,</span><br><span class="line"> 		entry, ramdisk, ramdisk_size, (void *)tags_phys);</span><br><span class="line"></span><br><span class="line"> 	enter_critical_section();</span><br><span class="line"></span><br><span class="line"> 	/* Initialise wdog to catch early kernel crashes */</span><br><span class="line"> #if WDOG_SUPPORT</span><br><span class="line"> 	msm_wdog_init();</span><br><span class="line"> #endif</span><br><span class="line"> 	/* do any platform specific cleanup before kernel entry */</span><br><span class="line"> 	platform_uninit();</span><br><span class="line"></span><br><span class="line"> 	arch_disable_cache(UCACHE);</span><br><span class="line"></span><br><span class="line"> #if ARM_WITH_MMU</span><br><span class="line"> 	arch_disable_mmu();</span><br><span class="line"> #endif</span><br><span class="line"> 	bs_set_timestamp(BS_KERNEL_ENTRY);</span><br><span class="line"></span><br><span class="line"> 	if (IS_ARM64(kptr))</span><br><span class="line"> 		/* Jump to a 64bit kernel */</span><br><span class="line"> 		scm_elexec_call((paddr_t)kernel, tags_phys);</span><br><span class="line"> 	else</span><br><span class="line"> 		/* Jump to a 32bit kernel */</span><br><span class="line"> 		entry(0, machtype, (unsigned*)tags_phys);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，LK引导过程完成，将进入系统启动过程。</p>
<h1 id="LK-fastboot模式"><a href="#LK-fastboot模式" class="headerlink" title="LK fastboot模式"></a>LK fastboot模式</h1><p>当LK通过检测按键或reboot_mode是<code>FASTBOOT_MODE</code>时，将进入到fastboot模式。<br>1.注册fastboot Command<br>通过aboot_fastboot_register_commands()注册fastboot支持的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">void aboot_fastboot_register_commands(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	char hw_platform_buf[MAX_RSP_SIZE];</span><br><span class="line"></span><br><span class="line">	struct fastboot_cmd_desc cmd_list[] = &#123;</span><br><span class="line">						/* By default the enabled list is empty. */</span><br><span class="line">						&#123;&quot;&quot;, NULL&#125;,</span><br><span class="line">						/* move commands enclosed within the below ifndef to here</span><br><span class="line">						 * if they need to be enabled in user build.</span><br><span class="line">						 */</span><br><span class="line">#ifndef DISABLE_FASTBOOT_CMDS</span><br><span class="line">						/* Register the following commands only for non-user builds */</span><br><span class="line">						&#123;&quot;flash:&quot;, cmd_flash&#125;,</span><br><span class="line">						&#123;&quot;erase:&quot;, cmd_erase&#125;,</span><br><span class="line">						&#123;&quot;boot&quot;, cmd_boot&#125;,</span><br><span class="line">						&#123;&quot;continue&quot;, cmd_continue&#125;,</span><br><span class="line">						&#123;&quot;reboot&quot;, cmd_reboot&#125;,</span><br><span class="line">						&#123;&quot;reboot-bootloader&quot;, cmd_reboot_bootloader&#125;,</span><br><span class="line">						&#123;&quot;oem unlock&quot;, cmd_oem_unlock&#125;,</span><br><span class="line">						&#123;&quot;oem unlock-go&quot;, cmd_oem_unlock_go&#125;,</span><br><span class="line">						&#123;&quot;oem lock&quot;, cmd_oem_lock&#125;,</span><br><span class="line">						&#123;&quot;flashing unlock&quot;, cmd_oem_unlock&#125;,</span><br><span class="line">						&#123;&quot;flashing lock&quot;, cmd_oem_lock&#125;,</span><br><span class="line">						&#123;&quot;flashing lock_critical&quot;, cmd_flashing_lock_critical&#125;,</span><br><span class="line">						&#123;&quot;flashing unlock_critical&quot;, cmd_flashing_unlock_critical&#125;,</span><br><span class="line">						&#123;&quot;flashing get_unlock_ability&quot;, cmd_flashing_get_unlock_ability&#125;,</span><br><span class="line">						&#123;&quot;oem device-info&quot;, cmd_oem_devinfo&#125;,</span><br><span class="line">						&#123;&quot;preflash&quot;, cmd_preflash&#125;,</span><br><span class="line">						&#123;&quot;oem enable-charger-screen&quot;, cmd_oem_enable_charger_screen&#125;,</span><br><span class="line">						&#123;&quot;oem disable-charger-screen&quot;, cmd_oem_disable_charger_screen&#125;,</span><br><span class="line">						&#123;&quot;oem off-mode-charge&quot;, cmd_oem_off_mode_charger&#125;,</span><br><span class="line">						&#123;&quot;oem select-display-panel&quot;, cmd_oem_select_display_panel&#125;,</span><br><span class="line">#if UNITTEST_FW_SUPPORT</span><br><span class="line">						&#123;&quot;oem run-tests&quot;, cmd_oem_runtests&#125;,</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">						&#125;;</span><br><span class="line"></span><br><span class="line">	int fastboot_cmds_count = sizeof(cmd_list)/sizeof(cmd_list[0]);</span><br><span class="line">	for (i = 1; i &lt; fastboot_cmds_count; i++)</span><br><span class="line">		fastboot_register(cmd_list[i].name,cmd_list[i].cb);</span><br><span class="line"></span><br><span class="line">	/* publish variables and their values */</span><br><span class="line">	fastboot_publish(&quot;product&quot;,  TARGET(BOARD));</span><br><span class="line">	fastboot_publish(&quot;kernel&quot;,   &quot;lk&quot;);</span><br><span class="line">	fastboot_publish(&quot;serialno&quot;, sn_buf);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * partition info is supported only for emmc partitions</span><br><span class="line">	 * Calling this for NAND prints some error messages which</span><br><span class="line">	 * is harmless but misleading. Avoid calling this for NAND</span><br><span class="line">	 * devices.</span><br><span class="line">	 */</span><br><span class="line">	if (target_is_emmc_boot())</span><br><span class="line">		publish_getvar_partition_info(part_info, ARRAY_SIZE(part_info));</span><br><span class="line"></span><br><span class="line">	/* Max download size supported */</span><br><span class="line">	snprintf(max_download_size, MAX_RSP_SIZE, &quot;\t0x%x&quot;,</span><br><span class="line">			target_get_max_flash_size());</span><br><span class="line">	fastboot_publish(&quot;max-download-size&quot;, (const char *) max_download_size);</span><br><span class="line">	/* Is the charger screen check enabled */</span><br><span class="line">	snprintf(charger_screen_enabled, MAX_RSP_SIZE, &quot;%d&quot;,</span><br><span class="line">			device.charger_screen_enabled);</span><br><span class="line">	fastboot_publish(&quot;charger-screen-enabled&quot;,</span><br><span class="line">			(const char *) charger_screen_enabled);</span><br><span class="line">	fastboot_publish(&quot;off-mode-charge&quot;, (const char *) charger_screen_enabled);</span><br><span class="line">	snprintf(panel_display_mode, MAX_RSP_SIZE, &quot;%s&quot;,</span><br><span class="line">			device.display_panel);</span><br><span class="line">	fastboot_publish(&quot;display-panel&quot;,</span><br><span class="line">			(const char *) panel_display_mode);</span><br><span class="line">	fastboot_publish(&quot;version-bootloader&quot;, (const char *) device.bootloader_version);</span><br><span class="line">	fastboot_publish(&quot;version-baseband&quot;, (const char *) device.radio_version);</span><br><span class="line">	fastboot_publish(&quot;secure&quot;, is_secure_boot_enable()? &quot;yes&quot;:&quot;no&quot;);</span><br><span class="line">	smem_get_hw_platform_name((unsigned char *) hw_platform_buf, sizeof(hw_platform_buf));</span><br><span class="line">	snprintf(get_variant, MAX_RSP_SIZE, &quot;%s %s&quot;, hw_platform_buf,</span><br><span class="line">		target_is_emmc_boot()? &quot;eMMC&quot;:&quot;UFS&quot;);</span><br><span class="line">	fastboot_publish(&quot;variant&quot;, (const char *) get_variant);</span><br><span class="line">#if CHECK_BAT_VOLTAGE</span><br><span class="line">	update_battery_status();</span><br><span class="line">	fastboot_publish(&quot;battery-voltage&quot;, (const char *) battery_voltage);</span><br><span class="line">	fastboot_publish(&quot;battery-soc-ok&quot;, (const char *) battery_soc_ok);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中主要是通过fastboot_register注册Command到cmdlist，通过fastboot_publish注册variables到varlist。<br>它们的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static struct fastboot_cmd *cmdlist;</span><br><span class="line"></span><br><span class="line">void fastboot_register(const char *prefix,</span><br><span class="line">		       void (*handle)(const char *arg, void *data, unsigned sz))</span><br><span class="line">&#123;</span><br><span class="line">	struct fastboot_cmd *cmd;</span><br><span class="line">	cmd = malloc(sizeof(*cmd));</span><br><span class="line">	if (cmd) &#123;</span><br><span class="line">		cmd-&gt;prefix = prefix;</span><br><span class="line">		cmd-&gt;prefix_len = strlen(prefix);</span><br><span class="line">		cmd-&gt;handle = handle;</span><br><span class="line">		cmd-&gt;next = cmdlist;</span><br><span class="line">		cmdlist = cmd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct fastboot_var *varlist;</span><br><span class="line"></span><br><span class="line">void fastboot_publish(const char *name, const char *value)</span><br><span class="line">&#123;</span><br><span class="line">	struct fastboot_var *var;</span><br><span class="line">	var = malloc(sizeof(*var));</span><br><span class="line">	if (var) &#123;</span><br><span class="line">		var-&gt;name = name;</span><br><span class="line">		var-&gt;value = value;</span><br><span class="line">		var-&gt;next = varlist;</span><br><span class="line">		varlist = var;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行adb reboot bootloader进入fastboot模式后，可以在PC端的fastboot可执行文件(Fastboot客户端源码在system/core/fastboot下，通过系统源码编译后的科执行文件位于./out/host/linux-x86/bin/fastboot目录下)与目标按fastboot协议交互。<br>通过fastboot_register注册到cmdlist的命令，都可以在pc端通过fastboot执行，常用的命令有：<br><strong><code>fastboot  devices</code></strong> 查看连接设备<br><strong><code>fastboot  update &lt;filename&gt;</code></strong> 更新update.zip包<br><strong><code>fastboot  flashall</code></strong> flash boot, system, vendor, and recovery<br><strong><code>fastboot  flash &lt;partition&gt; [ &lt;filename&gt; ]</code></strong> flash指定分区<br><strong><code>fastboot  erase &lt;partition&gt;</code></strong> erase执行分区<br><strong><code>fastboot  continue</code></strong> 继续启动<br><strong><code>fastboot  reboot bootloader</code></strong> reboot到bootloader<br><strong><code>fastboot  oem unlock</code></strong> oem解锁</p>
<p>通过fastboot_publish publish到varlist的value可以通过<code>fastboot getvar &lt;variable&gt;</code>获取，例如<br><strong><code>fastboot getvar version</code></strong><br><strong><code>fastboot getvar product</code></strong></p>
<p>2.启动fastboot<br>通过<code>fastboot_init(target_get_scratch_address(), target_get_max_flash_size());</code>初始化并启动fastboot。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">int fastboot_init(void *base, unsigned size)</span><br><span class="line">&#123;</span><br><span class="line">	char sn_buf[13];</span><br><span class="line">	thread_t *thr;</span><br><span class="line">	dprintf(INFO, &quot;fastboot_init()\n&quot;);</span><br><span class="line"></span><br><span class="line">	download_base = base;</span><br><span class="line">	download_max = size;</span><br><span class="line"></span><br><span class="line">	/* target specific initialization before going into fastboot. */</span><br><span class="line">	target_fastboot_init();</span><br><span class="line"></span><br><span class="line">	/* setup serialno */</span><br><span class="line">	target_serialno((unsigned char *) sn_buf);</span><br><span class="line">	dprintf(SPEW,&quot;serial number: %s\n&quot;,sn_buf);</span><br><span class="line">	surf_udc_device.serialno = sn_buf;</span><br><span class="line"></span><br><span class="line">	if(!strcmp(target_usb_controller(), &quot;dwc&quot;))</span><br><span class="line">	&#123;</span><br><span class="line">#ifdef USB30_SUPPORT</span><br><span class="line">		surf_udc_device.t_usb_if = target_usb30_init();</span><br><span class="line"></span><br><span class="line">		/* initialize udc functions to use dwc controller */</span><br><span class="line">		usb_if.udc_init            = usb30_udc_init;</span><br><span class="line">		usb_if.udc_register_gadget = usb30_udc_register_gadget;</span><br><span class="line">		usb_if.udc_start           = usb30_udc_start;</span><br><span class="line">		usb_if.udc_stop            = usb30_udc_stop;</span><br><span class="line"></span><br><span class="line">		usb_if.udc_endpoint_alloc  = usb30_udc_endpoint_alloc;</span><br><span class="line">		usb_if.udc_request_alloc   = usb30_udc_request_alloc;</span><br><span class="line">		usb_if.udc_request_free    = usb30_udc_request_free;</span><br><span class="line"></span><br><span class="line">		usb_if.usb_read            = usb30_usb_read;</span><br><span class="line">		usb_if.usb_write           = usb30_usb_write;</span><br><span class="line">#else</span><br><span class="line">		dprintf(CRITICAL, &quot;USB30 needs to be enabled for this target.\n&quot;);</span><br><span class="line">		ASSERT(0);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		/* initialize udc functions to use the default chipidea controller */</span><br><span class="line">		usb_if.udc_init            = udc_init;</span><br><span class="line">		usb_if.udc_register_gadget = udc_register_gadget;</span><br><span class="line">		usb_if.udc_start           = udc_start;</span><br><span class="line">		usb_if.udc_stop            = udc_stop;</span><br><span class="line"></span><br><span class="line">		usb_if.udc_endpoint_alloc  = udc_endpoint_alloc;</span><br><span class="line">		usb_if.udc_request_alloc   = udc_request_alloc;</span><br><span class="line">		usb_if.udc_request_free    = udc_request_free;</span><br><span class="line"></span><br><span class="line">		usb_if.usb_read            = hsusb_usb_read;</span><br><span class="line">		usb_if.usb_write           = hsusb_usb_write;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* register udc device */</span><br><span class="line">	usb_if.udc_init(&amp;surf_udc_device);</span><br><span class="line"></span><br><span class="line">	event_init(&amp;usb_online, 0, EVENT_FLAG_AUTOUNSIGNAL);</span><br><span class="line">	event_init(&amp;txn_done, 0, EVENT_FLAG_AUTOUNSIGNAL);</span><br><span class="line"></span><br><span class="line">	in = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_IN, 512);</span><br><span class="line">	if (!in)</span><br><span class="line">		goto fail_alloc_in;</span><br><span class="line">	out = usb_if.udc_endpoint_alloc(UDC_TYPE_BULK_OUT, 512);</span><br><span class="line">	if (!out)</span><br><span class="line">		goto fail_alloc_out;</span><br><span class="line"></span><br><span class="line">	fastboot_endpoints[0] = in;</span><br><span class="line">	fastboot_endpoints[1] = out;</span><br><span class="line"></span><br><span class="line">	req = usb_if.udc_request_alloc();</span><br><span class="line">	if (!req)</span><br><span class="line">		goto fail_alloc_req;</span><br><span class="line"></span><br><span class="line">	/* register gadget */</span><br><span class="line">	if (usb_if.udc_register_gadget(&amp;fastboot_gadget))</span><br><span class="line">		goto fail_udc_register;</span><br><span class="line"></span><br><span class="line">	fastboot_register(&quot;getvar:&quot;, cmd_getvar);</span><br><span class="line">	fastboot_register(&quot;download:&quot;, cmd_download);</span><br><span class="line">	fastboot_publish(&quot;version&quot;, &quot;0.5&quot;);</span><br><span class="line"></span><br><span class="line">	thr = thread_create(&quot;fastboot&quot;, fastboot_handler, 0, DEFAULT_PRIORITY, 4096);</span><br><span class="line">	if (!thr)</span><br><span class="line">	&#123;</span><br><span class="line">		goto fail_alloc_in;</span><br><span class="line">	&#125;</span><br><span class="line">	thread_resume(thr);</span><br><span class="line"></span><br><span class="line">	usb_if.udc_start();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">fail_udc_register:</span><br><span class="line">	usb_if.udc_request_free(req);</span><br><span class="line">fail_alloc_req:</span><br><span class="line">	usb_if.udc_endpoint_free(out);</span><br><span class="line">fail_alloc_out:</span><br><span class="line">	usb_if.udc_endpoint_free(in);</span><br><span class="line">fail_alloc_in:</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fastboot_init()主要工作是初始化usb_controller_interface,然后调用usb_if.udc_start()监听usb event,在新建线程等待usb event并调用fastboot_handler处理。fastboot_init后display_fastboot_menu_thread()将会在新线程中被调用,即用来在LCD上显示fastboot菜单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int fastboot_handler(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		event_wait(&amp;usb_online);</span><br><span class="line">		fastboot_command_loop();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fastboot_handler中等待usb事件，通过usb_if.usb_read()读取usb数据，并检索出对应cmdlist里的命令调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">static void fastboot_command_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct fastboot_cmd *cmd;</span><br><span class="line">	int r;</span><br><span class="line">#if CHECK_BAT_VOLTAGE</span><br><span class="line">	boolean is_first_erase_flash = false;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	dprintf(INFO,&quot;fastboot: processing commands\n&quot;);</span><br><span class="line"></span><br><span class="line">	uint8_t *buffer = (uint8_t *)memalign(CACHE_LINE, ROUNDUP(4096, CACHE_LINE));</span><br><span class="line">	if (!buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(CRITICAL, &quot;Could not allocate memory for fastboot buffer\n.&quot;);</span><br><span class="line">		ASSERT(0);</span><br><span class="line">	&#125;</span><br><span class="line">again:</span><br><span class="line">	while (fastboot_state != STATE_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">		/* Read buffer must be cleared first. If buffer is not cleared,</span><br><span class="line">		 * the original data in buf trailing the received command is</span><br><span class="line">		 * interpreted as part of the command.</span><br><span class="line">		 */</span><br><span class="line">		memset(buffer, 0, MAX_RSP_SIZE);</span><br><span class="line">		arch_clean_invalidate_cache_range((addr_t) buffer, MAX_RSP_SIZE);</span><br><span class="line"></span><br><span class="line">		r = usb_if.usb_read(buffer, MAX_RSP_SIZE);</span><br><span class="line">		if (r &lt; 0) break;</span><br><span class="line">		buffer[r] = 0;</span><br><span class="line">		dprintf(INFO,&quot;fastboot: %s\n&quot;, buffer);</span><br><span class="line"></span><br><span class="line">#if CHECK_BAT_VOLTAGE</span><br><span class="line">		/* check battery voltage before erase or flash image */</span><br><span class="line">		if (!strncmp((const char*) buffer, &quot;getvar:partition-type&quot;, 21))</span><br><span class="line">			is_first_erase_flash = true;</span><br><span class="line"></span><br><span class="line">		if (is_first_erase_flash) &#123;</span><br><span class="line">			if (!strncmp((const char*) buffer, &quot;erase&quot;, 5) ||</span><br><span class="line">				!strncmp((const char*) buffer, &quot;flash&quot;, 5)) &#123;</span><br><span class="line">				if (!target_battery_soc_ok()) &#123;</span><br><span class="line">					dprintf(INFO,&quot;fastboot: battery voltage: %d\n&quot;,</span><br><span class="line">						target_get_battery_voltage());</span><br><span class="line">					fastboot_fail(&quot;Warning: battery&apos;s capacity is very low\n&quot;);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">		fastboot_state = STATE_COMMAND;</span><br><span class="line"></span><br><span class="line">		for (cmd = cmdlist; cmd; cmd = cmd-&gt;next) &#123;</span><br><span class="line">			if (memcmp(buffer, cmd-&gt;prefix, cmd-&gt;prefix_len))</span><br><span class="line">				continue;</span><br><span class="line">			cmd-&gt;handle((const char*) buffer + cmd-&gt;prefix_len,</span><br><span class="line">				    (void*) download_base, download_size);</span><br><span class="line">			if (fastboot_state == STATE_COMMAND)</span><br><span class="line">				fastboot_fail(&quot;unknown reason&quot;);</span><br><span class="line"></span><br><span class="line">#if CHECK_BAT_VOLTAGE</span><br><span class="line">			if (!strncmp((const char*) buffer, &quot;erase&quot;, 5) ||</span><br><span class="line">				!strncmp((const char*) buffer, &quot;flash&quot;, 5)) &#123;</span><br><span class="line">				if (is_first_erase_flash) &#123;</span><br><span class="line">					is_first_erase_flash = false;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">#endif</span><br><span class="line">			goto again;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fastboot_fail(&quot;unknown command&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fastboot_state = STATE_OFFLINE;</span><br><span class="line">	dprintf(INFO,&quot;fastboot: oops!\n&quot;);</span><br><span class="line">	free(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Device-tree"><a href="#Device-tree" class="headerlink" title="Device tree"></a>Device tree</h1><p>Device tree是描述设备硬件信息的数据结构，通过.dts源文件定义，一般位于kernel/arch/arm/boot/dts目录下, .dts编译生成.dtb文件后将LK传递给kernel执行设备初始化工作。</p>
<p><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/android/device_tree.png?raw=true" alt="Device Tree"><br></div><br>关于Device Tree参考宋宝华老师的博文 <a href="http://blog.csdn.net/21cnbao/article/details/8457546" target="_blank" rel="external">ARM Linux 3.x的设备树（Device Tree）</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之BootFlow]]></title>
      <url>http://robinheztto.com/2016/01/10/android-bootflow/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Android BootFlow包括Boot引导阶段，Kernel启动阶段，Android核心启动几个阶段。</p>
</blockquote>
<p>Android系统启动的整个流程如下图所示，在开机上电后即进入Boot引导，包括BootROM与Bootloader，在Bootloader加载Kernel，Kernel完成初始化后启动第一个用户进程init，随后init启动Daemon进程，Zygote，Native Service等服务，接着Zygote启动Dalvik/ART，并孵化Android核心进程system_server，system_server中启动各种服务，最后SystemReady并启动Home Application。</p>
<p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/android-boot-process.png?raw=true" alt="Android-Boot-Process"></div></p>
<div>

<h1 id="Boot引导阶段"><a href="#Boot引导阶段" class="headerlink" title="Boot引导阶段"></a>Boot引导阶段</h1><p>Boot引导阶段即开机上电后BootROM与Bootloader的执行阶段，主要完成的工作是硬件的初始化及系统的引导。设备(soc)开机上电或复位后，跳转BootROM执行（soc上电或复位后跳转到原厂预设地址取址，该位置即BootROM），BootROM在初始化DDR后，会将Bootloader(LK) load到DDR，然后跳转到Bootloader(LK)执行，Bootloader将完成soc硬件初始化，并load kernel(boot.img)到DDR中，跳转至Kernel执行。</p>
<h1 id="Kernel启动阶段"><a href="#Kernel启动阶段" class="headerlink" title="Kernel启动阶段"></a>Kernel启动阶段</h1><p>Kernel是Android操作系统内核，负责存储管理、文件管理、设备管理、网络系统管理，调度和进程管理，内存管理等系统基础性功能。<br>在Bootloader加载Kernel后，Kernel先进行自解压，然后初始化(ARM)体系结构，创建栈，初始化c入口环境后跳转到C入口函数startkernel()。startkernel执行系统初始化，解析引导参数，建立内核各个基础子系统环境，如硬件中断/软中断系统、调度系统、时钟和定时器、内存、信号机制、文件系统等。接着进入rest_init执行，创建1号进程，用于构建驱动基础模型，加载驱动，完成后1号进程执行init程序进入用户空间；创建2号进程kthreadd并运行，用于管理内核线程；同时kernel init（startkernel）退化为idle进程（0号进程）。<br>init进程启动过程中会通过解析init.rc文件，启动各种deamon进程及native服务，同时也启动了孵化器Zygote，通过Zygote孵化出Android核心及应用进程。</p>
<h1 id="Android核心启动阶段"><a href="#Android核心启动阶段" class="headerlink" title="Android核心启动阶段"></a>Android核心启动阶段</h1><p><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/android/android-boot.png?raw=true" alt="Android-Boot"></div></p>
<p><div><br>在Zygote启动后紧接着启动Android系统核心system_server，SystemServer中启动大量的系统服务，包括startBootstrapServices();//启动引导服务，如AMS,PMS,DMS,PKMS<br>startCoreServices(); //启动核心服务<br>startOtherServices();//启动一般性服务，一个核心是WMS<br>最后进入主线程的loop循环。</div></p>
</div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android开发工具之tcpdump]]></title>
      <url>http://robinheztto.com/2016/01/05/android-tools-tcpdump/</url>
      <content type="html"><![CDATA[<hr>
<blockquote>
<p>Android开发中，如果需要在Android平台上进行网络数据包的抓取，使用tcpdump是非常方便的。通过tcpdump抓取数据包，pull到本地后可以利用Wireshark非常直观地分析数据包。</p>
</blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol>
<li>Root Android设备</li>
<li>下载安装<a href="https://www.wireshark.org/#download" target="_blank" rel="external">Wireshark</a></li>
<li>下载<a href="http://www.androidtcpdump.com/android-tcpdump/downloads" target="_blank" rel="external">Android tcpdump binary</a>文件</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li><code>adb root</code></li>
<li><code>adb remount</code></li>
<li><code>adb push tcpdump /system/bin</code></li>
<li><code>chmod 6755 /system/bin/tcpdump</code></li>
<li><code>tcpdump -i any -p -s 0 -w /sdcard/capture.pcap</code></li>
<li><code>adb pull /sdcard/capture.pcap</code></li>
<li>Wireshark分析capture.pcap数据包</li>
</ol>
<h1 id="tcpdump参数"><a href="#tcpdump参数" class="headerlink" title="tcpdump参数"></a>tcpdump参数</h1><ol>
<li>-i<br>监视指定网络接口的数据包，可通过tcpdump -D查看可抓包的网卡</li>
<li>-p<br>一般情况下,把网络接口设置为非’混杂’模式.但必须注意,在特殊情况下此网络接口还是会以’混杂’模式来工作；从而,’-p’的设与不设,不能当做以下选现的代名词:’ether host {local-hw-add}’或’ether broadcast’(nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包)．</li>
<li>-s<br>抓取数据包时默认抓取长度为68字节,-S 0指定可以抓到完整的数据包</li>
<li>-w<br>保存成pacp/cap文件，供Wireshark分析</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.androidtcpdump.com/" target="_blank" rel="external">Android tcpdump</a></li>
<li><a href="http://www.tcpdump.org/" target="_blank" rel="external">tcpdump.org</a></li>
<li><a href="https://www.wireshark.org/" target="_blank" rel="external">Wireshark</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android之开发环境搭建]]></title>
      <url>http://robinheztto.com/2016/01/01/android-env/</url>
      <content type="html"><![CDATA[<hr>
<h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><p>Google推荐使用64位Ubuntu操作系统开发Android，针对不同的Android版本，推荐使用相对应的Ubuntu版本。</p>
<ul>
<li>Android 6.0 (Marshmallow) - AOSP master: Ubuntu 14.04 (Trusty)    </li>
<li>Android 2.3.x (Gingerbread) - Android 5.x (Lollipop): Ubuntu 12.04 (Precise)   </li>
<li>Android 1.5 (Cupcake) - Android 2.2.x (Froyo): Ubuntu 10.04 (Lucid)   </li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p><strong> 安装jdk: </strong><br>Android 5.0版本前使用的是Oracle的JDK，5.0及以后的版本使用的是OpenJDK。</p>
<ul>
<li>Android 7.0 (Nougat) - Android 8.0 (O release): Ubuntu - OpenJDK 8</li>
<li>Android 5.x (Lollipop) - Android 6.0 (Marshmallow): OpenJDK 7</li>
<li>Android 2.3.x (Gingerbread) - Android 4.4.x (KitKat):Java JDK 6</li>
<li>Android 1.5 (Cupcake) - Android 2.2.x (Froyo): Java JDK 5   </li>
</ul>
<p>OpenJdk8安装：</p>
<ul>
<li><p>Ubuntu15.04及以上版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ubuntu14.04:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于安装的多个版本JDK,可使用以下命令指定   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-alternatives --config java   </span><br><span class="line">$ sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong> 安装编译相关开发包: </strong></p>
<ul>
<li><p>Ubuntu14.04:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git-core gnupg flex bison gperf build-essential \</span><br><span class="line">  zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \</span><br><span class="line">  lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \</span><br><span class="line">  libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ubuntu12.02:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git gnupg flex bison gperf build-essential \</span><br><span class="line">  zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev \</span><br><span class="line">  libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 \</span><br><span class="line">  libgl1-mesa-dev g++-multilib mingw32 tofrodos \</span><br><span class="line">  python-markdown libxml2-utils xsltproc zlib1g-dev:i386</span><br><span class="line">$ sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong> 开发工具安装: </strong>  </p>
<ol>
<li>下载<a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">Android studio</a></li>
<li>安装Android SDK</li>
</ol>
<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p><strong> Android源码下载: </strong>  </p>
<table>
<thead>
<tr>
<th>Code name</th>
<th>Version</th>
<th>API level</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nougat</td>
<td>7.1</td>
<td>API level 25</td>
</tr>
<tr>
<td>Nougat</td>
<td>7.0</td>
<td>API level 24</td>
</tr>
<tr>
<td>Marshmallow</td>
<td>6.0</td>
<td>API level 23</td>
</tr>
<tr>
<td>Lollipop</td>
<td>5.1</td>
<td>API level 22</td>
</tr>
<tr>
<td>Lollipop</td>
<td>5.0</td>
<td>API level 21</td>
</tr>
<tr>
<td>KitKat</td>
<td>4.4 - 4.4.4</td>
<td>API level 19</td>
</tr>
<tr>
<td>Jelly Bean</td>
<td>4.3.x</td>
<td>API level 18</td>
</tr>
<tr>
<td>Jelly Bean</td>
<td>4.2.x</td>
<td>API level 17</td>
</tr>
<tr>
<td>Jelly Bean</td>
<td>4.1.x</td>
<td>API level 16</td>
</tr>
<tr>
<td>Ice Cream Sandwich</td>
<td>4.0.3 - 4.0.4</td>
<td>API level 15, NDK 8</td>
</tr>
<tr>
<td>Ice Cream Sandwich</td>
<td>4.0.1 - 4.0.2</td>
<td>API level 14, NDK 7</td>
</tr>
<tr>
<td>Honeycomb</td>
<td>3.2.x</td>
<td>API level 13</td>
</tr>
<tr>
<td>Honeycomb</td>
<td>3.1</td>
<td>API level 12, NDK 6</td>
</tr>
<tr>
<td>Honeycomb</td>
<td>3.0</td>
<td>API level 11</td>
</tr>
<tr>
<td>Gingerbread</td>
<td>2.3.3 - 2.3.7</td>
<td>API level 10</td>
</tr>
<tr>
<td>Gingerbread</td>
<td>2.3 - 2.3.2</td>
<td>API level 9, NDK 5</td>
</tr>
<tr>
<td>Froyo</td>
<td>2.2.x</td>
<td>API level 8, NDK 4</td>
</tr>
<tr>
<td>Eclair</td>
<td>2.1</td>
<td>API level 7, NDK 3</td>
</tr>
<tr>
<td>Eclair</td>
<td>2.0.1</td>
<td>API level 6</td>
</tr>
<tr>
<td>Eclair</td>
<td>2.0</td>
<td>API level 5</td>
</tr>
<tr>
<td>Donut</td>
<td>1.6</td>
<td>API level 4, NDK 2</td>
</tr>
<tr>
<td>Cupcake</td>
<td>1.5</td>
<td>API level 3, NDK 1</td>
</tr>
<tr>
<td>(no code name)</td>
<td>1.1</td>
<td>API level 2</td>
</tr>
<tr>
<td>(no code name)</td>
<td>1.0</td>
<td>API level 1</td>
</tr>
</tbody>
</table>
<p>安装repo<br>repo是Google开发的一个脚本，在git上进行封装，用来简化git下载Android源码的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/bin    </span><br><span class="line">$ PATH=~/bin:$PATH   </span><br><span class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo   </span><br><span class="line">$ chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p>
<p>repo下载源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">$ mkdir WORKING_DIRECTORY</span><br><span class="line">$ cd WORKING_DIRECTORY</span><br></pre></td></tr></table></figure></p>
<p>默认下载master分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest</span><br></pre></td></tr></table></figure></p>
<p>或者指定分支下载,查看<a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">branch list</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest -b android-7.1.1_r1</span><br></pre></td></tr></table></figure></p>
<p>下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ repo sync -j8</span><br></pre></td></tr></table></figure></p>
<p><strong> Kernel源码下载:   </strong><br>虽然Android源码是通用的，但是每个平台kernel源码都有较大的差异，同时Android源码跟Kernel源码也是分开管理的。kernel源码可以通过以下命令获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://android.googlesource.com/kernel/common.git</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/hikey-linaro</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/x86_64.git</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/exynos.git</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/goldfish.git</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/msm.git</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/omap.git</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/samsung.git</span><br><span class="line">$ git clone https://android.googlesource.com/kernel/tegra.git</span><br></pre></td></tr></table></figure></p>
<p>其中goldfish.git是qemu虚拟机的内核代码库。下面是Google设备型号，kernel位置及源码仓库对应表。 </p>
<table>
<thead>
<tr>
<th>Device</th>
<th>Binarry location</th>
<th>Source location</th>
<th>Build configuration</th>
</tr>
</thead>
<tbody>
<tr>
<td>hikey</td>
<td>device/linaro/hikey-kernel</td>
<td>kernel/hikey-linaro</td>
<td>hikey_defconfig</td>
</tr>
<tr>
<td>angler</td>
<td>device/huawei/angler-kernel</td>
<td>kernel/msm</td>
<td>angler_defconfig</td>
</tr>
<tr>
<td>bullhead</td>
<td>device/lge/bullhead-kernel</td>
<td>kernel/msm</td>
<td>bullhead_defconfig</td>
</tr>
<tr>
<td>shamu</td>
<td>device/moto/shamu-kernel</td>
<td>kernel/msm</td>
<td>shamu_defconfig</td>
</tr>
<tr>
<td>fugu</td>
<td>device/asus/fugu-kernel</td>
<td>kernel/x86_64</td>
<td>fugu_defconfig</td>
</tr>
<tr>
<td>volantis</td>
<td>device/htc/flounder-kernel</td>
<td>kernel/tegra</td>
<td>flounder_defconfig</td>
</tr>
<tr>
<td>hammerhead</td>
<td>device/lge/hammerhead-kernel</td>
<td>kernel/msm</td>
<td>hammerhead_defconfig</td>
</tr>
<tr>
<td>flo</td>
<td>device/asus/flo-kernel/kernel</td>
<td>kernel/msm</td>
<td>flo_defconfig</td>
</tr>
<tr>
<td>deb</td>
<td>device/asus/flo-kernel/kernel</td>
<td>kernel/msm</td>
<td>flo_defconfig</td>
</tr>
<tr>
<td>manta</td>
<td>device/samsung/manta/kernel</td>
<td>kernel/exynos</td>
<td>manta_defconfig</td>
</tr>
<tr>
<td>mako</td>
<td>device/lge/mako-kernel/kernel</td>
<td>kernel/msm</td>
<td>mako_defconfig</td>
</tr>
<tr>
<td>grouper</td>
<td>device/asus/grouper/kernel</td>
<td>kernel/tegra</td>
<td>tegra3_android_defconfig</td>
</tr>
<tr>
<td>tilapia</td>
<td>device/asus/grouper/kernel</td>
<td>kernel/tegra</td>
<td>tegra3_android_defconfig</td>
</tr>
<tr>
<td>maguro</td>
<td>device/samsung/tuna/kernel</td>
<td>kernel/omap</td>
<td>tuna_defconfig</td>
</tr>
<tr>
<td>toro</td>
<td>device/samsung/tuna/kernel</td>
<td>kernel/omap</td>
<td>tuna_defconfig</td>
</tr>
<tr>
<td>panda</td>
<td>device/ti/panda/kernel</td>
<td>kernel/omap</td>
<td>panda_defconfig</td>
</tr>
<tr>
<td>stingray</td>
<td>device/moto/wingray/kernel</td>
<td>kernel/tegra</td>
<td>stingray_defconfig</td>
</tr>
<tr>
<td>wingray</td>
<td>device/moto/wingray/kernel</td>
<td>kernel/tegra</td>
<td>stingray_defconfig</td>
</tr>
<tr>
<td>crespo</td>
<td>device/samsung/crespo/kernel</td>
<td>kernel/samsung</td>
<td>herring_defconfig</td>
</tr>
<tr>
<td>crespo4g</td>
<td>device/samsung/crespo/kernel</td>
<td>kernel/samsung</td>
<td>herring_defconfig</td>
</tr>
</tbody>
</table>
<h1 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h1><ol>
<li><code>$ source build/envsetup.sh</code></li>
<li><code>$ lunch aosp_arm-eng</code></li>
<li><code>$ make -j8 2&gt;&amp;1 | tee build.log</code></li>
</ol>
<p>Android Studio导入源码：<br><code>$ make idegen &amp;&amp; development/tools/idegen/idegen.sh</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://source.android.com/source/index.html" target="_blank" rel="external">The Android Source Code</a></li>
<li><a href="http://www.androiddevtools.cn/" target="_blank" rel="external">AndroidDevTools</a></li>
</ol>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JNI基础]]></title>
      <url>http://robinheztto.com/2015/11/06/jni-basis/</url>
      <content type="html"><![CDATA[<p>$ gcc -shared -fPIC -I /usr/lib/jvm/java-8-openjdk-amd64/include/ -I /usr/lib/jvm/java-8-openjdk-amd64/include/linux hellojni.c -o libHelloJni.so<br>$ java -Djava.library.path=. HelloJni</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu下使用rsync进行数据同步备份]]></title>
      <url>http://robinheztto.com/2015/08/19/ubuntu-rsync/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>rsync是remote sync的简称,它是一款类unix系统下数据同步备份,增量文件快速传输的工具.rsync采用”rsync算法”,不仅能为client和server的提供文件快速同步,并且能够对整个目录树/文件系统进行同步备份.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>默认情况Ubuntu已经安装了rsync服务,如果没有安装也可通过<code>apt-get</code>安装.<br><code>$ sudo apt-get install rsync</code></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完毕后,rsync并没有默认创建rsync的配置文件,但有提供示例配置文件<code>/usr/share/doc/rsync/examples/rsyncd.conf</code>,可以参考示例文件进行配置．<br>rsync需配置以下二个文件：</p>
<ul>
<li>rsyncd.conf　rsync配置</li>
<li>rsyncd.secrets　rsync用户密码</li>
</ul>
<p>设置rsync账号密码<br><code>$ sudo vi /etc/rsyncd.secrets</code><br>按下面格式编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user1:password1</span><br><span class="line">user2:password2</span><br></pre></td></tr></table></figure></p>
<p>然后修改权限<code>$ sudo chmod 600 /etc/rsyncd.secrets</code></p>
<p>拷贝示例配置文件rsyncd.conf到/etc/下,然后再进行相关配置.<br><code>$ sudo cp /usr/share/doc/rsync/examples/rsyncd.conf /etc/</code><br>下面是server端rsyncd.conf的相关配置,分为GLOBAL OPTIONS与MODULE OPTIONS.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># GLOBAL OPTIONS</span><br><span class="line"></span><br><span class="line">pid file=/var/run/rsyncd.pid</span><br><span class="line"></span><br><span class="line">#port = 873</span><br><span class="line">address = 10.129.33.241</span><br><span class="line"></span><br><span class="line">#uid = nobody</span><br><span class="line">#gid = nobody    </span><br><span class="line">uid = root   </span><br><span class="line">gid = root  </span><br><span class="line">use chroot = yes</span><br><span class="line">read only = yes  </span><br><span class="line"></span><br><span class="line">motd file=/etc/motd</span><br><span class="line">log file=/var/log/rsyncd</span><br><span class="line"></span><br><span class="line">max connections=10</span><br><span class="line">timeout = 600</span><br><span class="line"></span><br><span class="line">log format = %t %a %m %f %b</span><br><span class="line"></span><br><span class="line"># MODULE OPTIONS</span><br><span class="line">[backup]</span><br><span class="line">	comment = release backup</span><br><span class="line">	path = /home/ftp/Monster-Release/</span><br><span class="line">	lock file = /var/lock/rsyncd</span><br><span class="line">	list = yes</span><br><span class="line">#	exclude =</span><br><span class="line">#	exclude from =</span><br><span class="line">#	include =</span><br><span class="line">#	include from =</span><br><span class="line">	auth users = rsyncmonster</span><br><span class="line">	secrets file = /etc/rsyncd.secrets</span><br><span class="line">#	strict modes = yes</span><br><span class="line">#	hosts allow =</span><br><span class="line">#	hosts deny =</span><br><span class="line">	ignore errors</span><br><span class="line">	ignore nonreadable = yes</span><br><span class="line">	transfer logging = no</span><br><span class="line">#	log format = %t: host %h (%a) %o %f (%l bytes). Total %b bytes.</span><br><span class="line">	refuse options = checksum dry-run</span><br><span class="line">	dont compress = *.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz</span><br></pre></td></tr></table></figure></p>
<p>全局配置说明:</p>
<ul>
<li>pid file=/var/run/rsyncd.pid 进程pid写入到文件/var/run/rsyncd.pid</li>
<li>address = 10.129.33.241 本机IP地址</li>
<li>port = 873  指定运行端口，默认873</li>
<li>uid = root 执行的用户</li>
<li>gid = root 执行的用户组</li>
<li>motd file=/etc/motd 服务器登陆信息,login时显示</li>
<li>log file=/var/log/rsyncd log文件</li>
<li>max connections=10 最大连接数</li>
<li>timeout = 600 连接超时</li>
<li>log format = %t %a %m %f %b log格式</li>
<li>ignore errors 忽略IO错误</li>
</ul>
<p>模块配置说明:</p>
<ul>
<li>comment = release backup 描述</li>
<li>path = /home/ftp/Monster-Release/ 同步备份目标的路径</li>
<li>list = yes 把rsync服务器上配置显示出来</li>
<li>auth users = user1 取rsyncd.secrets中定义的user</li>
<li>secrets file = /etc/rsyncd.secrets</li>
</ul>
<p>由于是以uid = root运行,使用<code>$ sudo rsync --daemon</code>启动rsync服务</p>
<p>修改conf文件重启rsync步骤:<br><code>$ ps -ef | grep rsync</code>查看rsync进程<br><code>$ sudo kill ${rsyncpid}</code><br><code>$ sudo rsync --daemon</code></p>
<p>server端配置完成后,可在client端进行同步备份操作,同样client也需安装rsync.<br>列出服务端配置的module: <code>rsync --list-only  user@10.129.33.241::</code><br>同步备份: <code>rsync -vzrtopg --progress user@10.129.33.241::backup backupdir</code><br>-v: -verbose，即详细模式输出<br>-z: –compress 即对备份的文件在传输时进行压缩处理<br>-r: –recursive 以递归模式处理<br>-t: –times 保持文件时间信息<br>-o: –owner 保持文件owner信息<br>-p: –perms用来保持文件权限<br>-g: –group用来保持文件group信息</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://rsync.samba.org/" target="_blank" rel="external">http://rsync.samba.org/</a></li>
<li><a href="https://help.ubuntu.com/community/rsync" target="_blank" rel="external">https://help.ubuntu.com/community/rsync</a></li>
<li><a href="http://blog.chinaunix.net/uid-25266990-id-114684.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-25266990-id-114684.html</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 14.04 Nexus Maven私服搭建]]></title>
      <url>http://robinheztto.com/2015/08/03/ubuntu-nexus-maven/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Maven是Apache基于POM(project object model)一个项目管理工具.Maven能够管理项目的构建build,reporting和documentation.</p>
<p>Nexus是一个强大的Maven仓库管理器，它极大地简化了内部仓库的维护和外部仓库的访问，可以在局域网搭建一个maven私服,用来部署第三方公共构件或者作为远程仓库在该局域网的一个代理.</p>
</blockquote>
<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><ol>
<li><p>下载<br>我们使用Nexus OSS开源版开源版进行环境搭建，<a href="http://www.sonatype.com/download-oss-sonatype" target="_blank" rel="external">官网下载</a> All platform的版本<a href="https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.13.0-01-bundle.tar.gz" target="_blank" rel="external">nexus-2.13.0-01-bundle.tar.gz</a></p>
</li>
<li><p>安装<br><code>$ sudo cp nexus-2.13.0-01-bundle.tar.gz /usr/local</code><br><code>$ cd /usr/local</code><br><code>$ sudo tar -zxvf nexus-2.13.0-01-bundle.tar.gz</code><br><code>$ sudo ln -s nexus-2.13.0-01 nexus</code><br><code>$ sudo nexus/bin/nexus</code><br>输出：<code>Usage: nexus/bin/nexus { console | start | stop | restart | status | dump }</code>　即表示安装成功<br><code>$ sudo vim bin/nexus</code> 修改<code>#RUN_AS_USER=</code>为<code>RUN_AS_USER=root</code><br><code>$ sudo bin/nexus start</code>启动nexus<br>浏览器登陆<a href="http://localhost:8081/nexus，默认用户名:admin，密码:admin123" target="_blank" rel="external">http://localhost:8081/nexus，默认用户名:admin，密码:admin123</a><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/ubuntu/nexus-welcome.png?raw=true" alt="nexus welcome"></p>
</li>
<li>设置开机启动：<br><code>$ sudo cp /usr/local/nexus/bin/nexus /etc/init.d/</code><br><code>$ sudo vim /etc/init.d/nexus</code><br>设置<br><code>NEXUS_HOME=&quot;/usr/local/nexus&quot;</code><br><code>RUN_AS_USER=root</code><br><code>PIDDIR=&quot;/var/run&quot;</code></li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol>
<li>Repositories配置</li>
</ol>
<p><a href="http://blog.csdn.net/l2show/article/details/48653949" target="_blank" rel="external">http://blog.csdn.net/l2show/article/details/48653949</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu14.04 FTP服务器搭建]]></title>
      <url>http://robinheztto.com/2015/06/06/ubuntu-ftp/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>vsftpd 是“very secure FTP daemon”的缩写，它是一款在Linux发行版中最受推崇的FTP服务器程序，安全性是它的一个最大的特点.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li>安装： <code>sudo apt-get install vsftpd</code>    </li>
<li>创建FTP账户： <code>sudo useradd -g ftp -s /sbin/nologin -d /home/ftp_directory ftpuser</code></li>
<li>设置账户密码： <code>sudo passwd ftpuser</code>   </li>
<li>重启服务： <code>sudo service vsftpd restart</code></li>
</ol>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol>
<li><p>备份<br>vsftpd的配置文件位于/etc/vsftpd.conf，修改之前先备份配置文件<br><code>sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.bak</code>    </p>
</li>
<li><p>目录限制<br>默认情况下，用户登陆FTP后，是可以切换到根目录以外的主机其他目录，为了加以限制，可做如下配置：<br><code>chroot_list_enable=YES</code><br><code>chroot_list_file=/etc/vsftpd.chroot_list</code><br>然后设置chroot_local_user，有以下二种设置<br>设置<code>chroot_local_user＝YES</code>表示/etc/vsftpd.chroot_list文件中用户不能chroot，其他用户可以<br>设置<code>chroot_local_user=NO</code>表示/etc/vsftpd.chroot_list中用户可以chroot，其他用户不行<br>创建vsftpd.chroot_list，写入需控制chroot的用户<br><code>sudo touch /etc/vsftpd.chroot_list</code>  </p>
</li>
<li><p>写权限<br><code>write_enable=YES</code><br>如果开启了chroot来控制用户路径，则用户不再具有该用户根目录的写的权限<br>需设置<code>allow_writeable_chroot=YES</code>  </p>
</li>
<li><p>530 Login incorrect<br>如果在登陆时返回530 Login incorrect.<br>修改<br><code>pam_service_name=vsftpd</code><br>为<br><code>pam_service_name=ftp</code>  </p>
</li>
<li><p>相关配置参数<br>（1）ftpd_banner=welcome to ftp service ：设置连接服务器后的欢迎信息<br>（2）idle_session_timeout=60 ：限制远程的客户机连接后，所建立的控制连接，在多长时间没有做任何的操作就会中断(秒)<br>（3）data_connection_timeout=120 ：设置客户机在进行数据传输时,设置空闲的数据中断时间<br>（4）accept_timeout=60 设置在多长时间后自动建立连接<br>（5）connect_timeout=60 设置数据连接的最大激活时间，多长时间断开，为别人所使用<br>（6）max_clients=200 指明服务器总的客户并发连接数为200<br>（7）max_per_ip=3 指明每个客户机的最大连接数为3<br>（8）local_max_rate=50000(50kbytes/sec) 本地用户最大传输速率限制<br>（9）anon_max_rate=30000匿名用户的最大传输速率限制<br>（10）pasv_min_port=端口<br>（11）pasv-max-prot=端口号 定义最大与最小端口，为0表示任意端口;为客户端连接指明端口<br>（12）listen_address=IP地址 设置ftp服务来监听的地址，客户端可以用哪个地址来连接<br>（13）listen_port=端口号 设置FTP工作的端口号，默认的为21<br>（14）chroot_local_user=YES 设置所有的本地用户可以chroot<br>（15）chroot_local_user=NO 设置指定用户能够chroot<br>（16）chroot_list_enable=YES<br>（17）chroot_list_file=/etc/vsftpd/chroot_list(只有/etc/vsftpd/chroot_list中的指定的用户才能执行 )<br>（18）local_root=path 无论哪个用户都能登录的用户，定义登录帐号的主目录, 若没有指定，则每一个用户则进入到个人用户主目录<br>（19）chroot_local_user=yes/no 是否锁定本地系统帐号用户主目录(所有);锁定后，用户只能访问用户的主目录/home/user,不能利用cd命令向上转;只能向下<br>（20）chroot_list_enable=yes/no 锁定指定文件中用户的主目录(部分),文件：/chroot_list_file=path 中指定;<br>（21）userlist_enable=YES/NO 是否加载用户列表文件<br>（22）userlist_deny=YES 表示上面所加载的用户是否允许拒绝登录<br>（23）userlist_file=/etc/vsftpd/user_list 列表文件   </p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git操作总结]]></title>
      <url>http://robinheztto.com/2015/05/23/git-operate/</url>
      <content type="html"><![CDATA[<hr>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ol>
<li><p>配置<br>Usage: git config –global|–system|–local|–list<br><code>$ git config --global user.name [username]</code><br><code>$ git config --global user.email [email]</code><br><code>$ git config --global color.ui true</code></p>
</li>
<li><p>初始化版本库<br><code>$ git init</code></p>
</li>
<li><p>暂存<br><code>$ git add .</code><br><code>$ git add -u</code>   暂存已跟踪文件<br><code>$ git add -A</code>   跟踪文件并暂存<br><code>$ git add -p</code>   选择性暂存文件</p>
</li>
<li><p>状态查看<br><code>$ git status</code><br><code>$ git status -s</code> 精简显示   </p>
</li>
<li><p>比较<br>工作区与暂存区比较:<br><code>$ git diff</code><br>暂存区与HEAD(版本库当前分支)比较:<br><code>$ git diff --staged</code><br>工作,暂存区(未提交修改)与HEAD(版本库当前分支)比较:<br><code>$ git diff HEAD</code></p>
</li>
<li><p>撤销<br>撤销工作区修改:<br><code>$ git checkout .</code><br>该命令会将暂存区全部文件或指定文件替换工作区对应文件<br><code>$ git checkout -- &lt;file&gt;</code>   </p>
<p>撤销工作区,暂存区修改:<br><code>$ git checkout HEAD .</code><br><code>$ git checkout HEAD &lt;file&gt;</code><br>该命令会将HEAD所指向的master分支全部或指定文件替换到工作区,暂存区,</p>
<p>暂存区域撤销:<br><code>$ git reset HEAD</code></p>
</li>
<li><p>移除<br>暂存区移除:<br><code>$ git rm --cached &lt;file&gt;</code>  </p>
</li>
<li><p>日志查看<br><code>git log</code>   </p>
</li>
<li><p>其他</p>
</li>
<li>修改远程仓库url:<br><code>git remote set-url origin new-url</code></li>
</ol>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[remastersys 备份/制作ubuntu副本]]></title>
      <url>http://robinheztto.com/2015/03/18/remastersys-md/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Remastersys是由Tony Brijeski 发起的免费软件项目,可以把已安装的Ubuntu、Debian及其衍生版打包成一个可以用来安装的Live CD/DVD的iso文件.</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>环境: ubuntu14.04</li>
<li>步骤:<br><code>$ wget &quot;https://www.freesoftwareservers.com/wp-content/uploads/2015/12/remastersys-gui.zip&quot; &amp;&amp; unzip remastersys-gui.zip &amp;&amp; cd remastersys-gui</code><br><code>$ sudo dpkg -i *.deb</code><br>如果报错,强制执行安装<br><code>$ echo y | sudo apt-get install -f</code></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>语法:<br>sudo remastersys backup|clean|dist [cdfs|iso] [filename.iso]<br>Backup：备份整个系统，包括你的个人数据和配置信息<br>Dist：打包整个系统，不包括你的个人数据和配置信息</p>
</li>
<li><p>用例:<br>sudo remastersys backup   (to make a livecd/dvd backup of your system)<br>sudo remastersys backup custom.iso (to make a livecd/dvd backup and call the iso custom.iso)<br>sudo remastersys clean    (to clean up temporary files of remastersys)<br>sudo remastersys dist     (to make a distributable livecd/dvd of your system)<br>sudo remastersys dist cdfs(to make a distributable livecd/dvd filesystem only)<br>sudo remastersys dist iso custom.iso(to make a distributable iso named custom.iso but onlyif the cdfs is already present)   </p>
</li>
<li><p>制作过程<br><code>$ sudo remastersys dist</code><br><img src="http://7xrz32.com1.z0.glb.clouddn.com/remastersys.png" alt="remastersys dist"><br>根据系统打包大小,执行时间在十几分钟到数小时,目标ISO文件生成在home/remastersys/remastersys/下<br>使用ubuntu系统自带工具制作U盘启动盘<br><img src="http://7xrz32.com1.z0.glb.clouddn.com/make.png" alt="make"><br>制作完成,清除生成文件可使用sudo remastersys clean</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://help.ubuntu.com/community/InstallCDCustomization?action=show&amp;redirect=InstallCDCustomizationHowTo" target="_blank" rel="external">https://help.ubuntu.com/community/InstallCDCustomization?action=show&amp;redirect=InstallCDCustomizationHowTo</a>  </li>
<li><a href="https://help.ubuntu.com/community/InstallCDCustomization/Scripts" target="_blank" rel="external">https://help.ubuntu.com/community/InstallCDCustomization/Scripts</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu14.04 OpenJdk8编译]]></title>
      <url>http://robinheztto.com/2014/12/19/java-build-openjdk/</url>
      <content type="html"><![CDATA[<h1 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h1><p>如下图示，选择从官网直接下载的方式，下载地址：<a href="http://download.java.net/openjdk/jdk8/" target="_blank" rel="external">OpenJDK™ Source</a></p>
<div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/java/openjdk-source-download.png?raw=true" alt="OpenJDK™ Source Download"><br></div><br>下载后目录结构如下图示：<br><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/java/openjdk-source-list.png?raw=true" alt="OpenJDK™ Source List"><br></div>

<h1 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h1><p>编译主要参考源码目录下README及README-builds.html文件，编译前本机已安装openjdk7/8作为Bootstrap JDK。</p>
<ul>
<li>bash ./configure<br>执行configure脚本会检查并配置编译环境，根据执行过程中提示<code>apt-get install</code>安装相应的包直到执行成功为止。执行成功后将输出如下所示的信息：<div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/java/openjdk-build-configure.png?raw=true" alt="OpenJDK™ Source Configure"><br></div></li>
<li>Make<br><code>export LANG=C</code><br><code>make all</code><br>编译output在build/linux-x86_64-normal-server-release下,编译过程中错误解决：<br>This OS is not supported:” <code>uname -a</code>;<br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/java/openjdk-build-os-not-support.png?raw=true" alt="OpenJDK™ Source Configure"><br>解决方法：修改hotspot/make/linux/Makefile在SUPPORTED_OS_VERSION选项加上4%。<code>SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3% 4%</code></li>
<li>Test<br>编译成功后输出如下信息：<div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/java/openjdk-source-build-success.png?raw=true" alt="OpenJDK™ Source Build Result"><br></div><br>测试编译生成java可执行文件：<br><div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/java/openjdk-source-build-test.png?raw=true" alt="OpenJDK™ Source Build Test"><br></div>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java核心技术之关键字]]></title>
      <url>http://robinheztto.com/2014/01/14/java-keyword/</url>
      <content type="html"><![CDATA[<h1 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final finally finalize"></a>final finally finalize</h1><ol>
<li><p>final可以用来修饰类，方法，变量。final修饰的类不能被继承扩展，修饰的方法不能被覆盖重写，修饰的变量初始化后不能被修改。<br>注意，final 并不等同于 immutable，如下代码所示，final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象行为不被 final 影响，添加元素等操作是完全正常的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final List&lt;String&gt; strList = new ArrayList&lt;&gt;();</span><br><span class="line">strList.add(&quot;Hello&quot;);</span><br><span class="line">strList.add(&quot;world&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>finally是java保证重点代码一定被执行的机制，可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。<br>下面的情况finally不会执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	// do something</span><br><span class="line">	System.exit(1);</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">	System.out.println(“Print from finally”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在垃圾回收前执行指定的资源回收操作，在jdk9中，finalize被标记为deprecated。<br>finalize的执行是和垃圾收集关联在一起的，一旦实现了非空的 finalize 方法，就会导致相应对象回收呈现数量级上的变慢，有人专门做过 benchmark，大概是 40~50 倍的下降。finalize被设计成在对象被垃圾收集前调用，这就意味着实现了finalize方法的对象是个“特殊公民”，JVM 要对它进行额外处理，finalize 本质上成为了快速回收的阻碍者，可能导致对象经过多个垃圾收集周期才能被回收。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java核心技术之异常处理机制]]></title>
      <url>http://robinheztto.com/2014/01/07/java-exception-error/</url>
      <content type="html"><![CDATA[<blockquote>
<p>异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。</p>
</blockquote>
<h1 id="Exception与Error，运行时异常与一般异常的区别"><a href="#Exception与Error，运行时异常与一般异常的区别" class="headerlink" title="Exception与Error，运行时异常与一般异常的区别"></a>Exception与Error，运行时异常与一般异常的区别</h1><p>Exception和Error都是继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。<br>Exception和Error体现了Java平台设计者对不同异常情况的分类。Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。<br>Exception又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p>
<center><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/java/throwable.png?raw=true" alt="xxx"><br></center>


<h1 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h1><p>Java 定义在 java.lang 包中的非检查性异常类。</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArithmeticException</td>
<td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td>
</tr>
<tr>
<td>ArrayStoreException</td>
<td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td>
</tr>
<tr>
<td>ClassCastException</td>
<td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td>
</tr>
<tr>
<td>IllegalMonitorStateException</td>
<td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td>
</tr>
<tr>
<td>IllegalThreadStateException</td>
<td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td>
</tr>
<tr>
<td>NegativeArraySizeException</td>
<td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td>
</tr>
<tr>
<td>SecurityException</td>
<td>由安全管理器抛出的异常，指示存在安全侵犯。</td>
</tr>
<tr>
<td>StringIndexOutOfBoundsException</td>
<td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td>
</tr>
<tr>
<td>UnsupportedOperationException</td>
<td>当不支持请求的操作时，抛出该异常。</td>
</tr>
</tbody>
</table>
<p>Java 定义在 java.lang 包中的检查性异常类。</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassNotFoundException</td>
<td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td>
</tr>
<tr>
<td>CloneNotSupportedException</td>
<td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>拒绝访问一个类的时候，抛出该异常。</td>
</tr>
<tr>
<td>InstantiationException</td>
<td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td>
</tr>
<tr>
<td>InterruptedException</td>
<td>一个线程被另一个线程中断，抛出该异常。</td>
</tr>
<tr>
<td>NoSuchFieldException</td>
<td>请求的变量不存在</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>请求的方法不存在</td>
</tr>
</tbody>
</table>
<h1 id="异常处理的基本语法"><a href="#异常处理的基本语法" class="headerlink" title="异常处理的基本语法"></a>异常处理的基本语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">     //try块中放可能发生异常的代码。</span><br><span class="line">     //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span><br><span class="line">     //如果发生异常，则尝试去匹配catch块。</span><br><span class="line">&#125; catch (SQLException SQLexception) &#123;</span><br><span class="line">    //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span><br><span class="line">    //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span><br><span class="line">    //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span><br><span class="line">    //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span><br><span class="line">    //如果try中没有发生异常，则所有的catch块将被忽略。</span><br><span class="line">&#125; catch (Exception exception) &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //finally块通常是可选的。</span><br><span class="line">    //无论异常是否发生，异常是否匹配被处理，finally都会执行。</span><br><span class="line">    //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span><br><span class="line">    //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理原则"><a href="#异常处理原则" class="headerlink" title="异常处理原则"></a>异常处理原则</h2><ul>
<li>try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</li>
<li>每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。</li>
<li>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常，代码应该能够直观地体现出尽量多的信息，而泛泛的Exception之类，恰恰隐藏了我们的目的。另外，也要保证程序不会捕获到不希望捕获的异常。比如，可能更希第二，不要生吞（swallow）异常望 RuntimeException 被扩散出来，而不是被捕获。</li>
<li>不要生吞（swallow）异常。</li>
<li>不要在finally里面抛异常，如果finally里也抛异常，就会导致真正的异常信息丢失，只会收到finally里抛的异常。</li>
<li>勿将异常用于控制流。</li>
</ul>
<h2 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h2><p>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()。因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。</p>
<p>良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。<br>需要注意的地方:</p>
<ul>
<li>finally块没有处理异常的能力。处理异常的只能是catch块。</li>
<li>在同一try…catch…finally块中，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。</li>
<li>在同一try…catch…finally块中，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。</li>
</ul>
<h2 id="throw-异常抛出语句"><a href="#throw-异常抛出语句" class="headerlink" title="throw 异常抛出语句"></a>throw 异常抛出语句</h2><p>throw exceptionObject<br>可以通过throw语句手动显式的抛出一个异常，throw语句的后面必须是一个异常对象。throw语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，它和由JRE自动形成的异常抛出点没有任何差别。</p>
<h1 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h1><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。<br>所有异常都必须是 Throwable 的子类。<br>如果希望写一个检查性异常类，则需要继承 Exception 类。<br>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</p>
<h1 id="try-with-resources-Java-SE7"><a href="#try-with-resources-Java-SE7" class="headerlink" title="try-with-resources(Java SE7)"></a>try-with-resources(Java SE7)</h1><p>try-with-resources语句是一种声明了一种或多种资源的try语句。资源是指在程序用完了之后必须要关闭的对象，try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。任何实现了java.lang.AutoCloseable接口的对象，和实现了java.io.Closeable接口的对象，都可以当做资源使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try (BufferedReader br = new BufferedReader(…);</span><br><span class="line">     BufferedWriter writer = new BufferedWriter(…)) &#123;// Try-with-resources</span><br><span class="line">// do something</span><br><span class="line">catch ( IOException | XEception e) &#123;// Multiple catch</span><br><span class="line">   // Handle it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java SE7之前，使用finally代码块来确保资源一定被关闭，无论try语句正常结束还是异常结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(new FileReader(path));</span><br><span class="line">try &#123;</span><br><span class="line">	// do something</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (br != null) br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="NoClassDefFoundError与ClassNotFoundException的区别"><a href="#NoClassDefFoundError与ClassNotFoundException的区别" class="headerlink" title="NoClassDefFoundError与ClassNotFoundException的区别"></a>NoClassDefFoundError与ClassNotFoundException的区别</h1><p>NoClassDefFoundError是一个错误(Error)，而ClassNOtFoundException是一个异常，在Java中对于错误和异常的处理是不同的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。<br>ClassNotFoundException的产生原因：</p>
<p>Java支持使用Class.forName方法来动态地加载类，任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。</p>
<p>ClassNotFoundException的产生原因：</p>
<p>Java支持使用Class.forName方法来动态地加载类，任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br>ClassNotFoundException的产生原因主要是：<br>Java支持使用反射方式在运行时动态加载类，例如使用Class.forName方法来动态地加载类时，可以将类名作为参数传递给上述方法从而将指定类加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。<br>解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。<br>另外还有一个导致ClassNotFoundException的原因就是：当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。通过控制动态类加载过程，可以避免上述情况发生。</p>
<p>NoClassDefFoundError产生的原因在于：<br>如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError.<br>造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java核心技术之对Java平台的理解]]></title>
      <url>http://robinheztto.com/2014/01/01/java-think-platform/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Java是一种面向对象的语言，最显著的特性有两个：一是“Write once, run anywhere”（一次编写，到处运行），平台无关性；另外就是自动垃圾回收（GC，Garbage Collection）机制，Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</p>
</blockquote>
<p><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/java/java-platform.png?raw=true" alt="Java Platform"></p>
<h1 id="Java是解释执行吗？"><a href="#Java是解释执行吗？" class="headerlink" title="Java是解释执行吗？"></a>Java是解释执行吗？</h1><p>这个说法不太准确。Java源代码首先通过Javac编译成为字节码（bytecode），然后在运行时，通过Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的JVM，比如Oracle JDK提供的Hotspot JVM，都提供了JIT（Just-In-Time）编译器，也就是通常所说的动态编译器。根据二八定律，消耗大部分系统资源的只有一小部分的代码（热点代码），而这也就是JIT所需要编译的部分，JIT能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行。<br>除了JIT，还有一种新的编译方式，即AOT（Aheadof-TimeCompilation），直接将字节码编译成机器代码，这样就避免了JIT预热等各方面的开销，Oracle JDK 9就引入了实验性的AOT特性，并且增加了新的jaotc工具。</p>
<h1 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h1 id="Java类库"><a href="#Java类库" class="headerlink" title="Java类库"></a>Java类库</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="IO-NIO"><a href="#IO-NIO" class="headerlink" title="IO/NIO"></a>IO/NIO</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h2 id="JDK工具"><a href="#JDK工具" class="headerlink" title="JDK工具"></a>JDK工具</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java系列之JVM内存区域]]></title>
      <url>http://robinheztto.com/2013/05/24/java-jvm-memory-area/</url>
      <content type="html"><![CDATA[<h1 id="Java虚拟机基本结构"><a href="#Java虚拟机基本结构" class="headerlink" title="Java虚拟机基本结构"></a>Java虚拟机基本结构</h1><div align="center"><br><img src="https://github.com/RobinHeZtto/Resource/blob/master/blog/image/java/java-jvm.jpeg?raw=true" alt="java-jvm"><br></div>

<p>如上图示，Java虚拟机包括垃圾回收，类加载子系统，运行时数据区域，执行引擎，JNI，本地库接口等模块。</p>
<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM运行时内存区域包括方法区，堆，栈，程序计数器，本地方法栈。其中，方法区与堆是所有线程共享数据区，而栈，程序计数器，本地方法栈是线程隔离的数据区。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器指的是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<ul>
<li>每个线程都有自己的独立的程序计数器。</li>
<li>如果线程正在执行的是Java方法，那么这个计数器的值就是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法,这个计数器值为空(undefined)。</li>
<li>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>Java虚拟机栈是Java方法执行的内存区域，每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。Java虚拟机栈是线程私有的，它的生命周期与线程相同。局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型(指向了一条字节码指令的地址)。</p>
<p>如果线程请求栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，无法申请到内存抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地栈则为虚拟机使用到的Native方法服务。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是线程共享的，在虚拟机启动时创建。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为:新生代和老年代。再细致一点的有Eden空间、From    Survivor空间、ToSurvivor空间等。在实现时,既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>线程共享,用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。(JDK1.7后，字面量(interned strings)，类的静态变量(class statics)转移到了java heap)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Programming in the UNIX Environment]]></title>
      <url>http://robinheztto.com/2013/03/01/programming-in-the-UNIX-environment/</url>
      <content type="html"><![CDATA[<blockquote>
<p>程序：存储在磁盘上的可执行文件。<br>进程：程序的执行实例，包括进程地址空间，系统IO资源等</p>
</blockquote>
<div align="center"><br><img src="https://github.com/XRobinHe/Resource/blob/master/blog/image/others/unix-architecture.png?raw=true" alt="UNIX操作系统体系结构"><br></div>

<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><blockquote>
<p>进程创建，进程执行，进程终止，进程属性</p>
</blockquote>
<h2 id="进程标志"><a href="#进程标志" class="headerlink" title="进程标志"></a>进程标志</h2><p>每个进程都有一个非负整形值的唯一进程ID，即进程ID。获取相关ID的api如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t getpid(void);//返回调用进程的进程ID</span><br><span class="line">pid_t getppid(void);//返回调用进程的父进程ID</span><br><span class="line"></span><br><span class="line">uid_t getuid(void);//返回调用进程的实际用户ID</span><br><span class="line">uid_t geteuid(void);//返回调用进程的有效用户ID</span><br><span class="line"></span><br><span class="line">gid_t getgid(void);//返回调用进程的实际用户组ID</span><br><span class="line">gid_t getegid(void);//返回调用进程的有效组用户ID</span><br></pre></td></tr></table></figure></p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>一个现有进程可通过调用fork()创建一个新进程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t fork(void);//子进程返回０，父进程返回子进程ID，出错则返回-1</span><br></pre></td></tr></table></figure></p>
<p>由fork()创建的新进程称为子进程，fork()调用一次返回二次，在父进程中返回子进程ID，在子进程中返回0。在fork()成功后，父子进程的执行顺序是不确定的，取决于调度算法。<br>在执行fork()调用以后，父子进程的内存映像共享(包括数据段/代码段/堆/栈/打开的文件/uid/gid／umask等),只有在子进程修改这些区域时才会为该内存区域创建父进程的副本，即写时复制(Copy-on-Write,COW)。</p>
<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h2><p>vfork()用于创建一个新进程并且保证子进程先运行，只有当子进程调用exec或exit之后父进程才有可能被调度回复运行,如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。`<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t vfork(void);</span><br></pre></td></tr></table></figure></p>
<p>vfork与fork另一个重要的区别就是ork要拷贝父进程的进程映像，而vfork在子进程没有调用exec和exit之前，子进程与父进程<strong>共享</strong>进程环境。</p>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>一般在fork出新的子进程后会在子进程中调用exec执行另一个程序。当调用exec函数执行时，进程执行的程序替换为新程序，前后的进程ID并未改变，即exec替换了当前进程的代码段、数据端、堆段、栈段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">extern char **environ;</span><br><span class="line"></span><br><span class="line">int execl(const char *path, const char *arg, ...);</span><br><span class="line">int execlp(const char *file, const char *arg, ...);</span><br><span class="line">int execle(const char *path, const char *arg,</span><br><span class="line">           ..., char * const envp[]);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execvpe(const char *file, char *const argv[],</span><br><span class="line">            char *const envp[]);</span><br></pre></td></tr></table></figure></p>
<h2 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait/waitpid"></a>wait/waitpid</h2><p>当某个进程异常或正常终止时，内核就向其父进程发送SIGCHLD信号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">//返回值，成功返回退出进程的ID，出错返回０或-1</span><br><span class="line"></span><br><span class="line">pid_t wait(int *status);</span><br><span class="line"></span><br><span class="line">pid_t waitpid(pid_t pid, int *status, int options);</span><br></pre></td></tr></table></figure></p>
<p>wait与waitpid的区别如下：</p>
<ul>
<li>调用wait在子进程终止前将阻塞当前进程。</li>
<li>waitpid可选参数可使子进程终止前不阻塞当前进程，并且可控制等待的进程。</li>
</ul>
<p>waitpid()中的pid参数作用如下：<br>pid==-1,等待任一子进程，此时wait与waitpid等效。<br>pid&gt;0，等代进程ID与pid相等进程。<br>pid==0,等待组ID等于调用进程组ID的任一子进程。<br>pid&lt;0,等待组ID等于pid的任一子进程。</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><blockquote>
<p>IPC InterProcess Communication.</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java语言基础]]></title>
      <url>http://robinheztto.com/2013/01/21/java-basics/</url>
      <content type="html"><![CDATA[<ul>
<li>数据类型<br>由于java的平台无关性，java所有基本数据类型的存储大小及取值范围固定，且没有signed与unsigned之分，默认为signed类型，所以java也没有sizeof关键字。</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th style="text-align:center">长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>byte</td>
<td style="text-align:center">1bit</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">2byte</td>
</tr>
<tr>
<td>int</td>
<td style="text-align:center">4byte</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">8byte</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:center">4byte</td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">8byte</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言基础]]></title>
      <url>http://robinheztto.com/2013/01/21/c-basics/</url>
      <content type="html"><![CDATA[<h1 id="类型-运算符-表达式"><a href="#类型-运算符-表达式" class="headerlink" title="类型/运算符/表达式"></a>类型/运算符/表达式</h1><p>变量与常量是程序处理的两种基本数据对象，通过运算符表达式将变量与常量进行组合来产生新的值，而对象的类型决定了可取值的集合与可执行的操作。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Ｃ语言中数据对象分成基本数据类型，指针类型，枚举类型，void类型，组合类型。</p>
<ul>
<li>基本数据类型<br>基本数据类型中的整型可分为有符号signed型与无符号unsigned型。</li>
</ul>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th style="text-align:center">32-bit</th>
<th style="text-align:right">64-bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td style="text-align:center">1</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>short</td>
<td style="text-align:center">2</td>
<td style="text-align:right">2</td>
</tr>
<tr>
<td>int</td>
<td style="text-align:center">4</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td>long</td>
<td style="text-align:center">4</td>
<td style="text-align:right">8</td>
</tr>
<tr>
<td>float</td>
<td style="text-align:center">4</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td>double</td>
<td style="text-align:center">8</td>
<td style="text-align:right">8</td>
</tr>
</tbody>
</table>
<ul>
<li><p>指针类型</p>
</li>
<li><p>void类型</p>
</li>
<li><p>组合类型，包括数组，结构体struct，联合体union，枚举类型enum</p>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:center">结合性</th>
</tr>
</thead>
<tbody>
<tr>
<td>()　 []　 -&gt;　 .</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>! 　~ 　++　 –　 + 　- 　*　 (type)　 sizeof</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td>* 　/　 %</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>+ 　-</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>&lt;&lt; 　&gt;&gt;</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>&lt; 　&lt;= 　&gt; 　&gt;=</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>== 　!=　</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>&amp;</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>^</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>&#124;</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>?:</td>
<td style="text-align:center">从左到右</td>
</tr>
<tr>
<td>= +=   -=   *=   /=   %=   &amp;=   ^=   &#124;=   &lt;&lt;=   &gt;&gt;=</td>
<td style="text-align:center">从右到左</td>
</tr>
<tr>
<td>,</td>
<td style="text-align:center">从右到左</td>
</tr>
</tbody>
</table>
<ul>
<li><p>ASCII编码</p>
</li>
<li><p>关键字<br>static<br>const<br>volatile<br>continue<br>break</p>
</li>
</ul>
<ul>
<li><p>true or false<br>Ｃ语言中，非０表示真，０表示假</p>
</li>
<li><p>const<br>const并不能把变量变为常量，只是通过编译器限定其只读属性。</p>
</li>
</ul>
<p>预处理，编译，汇编，链接，加载</p>
<ul>
<li>链接脚本<br>lds文件，定义链接过程中各代码段的存储顺序<br>链接器对部分地址进行绑定并分配相对地址，加载器完成重定位并赋予实际地址。</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/" target="_blank" rel="external">Linux C编程一站式学习</a></li>
<li>《链接器和加载器》</li>
<li>《C专家编程》</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu ssh git服务搭建]]></title>
      <url>http://robinheztto.com/2012/09/03/ubuntu-ssh-git/</url>
      <content type="html"><![CDATA[<ul>
<li>安装git与ssh</li>
</ul>
<ol>
<li><code>$ sudo apt-get install git-core</code></li>
<li><code>$ sudo apt-get install openssh-server</code></li>
<li><code>$ sudo apt-get install openssh-client</code></li>
</ol>
<ul>
<li>安装python setuptools</li>
</ul>
<ol>
<li><code>$ sudo apt-get install python-setuptools</code></li>
</ol>
<ul>
<li>下载安装gitosis</li>
</ul>
<ol>
<li><code>$ git clone https://github.com/res0nat0r/gitosis.git</code></li>
<li><code>$ cd gitosis/</code></li>
<li><code>$ sudo python setup.py install</code></li>
</ol>
<ul>
<li><p>添加git账户<br><code>$ sudo adduser \
　　--system \
　　--shell /bin/sh \
　　--gecos &#39;git version control&#39; \
　　--group \
　　--disabled-password \
　　--home /home/git \
　　git</code></p>
</li>
<li><p>生成rsa密钥（已有~/.ssh/id_rsa.pub略过此步）</p>
</li>
</ul>
<ol>
<li><code>$ ssh-keygen -t rsa</code></li>
</ol>
<ul>
<li>上传管理账户公钥到服务器（可直接copy至server）</li>
</ul>
<ol>
<li><code>$ scp ~/.ssh/id_rsa.pub git@127.0.0.1:/tmp</code>   （scp ~/.ssh/id_rsa.pub 用户名@主机:/tmp）</li>
</ol>
<ul>
<li>初使化gitosis</li>
</ul>
<ol>
<li><code>$ sudo -H -u git gitosis-init &lt; /tmp/id_rsa.pub</code></li>
</ol>
<ul>
<li>修改post-update权限</li>
</ul>
<ol>
<li><code>$ sudo chmod 755 /home/git/repositories/gitosis-admin.git/hooks/post-update</code></li>
</ol>
<ul>
<li>clone gitosis管理平台</li>
</ul>
<ol>
<li><code>$ git clone git@127.0.0.1:gitosis-admin.git</code>  （git clone git@主机名:gitosis-admin.git）</li>
</ol>
<ul>
<li>安装完成<br>　　通过修改gitosis-admin管理gitosis用户权限，添加公密到keydir，添加用户，修改完后commit，push到中服务器即可完成仓库权限的相关操作。</li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
